!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
ACQ_CID	shader.h	/^      ACQ_CID,$/;"	e	enum:tx_log_walker::commit_tx_state_t
ACQ_CU_ENTRIES	shader.h	/^      ACQ_CU_ENTRIES,$/;"	e	enum:tx_log_walker::commit_tx_state_t
ADDRDEC_H	addrdec.h	34;"	d
ADDR_CHIP_S	addrdec.h	/^   int ADDR_CHIP_S;$/;"	m	class:linear_to_raw_address_translation
ALU_HAZARD	scoreboard.h	/^   ALU_HAZARD,$/;"	e	enum:data_hazard_t
ASSOC	gpu-cache.h	/^    ASSOC \/\/ normal cache $/;"	e	enum:mshr_config_t
ATAG_READ	shader.h	/^      ATAG_READ$/;"	e	enum:tx_log_walker::log_acc_type_t
BANK_ACTIVE	dram.h	41;"	d
BANK_IDLE	dram.h	40;"	d
BK	addrdec.h	/^      BK    = 1,$/;"	e	enum:linear_to_raw_address_translation::__anon1
BK_CONF	stats.h	/^   BK_CONF,$/;"	e	enum:mem_stage_stall_type
BL	gpu-sim.h	/^   unsigned BL;     \/\/Burst Length in bytes (4 in GDDR3, 8 in GDDR5)$/;"	m	struct:memory_config
BURST	addrdec.h	/^      BURST = 4,$/;"	e	enum:linear_to_raw_address_translation::__anon1
CCDLc	dram.h	/^	unsigned int CCDLc;$/;"	m	struct:bankgrp_t
CCDc	dram.h	/^   unsigned int CCDc;$/;"	m	class:dram_t
CHIP	addrdec.h	/^      CHIP  = 0,$/;"	e	enum:linear_to_raw_address_translation::__anon1
CL	gpu-sim.h	/^   unsigned CL;     \/\/CAS latency$/;"	m	struct:memory_config
COAL_STALL	stats.h	/^   COAL_STALL,$/;"	e	enum:mem_stage_stall_type
COHERENCE_MANAGER_H_	coherence_manager.h	9;"	d
COH_HIT	coherence_manager.h	/^        COH_HIT,$/;"	e	enum:coherence_cache_request_status
COH_INVALID	coherence_manager.h	/^        COH_INVALID,$/;"	e	enum:coherence_cache_block_state
COH_MISS	coherence_manager.h	/^        COH_MISS,$/;"	e	enum:coherence_cache_request_status
COH_MISS_EVICTION	coherence_manager.h	/^        COH_MISS_EVICTION$/;"	e	enum:coherence_cache_request_status
COH_MODIFIED	coherence_manager.h	/^        COH_MODIFIED$/;"	e	enum:coherence_cache_block_state
COH_SHARED	coherence_manager.h	/^        COH_SHARED,$/;"	e	enum:coherence_cache_block_state
COL	addrdec.h	/^      COL   = 3,$/;"	e	enum:linear_to_raw_address_translation::__anon1
COMMIT_READY	commit_unit.h	/^   COMMIT_READY,$/;"	e	enum:commit_state
COMMIT_SENT	commit_unit.h	/^   COMMIT_SENT,$/;"	e	enum:commit_state
COMMIT_UNIT_H	commit_unit.h	2;"	d
COMMIT_WRITE	commit_unit.h	/^   COMMIT_WRITE$/;"	e	enum:cu_mem_op
CONCRETE_SCHEDULER_GTO	shader.h	/^    CONCRETE_SCHEDULER_GTO,$/;"	e	enum:concrete_scheduler
CONCRETE_SCHEDULER_LRR	shader.h	/^    CONCRETE_SCHEDULER_LRR = 0,$/;"	e	enum:concrete_scheduler
CONCRETE_SCHEDULER_TWO_LEVEL_ACTIVE	shader.h	/^    CONCRETE_SCHEDULER_TWO_LEVEL_ACTIVE,$/;"	e	enum:concrete_scheduler
CONCRETE_SCHEDULER_WARP_LIMITING	shader.h	/^    CONCRETE_SCHEDULER_WARP_LIMITING,$/;"	e	enum:concrete_scheduler
CONSTANT	stat-tool.cc	/^   NORMAL, TEXTURE, CONSTANT, INSTRUCTION$/;"	e	enum:cache_access_logger_types	file:
CONST_MSHR_MERGE	gpu-sim.h	55;"	d
CORE	gpu-sim.cc	93;"	d	file:
CPP	Makefile	/^CPP = g++ $(SNOW)$/;"	m
CREATELOG	gpu-sim.h	61;"	d
CSRCS	Makefile	/^CSRCS = $(filter-out $(EXCLUDES), $(SRCS))$/;"	m
CURRENT_STAT_IDX	power_stat.h	/^    CURRENT_STAT_IDX = 0,    \/\/ Current activity count$/;"	e	enum:_stat_idx
CU_ALLOC_FAIL	mem_fetch.h	/^    CU_ALLOC_FAIL,$/;"	e	enum:mf_type
CU_ALLOC_PASS	mem_fetch.h	/^    CU_ALLOC_PASS,$/;"	e	enum:mf_type
CU_DONE_COMMIT	mem_fetch.h	/^    CU_DONE_COMMIT,$/;"	e	enum:mf_type
CU_FAIL	mem_fetch.h	/^    CU_FAIL,$/;"	e	enum:mf_type
CU_PASS	mem_fetch.h	/^    CU_PASS,$/;"	e	enum:mf_type
CXXFLAGS	Makefile	/^	CXXFLAGS = -Wall -DDEBUG$/;"	m
CXXFLAGS	Makefile	/^	CXXFLAGS = -Wall$/;"	m
C_MEM	stats.h	/^   C_MEM,$/;"	e	enum:mem_stage_access_type
DATA_PORT_STALL	stats.h	/^   DATA_PORT_STALL,$/;"	e	enum:mem_stage_stall_type
DATA_READ	shader.h	/^      DATA_READ,$/;"	e	enum:tx_log_walker::log_acc_type_t
DEBUG	Makefile	/^DEBUG?=0$/;"	m
DEBUGL1MISS	gpu-misc.h	34;"	d
DEC2ZERO	dram.cc	202;"	d	file:
DELAYQUEUE_H	delayqueue.h	33;"	d
DRAM	gpu-sim.cc	95;"	d	file:
DRAM_FIFO	gpu-sim.h	/^   DRAM_FIFO=0,$/;"	e	enum:dram_ctrl_t
DRAM_FRFCFS	gpu-sim.h	/^   DRAM_FRFCFS=1$/;"	e	enum:dram_ctrl_t
DRAM_H	dram.h	30;"	d
DUMPLOG	gpu-sim.h	63;"	d
DYNAMIC_WARP_PRINT_RESOLUTION	shader.cc	703;"	d	file:
EXCLUDES	Makefile	/^EXCLUDES = $/;"	m
EX_WB	shader.h	/^    EX_WB,$/;"	e	enum:pipeline_stage_name_t
FAIL	commit_unit.h	/^   FAIL,$/;"	e	enum:commit_state
FIFO	gpu-cache.h	/^    FIFO$/;"	e	enum:replacement_policy_t
FILL	commit_unit.h	/^   FILL, $/;"	e	enum:commit_state
GLOBAL_MSHR_MERGE	gpu-sim.h	56;"	d
GPU_CACHE_H	gpu-cache.h	29;"	d
GPU_MEMLATSTAT_MC	gpu-sim.h	51;"	d
GPU_MISC_H	gpu-misc.h	30;"	d
GPU_RSTAT_BW_STAT	gpu-sim.h	45;"	d
GPU_RSTAT_DWF_MAP	gpu-sim.h	47;"	d
GPU_RSTAT_L1MISS	gpu-sim.h	48;"	d
GPU_RSTAT_PDOM	gpu-sim.h	49;"	d
GPU_RSTAT_SCHED	gpu-sim.h	50;"	d
GPU_RSTAT_SHD_INFO	gpu-sim.h	44;"	d
GPU_RSTAT_WARP_DIS	gpu-sim.h	46;"	d
GPU_SIM_H	gpu-sim.h	29;"	d
G_MEM_LD	stats.h	/^   G_MEM_LD,$/;"	e	enum:mem_stage_access_type
G_MEM_ST	stats.h	/^   G_MEM_ST,$/;"	e	enum:mem_stage_access_type
HAZARD_DETECT	commit_unit.h	/^   HAZARD_DETECT, $/;"	e	enum:commit_state
HISTOGRAM_H	histogram.h	29;"	d
HIT	gpu-cache.h	/^    HIT = 0,$/;"	e	enum:cache_request_status
HIT_PARTIAL	gpu-cache.h	/^    HIT_PARTIAL,$/;"	e	enum:cache_request_status
HIT_RESERVED	gpu-cache.h	/^    HIT_RESERVED,$/;"	e	enum:cache_request_status
IBUFFER_SIZE	shader.h	/^    static const unsigned IBUFFER_SIZE=2;$/;"	m	class:shd_warp_t
ICNT	gpu-sim.cc	96;"	d	file:
ICNT_RC_FAIL	stats.h	/^   ICNT_RC_FAIL,$/;"	e	enum:mem_stage_stall_type
ICNT_WRAPPER_H	icnt_wrapper.h	29;"	d
IDLE	shader.h	/^      IDLE = 0,$/;"	e	enum:tx_log_walker::commit_tx_state_t
ID_OC_MEM	shader.h	/^    ID_OC_MEM,  $/;"	e	enum:pipeline_stage_name_t
ID_OC_SFU	shader.h	/^    ID_OC_SFU,  $/;"	e	enum:pipeline_stage_name_t
ID_OC_SP	shader.h	/^    ID_OC_SP=0,$/;"	e	enum:pipeline_stage_name_t
INPIPE	shader.h	/^   INPIPE = 0,$/;"	e	enum:thread_state
INSTRUCTION	stat-tool.cc	/^   NORMAL, TEXTURE, CONSTANT, INSTRUCTION$/;"	e	enum:cache_access_logger_types	file:
INTERSIM	icnt_wrapper.h	/^   INTERSIM = 1,$/;"	e	enum:network_mode
INTRA_WARP_CD	shader.h	/^      INTRA_WARP_CD,$/;"	e	enum:tx_log_walker::commit_tx_state_t
INVALID	gpu-cache.h	/^    INVALID,$/;"	e	enum:cache_block_state
INVALID	shader.h	/^      INVALID = 0, $/;"	e	enum:tx_log_walker::log_acc_type_t
L2	gpu-sim.cc	94;"	d	file:
L2_L2tocblength	mem_latency_stat.h	/^   unsigned int *L2_L2tocblength;$/;"	m	class:memory_stats_t
L2_L2todramlength	mem_latency_stat.h	/^   unsigned int *L2_L2todramlength;$/;"	m	class:memory_stats_t
L2_cbtoL2length	mem_latency_stat.h	/^   unsigned int *L2_cbtoL2length;$/;"	m	class:memory_stats_t
L2_cbtoL2writelength	mem_latency_stat.h	/^   unsigned int *L2_cbtoL2writelength;$/;"	m	class:memory_stats_t
L2_dram_queue_empty	l2cache.cc	/^bool memory_sub_partition::L2_dram_queue_empty() const$/;"	f	class:memory_sub_partition
L2_dram_queue_pop	l2cache.cc	/^void memory_sub_partition::L2_dram_queue_pop() $/;"	f	class:memory_sub_partition
L2_dram_queue_top	l2cache.cc	/^class mem_fetch* memory_sub_partition::L2_dram_queue_top() const$/;"	f	class:memory_sub_partition
L2_dramtoL2length	mem_latency_stat.h	/^   unsigned int *L2_dramtoL2length;$/;"	m	class:memory_stats_t
L2_dramtoL2writelength	mem_latency_stat.h	/^   unsigned int *L2_dramtoL2writelength;$/;"	m	class:memory_stats_t
L2dramout	l2cache.h	/^   class mem_fetch *L2dramout; $/;"	m	class:memory_sub_partition	typeref:class:memory_sub_partition::mem_fetch
L2icnt_interface	l2cache.h	/^        L2icnt_interface( memory_sub_partition *unit ) { m_unit = unit; }$/;"	f	class:L2icnt_interface
L2icnt_interface	l2cache.h	/^class L2icnt_interface : public mem_fetch_interface {$/;"	c
L2interface	l2cache.h	/^    L2interface( memory_sub_partition *unit ) { m_unit=unit; }$/;"	f	class:L2interface
L2interface	l2cache.h	/^class L2interface : public mem_fetch_interface {$/;"	c
LOCAL_ONLY_WRITE_ALLOCATE	gpu-cache.h	/^	LOCAL_ONLY_WRITE_ALLOCATE$/;"	e	enum:write_allocate_policy_t
LOCAL_WB_GLOBAL_WT	gpu-cache.h	/^    LOCAL_WB_GLOBAL_WT$/;"	e	enum:write_policy_t
LOGB2	gpu-misc.cc	/^unsigned int LOGB2( unsigned int v ) {$/;"	f
LOGB2_32	addrdec.cc	/^static unsigned int LOGB2_32( unsigned int v ) $/;"	f	file:
LRU	gpu-cache.h	/^    LRU,$/;"	e	enum:replacement_policy_t
L_MEM_LD	stats.h	/^   L_MEM_LD,$/;"	e	enum:mem_stage_access_type
L_MEM_ST	stats.h	/^   L_MEM_ST,$/;"	e	enum:mem_stage_access_type
MAX	gpu-sim.cc	78;"	d	file:
MAX	shader.cc	54;"	d	file:
MAX_ALU_LATENCY	shader.h	/^    static const unsigned MAX_ALU_LATENCY = 512;$/;"	m	class:shader_core_ctx
MAX_ALU_LATENCY	shader.h	/^    static const unsigned MAX_ALU_LATENCY = 512;$/;"	m	class:simd_function_unit
MAX_CORES	commit_unit.h	19;"	d
MAX_CORES	tm_conflict_detector.h	9;"	d
MAX_CTA_PER_SHADER	shader.h	74;"	d
MAX_DEFAULT_CACHE_SIZE_MULTIBLIER	gpu-cache.cc	35;"	d	file:
MC_PARTITION_INCLUDED	l2cache.h	29;"	d
MEMPART_DPRINTF	l2cache_trace.h	39;"	d
MEMPART_DPRINTF	l2cache_trace.h	52;"	d
MEMPART_DTRACE	l2cache_trace.h	35;"	d
MEMPART_DTRACE	l2cache_trace.h	51;"	d
MEMPART_PRINT_STR	l2cache_trace.h	34;"	d
MEM_FETCH_H	mem_fetch.h	29;"	d
MEM_HAZARD	scoreboard.h	/^   MEM_HAZARD$/;"	e	enum:data_hazard_t
MEM_LATENCY_STAT_H	mem_latency_stat.h	29;"	d
MEM_LATENCY_STAT_IMPL	gpu-sim.cc	99;"	d	file:
MF_TUP	mem_fetch.cc	101;"	d	file:
MF_TUP	mem_fetch.cc	105;"	d	file:
MF_TUP	mem_fetch.h	80;"	d
MF_TUP	mem_fetch.h	84;"	d
MF_TUP_BEGIN	mem_fetch.cc	100;"	d	file:
MF_TUP_BEGIN	mem_fetch.cc	104;"	d	file:
MF_TUP_BEGIN	mem_fetch.h	79;"	d
MF_TUP_BEGIN	mem_fetch.h	83;"	d
MF_TUP_END	mem_fetch.cc	102;"	d	file:
MF_TUP_END	mem_fetch.cc	106;"	d	file:
MF_TUP_END	mem_fetch.h	81;"	d
MF_TUP_END	mem_fetch.h	85;"	d
MIN	shader.cc	55;"	d	file:
MISS	gpu-cache.h	/^    MISS,$/;"	e	enum:cache_request_status
MODIFIED	gpu-cache.h	/^    MODIFIED$/;"	e	enum:cache_block_state
MSHR_RC_FAIL	stats.h	/^   MSHR_RC_FAIL,$/;"	e	enum:mem_stage_stall_type
MhZ	gpu-sim.h	59;"	d
NON_CU_OP	commit_unit.h	/^   NON_CU_OP = 0, $/;"	e	enum:cu_mem_op
NORMAL	stat-tool.cc	/^   NORMAL, TEXTURE, CONSTANT, INSTRUCTION$/;"	e	enum:cache_access_logger_types	file:
NO_ALLOC	shader.h	/^      NO_ALLOC,$/;"	e	enum:opndcoll_rfu_t::alloc_t
NO_HAZARD	scoreboard.h	/^   NO_HAZARD = 0,$/;"	e	enum:data_hazard_t
NO_OP_FLAG	shader.h	59;"	d
NO_RC_FAIL	stats.h	/^   NO_RC_FAIL = 0, $/;"	e	enum:mem_stage_stall_type
NO_WRITE_ALLOCATE	gpu-cache.h	/^	NO_WRITE_ALLOCATE,$/;"	e	enum:write_allocate_policy_t
NUM_CACHE_REQUEST_STATUS	gpu-cache.h	/^    NUM_CACHE_REQUEST_STATUS$/;"	e	enum:cache_request_status
NUM_CONCRETE_SCHEDULERS	shader.h	/^    NUM_CONCRETE_SCHEDULERS$/;"	e	enum:concrete_scheduler
NUM_ORDERING	shader.h	/^        NUM_ORDERING,$/;"	e	enum:scheduler_unit::OrderingType
NUM_STAT_IDX	power_stat.h	/^    NUM_STAT_IDX     \/\/ Total number of samples$/;"	e	enum:_stat_idx
N_ADDRDEC	addrdec.h	/^      N_ADDRDEC$/;"	e	enum:linear_to_raw_address_translation::__anon1
N_COMMIT_STATE	commit_unit.h	/^   N_COMMIT_STATE$/;"	e	enum:commit_state
N_MEM_STAGE_ACCESS_TYPE	stats.h	/^   N_MEM_STAGE_ACCESS_TYPE$/;"	e	enum:mem_stage_access_type
N_MEM_STAGE_STALL_TYPE	stats.h	/^   N_MEM_STAGE_STALL_TYPE$/;"	e	enum:mem_stage_stall_type
N_NETWORK_MODE	icnt_wrapper.h	/^   N_NETWORK_MODE$/;"	e	enum:network_mode
N_PIPELINE_STAGES	shader.h	/^    N_PIPELINE_STAGES $/;"	e	enum:pipeline_stage_name_t
N_THREAD_STATE	shader.h	/^   N_THREAD_STATE    \/\/ counting purposes only$/;"	e	enum:thread_state
OBJS	Makefile	/^OBJS = $(CSRCS:%.cc=$(OUTPUT_DIR)\/%.$(OEXT))$/;"	m
OC_EX_MEM	shader.h	/^    OC_EX_MEM,$/;"	e	enum:pipeline_stage_name_t
OC_EX_SFU	shader.h	/^    OC_EX_SFU,$/;"	e	enum:pipeline_stage_name_t
OC_EX_SP	shader.h	/^    OC_EX_SP,$/;"	e	enum:pipeline_stage_name_t
ODD_HASH_MULTIPLE	gpu-cache.cc	1599;"	d	file:
OEXT	Makefile	/^OEXT = o$/;"	m
ON_FILL	gpu-cache.h	/^    ON_FILL$/;"	e	enum:allocation_policy_t
ON_MISS	gpu-cache.h	/^    ON_MISS,$/;"	e	enum:allocation_policy_t
ORDERED_PRIORITY_FUNC_ONLY	shader.h	/^        ORDERED_PRIORITY_FUNC_ONLY,$/;"	e	enum:scheduler_unit::OrderingType
ORDERING_GREEDY_THEN_PRIORITY_FUNC	shader.h	/^        ORDERING_GREEDY_THEN_PRIORITY_FUNC = 0,$/;"	e	enum:scheduler_unit::OrderingType
OUTPUT_DIR	Makefile	/^OUTPUT_DIR=$(SIM_OBJ_FILES_DIR)\/gpgpu-sim$/;"	m
OrderingType	shader.h	/^    enum OrderingType $/;"	g	class:scheduler_unit
PASS	commit_unit.h	/^   PASS,$/;"	e	enum:commit_state
PASS_ACK_WAIT	commit_unit.h	/^   PASS_ACK_WAIT,$/;"	e	enum:commit_state
POWER_FLAGS	Makefile	/^	POWER_FLAGS = -I$(GPGPUSIM_POWER_MODEL) -DGPGPUSIM_POWER_MODEL$/;"	m
POWER_FLAGS	Makefile	/^POWER_FLAGS=$/;"	m
POWER_INTERFACE_H_	power_interface.h	29;"	d
POWER_STAT_H	power_stat.h	29;"	d
PREV_STAT_IDX	power_stat.h	/^    PREV_STAT_IDX,           \/\/ Previous sample activity count$/;"	e	enum:_stat_idx
PRINT_CYCLE	dram.cc	/^int PRINT_CYCLE = 0;$/;"	v
PRIORITIZE_MSHR_OVER_WB	shader.cc	53;"	d	file:
PROGRAM_MEM_START	shader.cc	754;"	d	file:
RASc	dram.h	/^   unsigned int RASc;$/;"	m	struct:bank_t
RCDWRc	dram.h	/^   unsigned int RCDWRc;$/;"	m	struct:bank_t
RCDc	dram.h	/^   unsigned int RCDc;$/;"	m	struct:bank_t
RCc	dram.h	/^   unsigned int RCc;$/;"	m	struct:bank_t
READ	dram.h	38;"	d
READ_ALLOC	shader.h	/^      READ_ALLOC,$/;"	e	enum:opndcoll_rfu_t::alloc_t
READ_LOG_ACC	shader.h	/^      READ_LOG_ACC,$/;"	e	enum:tx_log_walker::log_acc_type_t
READ_LOG_LOAD	shader.h	/^         READ_LOG_LOAD, $/;"	e	enum:tx_log_walker::iwcd_uarch_info::event_type
READ_ONLY	gpu-cache.h	/^    READ_ONLY,$/;"	e	enum:write_policy_t
READ_PACKET_SIZE	shader.h	66;"	d
READ_REPLY	mem_fetch.h	/^    READ_REPLY, \/\/ send to shader$/;"	e	enum:mf_type
READ_REQUEST	mem_fetch.h	/^    READ_REQUEST = 0,$/;"	e	enum:mf_type
READ_REQUEST_SENT	gpu-cache.h	/^    READ_REQUEST_SENT,$/;"	e	enum:cache_event
RESEND_RS	shader.h	/^      RESEND_RS,$/;"	e	enum:tx_log_walker::commit_tx_state_t
RESEND_WS	shader.h	/^      RESEND_WS,$/;"	e	enum:tx_log_walker::commit_tx_state_t
RESERVATION_FAIL	gpu-cache.h	/^    RESERVATION_FAIL, $/;"	e	enum:cache_request_status
RESERVED	gpu-cache.h	/^    RESERVED,$/;"	e	enum:cache_block_state
RETIRED	commit_unit.h	/^   RETIRED,$/;"	e	enum:commit_state
REVALIDATION_WAIT	commit_unit.h	/^   REVALIDATION_WAIT,$/;"	e	enum:commit_state
ROW	addrdec.h	/^      ROW   = 2,$/;"	e	enum:linear_to_raw_address_translation::__anon1
RPc	dram.h	/^   unsigned int RPc;$/;"	m	struct:bank_t
RRDc	dram.h	/^   unsigned int RRDc;$/;"	m	class:dram_t
RTPLc	dram.h	/^	unsigned int RTPLc;$/;"	m	struct:bankgrp_t
RTPc	dram.h	/^   unsigned int RTPc; \/\/ read to precharge$/;"	m	struct:bank_t
RTWc	dram.h	/^   unsigned int RTWc;   \/\/read to write penalty applies across banks$/;"	m	class:dram_t
SAMPLELOG	gpu-sim.h	62;"	d
SCHEDULER_PRIORITIZATION_GTLRR	shader.h	/^    SCHEDULER_PRIORITIZATION_GTLRR, \/\/ Greedy Then Loose Round Robin$/;"	e	enum:scheduler_prioritization_type
SCHEDULER_PRIORITIZATION_GTO	shader.h	/^    SCHEDULER_PRIORITIZATION_GTO, \/\/ Greedy Then Oldest$/;"	e	enum:scheduler_prioritization_type
SCHEDULER_PRIORITIZATION_GTY	shader.h	/^    SCHEDULER_PRIORITIZATION_GTY, \/\/ Greedy Then Youngest$/;"	e	enum:scheduler_prioritization_type
SCHEDULER_PRIORITIZATION_LRR	shader.h	/^    SCHEDULER_PRIORITIZATION_LRR = 0, \/\/ Loose Round Robin$/;"	e	enum:scheduler_prioritization_type
SCHEDULER_PRIORITIZATION_OLDEST	shader.h	/^    SCHEDULER_PRIORITIZATION_OLDEST, \/\/ Oldest First$/;"	e	enum:scheduler_prioritization_type
SCHEDULER_PRIORITIZATION_SRR	shader.h	/^    SCHEDULER_PRIORITIZATION_SRR, \/\/ Strict Round Robin$/;"	e	enum:scheduler_prioritization_type
SCHEDULER_PRIORITIZATION_YOUNGEST	shader.h	/^    SCHEDULER_PRIORITIZATION_YOUNGEST, \/\/ Youngest First$/;"	e	enum:scheduler_prioritization_type
SCHED_DPRINTF	shader_trace.h	55;"	d
SCHED_DPRINTF	shader_trace.h	70;"	d
SCHED_PRINT_STR	shader_trace.h	38;"	d
SCOREBOARD_H_	scoreboard.h	35;"	d
SEND_ACK_CLEANUP	shader.h	/^      SEND_ACK_CLEANUP$/;"	e	enum:tx_log_walker::commit_tx_state_t
SEND_RS	shader.h	/^      SEND_RS,$/;"	e	enum:tx_log_walker::commit_tx_state_t
SEND_WS	shader.h	/^      SEND_WS,$/;"	e	enum:tx_log_walker::commit_tx_state_t
SHADER_DPRINTF	shader_trace.h	43;"	d
SHADER_DPRINTF	shader_trace.h	69;"	d
SHADER_DTRACE	shader_trace.h	39;"	d
SHADER_DTRACE	shader_trace.h	68;"	d
SHADER_H	shader.h	30;"	d
SHADER_PRINT_STR	shader_trace.h	37;"	d
SMEM_ACCESS	shader.h	/^         SMEM_ACCESS = 0, $/;"	e	enum:tx_log_walker::iwcd_uarch_info::event_type
SRCS	Makefile	/^SRCS = $(shell ls *.cc)$/;"	m
STATS_INCLUDED	stats.h	29;"	d
STAT_TOOL_H	stat-tool.h	29;"	d
STRSIZE	shader.cc	135;"	d	file:
STRSIZE	shader.cc	2041;"	d	file:
STR_SIZE	shader.cc	2523;"	d	file:
SWAP	dram.cc	203;"	d	file:
S_MEM	stats.h	/^   S_MEM,$/;"	e	enum:mem_stage_access_type
Scoreboard	scoreboard.cc	/^Scoreboard::Scoreboard( unsigned sid, unsigned n_warps, simt_stack **simt, bool serialize_tx_warps )$/;"	f	class:Scoreboard
Scoreboard	scoreboard.h	/^class Scoreboard {$/;"	c
SimpleScoreboard	scoreboard.h	/^    SimpleScoreboard( unsigned sid, unsigned n_warps, simt_stack **simt ) $/;"	f	class:SimpleScoreboard
SimpleScoreboard	scoreboard.h	/^class SimpleScoreboard : public Scoreboard {$/;"	c
Stack	stack.h	/^} Stack;$/;"	t	typeref:struct:__anon5
TEXTURE	stat-tool.cc	/^   NORMAL, TEXTURE, CONSTANT, INSTRUCTION$/;"	e	enum:cache_access_logger_types	file:
TEX_FIFO	gpu-cache.h	/^    TEX_FIFO,$/;"	e	enum:mshr_config_t
TEX_MSHR_MERGE	gpu-sim.h	54;"	d
TLB_HIT	stats.h	/^	TLB_HIT = 0,$/;"	e	enum:tlb_request_status
TLB_PENDING	stats.h	/^	TLB_PENDING$/;"	e	enum:tlb_request_status
TLB_READY	stats.h	/^	TLB_READY,$/;"	e	enum:tlb_request_status
TLB_STALL	stats.h	/^   TLB_STALL,$/;"	e	enum:mem_stage_stall_type
TLW_logging	shader.cc	/^bool TLW_logging = false; $/;"	v
TM_CONFLICT_DETECTOR_INCLUDED	tm_conflict_detector.h	2;"	d
TM_PACKET_SIZE	tm_conflict_detector.h	10;"	d
TRACE	Makefile	/^TRACE?=0$/;"	m
TR_ABORT	mem_fetch.h	/^    TR_ABORT,$/;"	e	enum:mf_type
TR_COMMIT	mem_fetch.h	/^    TR_COMMIT,$/;"	e	enum:mf_type
TR_INVALIDATE	mem_fetch.h	/^    TR_INVALIDATE,$/;"	e	enum:mf_type
TR_INVALIDATE_ACK	mem_fetch.h	/^    TR_INVALIDATE_ACK,$/;"	e	enum:mf_type
TR_LOAD_REPLY	mem_fetch.h	/^    TR_LOAD_REPLY,$/;"	e	enum:mf_type
TR_LOAD_REQ	mem_fetch.h	/^    TR_LOAD_REQ,$/;"	e	enum:mf_type
TR_MARK	mem_fetch.h	/^    TR_MARK,$/;"	e	enum:mf_type
TR_NSTID_PROBE_REPLY	mem_fetch.h	/^    TR_NSTID_PROBE_REPLY,$/;"	e	enum:mf_type
TR_NSTID_PROBE_REQ	mem_fetch.h	/^    TR_NSTID_PROBE_REQ,$/;"	e	enum:mf_type
TR_OVERFLOW_DONE	mem_fetch.h	/^    TR_OVERFLOW_DONE,              \/\/ core finished overflow transaction$/;"	e	enum:mf_type
TR_OVERFLOW_REQUEST_START	mem_fetch.h	/^    TR_OVERFLOW_REQUEST_START,     \/\/ core wants permission to overflow x\$$/;"	e	enum:mf_type
TR_OVERFLOW_REQUEST_START_ACK	mem_fetch.h	/^    TR_OVERFLOW_REQUEST_START_ACK, \/\/ tid vendor allows overflow on one core$/;"	e	enum:mf_type
TR_OVERFLOW_RESUME	mem_fetch.h	/^    TR_OVERFLOW_RESUME             \/\/ tid vendor allows cores to resume$/;"	e	enum:mf_type
TR_OVERFLOW_STOP	mem_fetch.h	/^    TR_OVERFLOW_STOP,              \/\/ tid vendor asks other cores to halt any transactional work$/;"	e	enum:mf_type
TR_OVERFLOW_STOP_ACK	mem_fetch.h	/^    TR_OVERFLOW_STOP_ACK,          \/\/ cores reply they have halted$/;"	e	enum:mf_type
TR_SKIP	mem_fetch.h	/^    TR_SKIP,$/;"	e	enum:mf_type
TR_TID_REPLY	mem_fetch.h	/^    TR_TID_REPLY,$/;"	e	enum:mf_type
TR_TID_REQUEST	mem_fetch.h	/^    TR_TID_REQUEST,$/;"	e	enum:mf_type
TX_CU_ALLOC	mem_fetch.h	/^    TX_CU_ALLOC,$/;"	e	enum:mf_type
TX_DONE_FILL	mem_fetch.h	/^    TX_DONE_FILL,$/;"	e	enum:mf_type
TX_FAIL	mem_fetch.h	/^    TX_FAIL,$/;"	e	enum:mf_type
TX_PACKET_SIZE	commit_unit.cc	1127;"	d	file:
TX_PACKET_SIZE	shader.cc	5241;"	d	file:
TX_PASS	mem_fetch.h	/^    TX_PASS,$/;"	e	enum:mf_type
TX_READ_SET	mem_fetch.h	/^    TX_READ_SET,$/;"	e	enum:mf_type
TX_SKIP	mem_fetch.h	/^    TX_SKIP,$/;"	e	enum:mf_type
TX_WRITE_SET	mem_fetch.h	/^    TX_WRITE_SET,$/;"	e	enum:mf_type
T_MEM	stats.h	/^   T_MEM,$/;"	e	enum:mem_stage_access_type
UNUSED	commit_unit.h	/^   UNUSED = 0,$/;"	e	enum:commit_state
USE_SET_INDEX_HASH	gpu-cache.cc	1601;"	d	file:
VALID	gpu-cache.h	/^    VALID,$/;"	e	enum:cache_block_state
VALIDATE	commit_unit.h	/^   VALIDATE,$/;"	e	enum:cu_mem_op
VALIDATION_WAIT	commit_unit.h	/^   VALIDATION_WAIT,$/;"	e	enum:commit_state
VISUALIZER_H_INCLUDED	visualizer.h	29;"	d
WAIT_ATOMIC	shader.h	/^   WAIT_ATOMIC,$/;"	e	enum:thread_state
WAIT_BARRIER	shader.h	/^   WAIT_BARRIER,$/;"	e	enum:thread_state
WAIT_CLEANING	shader.h	/^   WAIT_CLEANING,$/;"	e	enum:thread_state
WAIT_COMMIT	shader.h	/^   WAIT_COMMIT,$/;"	e	enum:thread_state
WAIT_CONCCONTROL	shader.h	/^   WAIT_CONCCONTROL,$/;"	e	enum:thread_state
WAIT_CONTFLOWDIV_CLEANING	shader.h	/^   WAIT_CONTFLOWDIV_CLEANING,$/;"	e	enum:thread_state
WAIT_CONTFLOWDIV_COMMIT	shader.h	/^   WAIT_CONTFLOWDIV_COMMIT,$/;"	e	enum:thread_state
WAIT_CONTFLOWDIV_COMMITEXIT	shader.h	/^   WAIT_CONTFLOWDIV_COMMITEXIT,$/;"	e	enum:thread_state
WAIT_CONTFLOWDIV_CONCCONTROL	shader.h	/^   WAIT_CONTFLOWDIV_CONCCONTROL,$/;"	e	enum:thread_state
WAIT_CONTFLOWDIV_NORMAL	shader.h	/^   WAIT_CONTFLOWDIV_NORMAL,$/;"	e	enum:thread_state
WAIT_CU_ALLOC_REPLY	shader.h	/^      WAIT_CU_ALLOC_REPLY,$/;"	e	enum:tx_log_walker::commit_tx_state_t
WAIT_CU_REPLY	shader.h	/^      WAIT_CU_REPLY,$/;"	e	enum:tx_log_walker::commit_tx_state_t
WAIT_DATAHAZARD_ALU	shader.h	/^   WAIT_DATAHAZARD_ALU,$/;"	e	enum:thread_state
WAIT_DATAHAZARD_MEM	shader.h	/^   WAIT_DATAHAZARD_MEM,$/;"	e	enum:thread_state
WAIT_DATAHAZARD_OTHER	shader.h	/^   WAIT_DATAHAZARD_OTHER,$/;"	e	enum:thread_state
WAIT_IBUFFER	shader.h	/^   WAIT_IBUFFER,$/;"	e	enum:thread_state
WAIT_INITKERNEL	shader.h	/^   WAIT_INITKERNEL,$/;"	e	enum:thread_state
WAIT_SCHEDULER	shader.h	/^   WAIT_SCHEDULER,$/;"	e	enum:thread_state
WARP_PER_CTA_MAX	shader.h	/^const unsigned WARP_PER_CTA_MAX = 48;$/;"	v
WB_CACHE_RSRV_FAIL	stats.h	/^   WB_CACHE_RSRV_FAIL,$/;"	e	enum:mem_stage_stall_type
WB_ICNT_RC_FAIL	stats.h	/^   WB_ICNT_RC_FAIL,$/;"	e	enum:mem_stage_stall_type
WL	gpu-sim.h	/^   unsigned WL;     \/\/WRITE latency$/;"	m	struct:memory_config
WRITE	dram.h	39;"	d
WRITE_ACK	mem_fetch.h	/^    WRITE_ACK,$/;"	e	enum:mf_type
WRITE_ALLOC	shader.h	/^      WRITE_ALLOC,$/;"	e	enum:opndcoll_rfu_t::alloc_t
WRITE_ALLOCATE	gpu-cache.h	/^	WRITE_ALLOCATE,$/;"	e	enum:write_allocate_policy_t
WRITE_BACK	gpu-cache.h	/^    WRITE_BACK,$/;"	e	enum:write_policy_t
WRITE_BACK_REQUEST_SENT	gpu-cache.h	/^    WRITE_BACK_REQUEST_SENT,$/;"	e	enum:cache_event
WRITE_EVICT	gpu-cache.h	/^    WRITE_EVICT,$/;"	e	enum:write_policy_t
WRITE_LOG_ACC	shader.h	/^      WRITE_LOG_ACC,$/;"	e	enum:tx_log_walker::log_acc_type_t
WRITE_LOG_LOAD	shader.h	/^         WRITE_LOG_LOAD$/;"	e	enum:tx_log_walker::iwcd_uarch_info::event_type
WRITE_MASK_SIZE	shader.h	71;"	d
WRITE_PACKET_SIZE	shader.h	69;"	d
WRITE_REQUEST	mem_fetch.h	/^    WRITE_REQUEST,$/;"	e	enum:mf_type
WRITE_REQUEST_SENT	gpu-cache.h	/^    WRITE_REQUEST_SENT$/;"	e	enum:cache_event
WRITE_THROUGH	gpu-cache.h	/^    WRITE_THROUGH,$/;"	e	enum:write_policy_t
WTPc	dram.h	/^   unsigned int WTPc; \/\/ write to precharge$/;"	m	struct:bank_t
WTRc	dram.h	/^   unsigned int WTRc;   \/\/write to read penalty applies across banks$/;"	m	class:dram_t
_MY_STACK_	stack.h	29;"	d
__SHADER_TRACE_H__	shader_trace.h	30;"	d
_inmatch	shader.h	/^      int *_inmatch;$/;"	m	class:opndcoll_rfu_t::arbiter_t
_outmatch	shader.h	/^      int *_outmatch;$/;"	m	class:opndcoll_rfu_t::arbiter_t
_request	shader.h	/^      int **_request;$/;"	m	class:opndcoll_rfu_t::arbiter_t
_stat_idx	power_stat.h	/^typedef enum _stat_idx{$/;"	g
accept_fetch_response	shader.cc	/^void shader_core_ctx::accept_fetch_response( mem_fetch *mf )$/;"	f	class:shader_core_ctx
accept_ldst_unit_response	shader.cc	/^void shader_core_ctx::accept_ldst_unit_response(mem_fetch * mf) $/;"	f	class:shader_core_ctx
access	coherence_manager.cc	/^coherence_cache_request_status coherence_tag_array::access( new_addr_type addr, unsigned time, bool write, new_addr_type &evicted_block_addr) {$/;"	f	class:coherence_tag_array
access	coherence_manager.h	/^    void access(unsigned time)$/;"	f	struct:coherence_cache_block_t
access	commit_unit.cc	/^bool commit_unit::access( mem_fetch *mf, unsigned time )$/;"	f	class:commit_unit
access	gpu-cache.cc	/^data_cache::access( new_addr_type addr,$/;"	f	class:data_cache
access	gpu-cache.cc	/^enum cache_request_status tag_array::access( new_addr_type addr, unsigned time, unsigned &idx )$/;"	f	class:tag_array
access	gpu-cache.cc	/^enum cache_request_status tag_array::access( new_addr_type addr, unsigned time, unsigned &idx, bool &wb, cache_block_t &evicted ) $/;"	f	class:tag_array
access	gpu-cache.cc	/^enum cache_request_status tex_cache::access( new_addr_type addr, mem_fetch *mf,$/;"	f	class:tex_cache
access	gpu-cache.cc	/^l1_cache::access( new_addr_type addr,$/;"	f	class:l1_cache
access	gpu-cache.cc	/^l2_cache::access( new_addr_type addr,$/;"	f	class:l2_cache
access	gpu-cache.cc	/^read_only_cache::access( new_addr_type addr,$/;"	f	class:read_only_cache
access	tm_conflict_detector.h	/^    bool access( mem_fetch *mf, unsigned time )$/;"	f	class:tm_conflict_detector
access_log	shader.cc	/^void tx_log_walker_warpc::access_log(iwcd_uarch_info::uarch_event & uevent, int warp_id, warp_commit_tx_t &cmt_warp) $/;"	f	class:tx_log_walker_warpc
access_ready	gpu-cache.h	/^    bool access_ready() const {return !m_current_response.empty();}$/;"	f	class:mshr_table
access_ready	gpu-cache.h	/^    bool access_ready() const {return m_mshrs.access_ready();}$/;"	f	class:baseline_cache
access_ready	gpu-cache.h	/^    bool access_ready() const{return !m_result_fifo.empty();}$/;"	f	class:tex_cache
accesses	gpu-cache.h	/^    unsigned accesses;$/;"	m	struct:cache_sub_stats
accumulate_L2cache_stats	l2cache.cc	/^void memory_sub_partition::accumulate_L2cache_stats(class cache_stats &l2_stats) const {$/;"	f	class:memory_sub_partition
acquire_cid	shader.cc	/^void tx_log_walker::acquire_cid( unsigned wid, unsigned thread_id, commit_tx_t &tp )$/;"	f	class:tx_log_walker
acquire_token	scoreboard.cc	/^void global_scoreboard::acquire_token(unsigned sid, unsigned wid)$/;"	f	class:global_scoreboard
active	commit_unit.h	/^      bool active;$/;"	m	struct:conflict_table_perfect::conflict_table_entry
active	gpu-sim.cc	/^bool gpgpu_sim::active()$/;"	f	class:gpgpu_sim
active	shader.h	/^      bool active() const { return m_active; }$/;"	f	struct:tx_log_walker::warp_commit_tx_t
active_lanes_in_pipeline	shader.cc	/^void ldst_unit::active_lanes_in_pipeline(){$/;"	f	class:ldst_unit
active_lanes_in_pipeline	shader.cc	/^void sfu::active_lanes_in_pipeline(){$/;"	f	class:sfu
active_lanes_in_pipeline	shader.cc	/^void sp_unit::active_lanes_in_pipeline(){$/;"	f	class:sp_unit
active_mask_t	commit_unit.h	/^   typedef std::bitset<32> active_mask_t; $/;"	t	class:warp_commit_entry
active_sms	gpu-sim.h	/^   float * active_sms;$/;"	m	class:gpgpu_sim
add	gpu-cache.cc	/^void mshr_table::add( new_addr_type block_addr, mem_fetch *mf ){$/;"	f	class:mshr_table
add2bin	histogram.cc	/^void binned_histogram::add2bin (int sample) {$/;"	f	class:binned_histogram
add2bin	histogram.cc	/^void linear_histogram::add2bin (int sample) {$/;"	f	class:linear_histogram
add2bin	histogram.cc	/^void pow2_histogram::add2bin (int sample) {$/;"	f	class:pow2_histogram
add_cu_set	shader.cc	/^void opndcoll_rfu_t::add_cu_set(unsigned set_id, unsigned num_cu, unsigned num_dispatch){$/;"	f	class:opndcoll_rfu_t
add_partial_fill	gpu-cache.h	/^    void add_partial_fill() { m_pending_fills += 1; }$/;"	f	struct:cache_block_t
add_port	shader.cc	/^void opndcoll_rfu_t::add_port(port_vector_t & input, port_vector_t & output, uint_vector_t cu_sets)$/;"	f	class:opndcoll_rfu_t
add_read_requests	shader.h	/^      void add_read_requests( collector_unit_t *cu ) $/;"	f	class:opndcoll_rfu_t::arbiter_t
add_req	dram_sched.cc	/^void frfcfs_scheduler::add_req( dram_req_t *req )$/;"	f	class:frfcfs_scheduler
add_sharer	coherence_manager.cc	/^unsigned coherence_manager::add_sharer(unsigned hwtid, new_addr_type block_addr, unsigned time, bool write, std::set<unsigned> &invalidation_vector) {$/;"	f	class:coherence_manager
add_snap_shot_trigger	stat-tool.cc	/^void add_snap_shot_trigger (snap_shot_trigger* ss_trigger)$/;"	f
add_spill_log	stat-tool.cc	/^void add_spill_log (spill_log_interface* spill_log)$/;"	f
add_stats	shader.h	/^   void add_stats(thread_state_stat& stats) {$/;"	f	struct:thread_state_stat
add_supervised_warp_id	shader.h	/^	void add_supervised_warp_id(int i) {$/;"	f	class:two_level_active_scheduler
add_supervised_warp_id	shader.h	/^    virtual void add_supervised_warp_id(int i) {$/;"	f	class:scheduler_unit
addr	commit_unit.h	/^       new_addr_type addr;$/;"	m	class:commit_unit::cu_mem_acc
addr	commit_unit.h	/^      new_addr_type addr;$/;"	m	struct:conflict_table_hash::conflict_table_hash_entry
addr	dram.h	/^   unsigned long long int addr;$/;"	m	class:dram_req_t
addr_hashset_t	commit_unit.h	/^    typedef tr1_hash_map<new_addr_type, int> addr_hashset_t; $/;"	t	class:cu_access_set
addrdec_getmasklimit	addrdec.cc	/^static void addrdec_getmasklimit(new_addr_type mask, unsigned char *high, unsigned char *low) $/;"	f	file:
addrdec_mask	addrdec.h	/^   new_addr_type addrdec_mask[N_ADDRDEC];$/;"	m	class:linear_to_raw_address_translation
addrdec_mkhigh	addrdec.h	/^   unsigned char addrdec_mkhigh[N_ADDRDEC];$/;"	m	class:linear_to_raw_address_translation
addrdec_mklow	addrdec.h	/^   unsigned char addrdec_mklow[N_ADDRDEC];$/;"	m	class:linear_to_raw_address_translation
addrdec_option	addrdec.h	/^   const char *addrdec_option;$/;"	m	class:linear_to_raw_address_translation
addrdec_packbits	addrdec.cc	/^static new_addr_type addrdec_packbits( new_addr_type mask, new_addr_type val, unsigned char high, unsigned char low) $/;"	f	file:
addrdec_parseoption	addrdec.cc	/^void linear_to_raw_address_translation::addrdec_parseoption(const char *option)$/;"	f	class:linear_to_raw_address_translation
addrdec_setoption	addrdec.cc	/^void linear_to_raw_address_translation::addrdec_setoption(option_parser_t opp)$/;"	f	class:linear_to_raw_address_translation
addrdec_t	addrdec.h	/^struct addrdec_t {$/;"	s
addrdec_tlx	addrdec.cc	/^void linear_to_raw_address_translation::addrdec_tlx(new_addr_type addr, addrdec_t *tlx) const$/;"	f	class:linear_to_raw_address_translation
addsample	stat-tool.h	/^   void addsample(int pos) {$/;"	f	class:linear_histogram_snapshot
age	dram.h	/^   unsigned int age;$/;"	m	class:dram_req_t
all_commit	shader.cc	/^bool tx_log_walker::warp_commit_tx_t::all_commit()$/;"	f	class:tx_log_walker::warp_commit_tx_t
all_commit_done	commit_unit.cc	/^bool warp_commit_entry::all_commit_done() const $/;"	f	class:warp_commit_entry
all_replied	shader.cc	/^bool tx_log_walker::warp_commit_tx_t::all_replied()$/;"	f	class:tx_log_walker::warp_commit_tx_t
all_sent	shader.cc	/^bool tx_log_walker::warp_commit_tx_t::all_sent()$/;"	f	class:tx_log_walker::warp_commit_tx_t
all_validation_done	commit_unit.cc	/^bool warp_commit_entry::all_validation_done() const$/;"	f	class:warp_commit_entry
alloc	commit_unit.cc	/^   virtual mem_fetch * alloc(const class warp_inst_t &inst, const mem_access_t &access) const $/;"	f	class:commit_unit_mf_allocator
alloc	commit_unit.cc	/^   virtual mem_fetch * alloc(new_addr_type addr, mem_access_type type, unsigned size, bool wr) const$/;"	f	class:commit_unit_mf_allocator
alloc	commit_unit.cc	/^   virtual mem_fetch * alloc(new_addr_type addr, mem_access_type type, unsigned size, bool wr, $/;"	f	class:commit_unit_mf_allocator
alloc	l2cache.cc	/^mem_fetch * partition_mf_allocator::alloc(new_addr_type addr, mem_access_type type, unsigned size, bool wr ) const $/;"	f	class:partition_mf_allocator
alloc	l2cache.h	/^    virtual mem_fetch * alloc(const class warp_inst_t &inst, const mem_access_t &access) const $/;"	f	class:partition_mf_allocator
alloc	shader.h	/^    mem_fetch *alloc( const warp_inst_t &inst, const mem_access_t &access ) const$/;"	f	class:shader_core_mem_fetch_allocator
alloc	shader.h	/^    mem_fetch *alloc( new_addr_type addr, mem_access_type type, unsigned size, bool wr ) const $/;"	f	class:shader_core_mem_fetch_allocator
alloc_commit_id	shader.cc	/^unsigned int tx_log_walker::warp_commit_tx_t::alloc_commit_id() { return s_next_commit_id++; }$/;"	f	class:tx_log_walker::warp_commit_tx_t
alloc_intra_warp_cd_resource	shader.cc	/^void tx_log_walker_warpc::alloc_intra_warp_cd_resource() $/;"	f	class:tx_log_walker_warpc
alloc_read	shader.h	/^      void alloc_read( const op_t &op )  { assert(is_free()); m_allocation=READ_ALLOC; m_op=op; }$/;"	f	class:opndcoll_rfu_t::allocation_t
alloc_t	shader.h	/^   enum alloc_t {$/;"	g	class:opndcoll_rfu_t
alloc_write	shader.h	/^      void alloc_write( const op_t &op ) { assert(is_free()); m_allocation=WRITE_ALLOC; m_op=op; }$/;"	f	class:opndcoll_rfu_t::allocation_t
allocate	coherence_manager.h	/^    void allocate( new_addr_type tag, new_addr_type block_addr, coherence_cache_block_state status, unsigned time )$/;"	f	struct:coherence_cache_block_t
allocate	gpu-cache.h	/^    void allocate( new_addr_type tag, new_addr_type block_addr, unsigned time )$/;"	f	struct:cache_block_t
allocate	shader.cc	/^bool opndcoll_rfu_t::collector_unit_t::allocate( register_set* pipeline_reg_set, register_set* output_reg_set ) $/;"	f	class:opndcoll_rfu_t::collector_unit_t
allocate_bank_for_write	shader.h	/^      void allocate_bank_for_write( unsigned bank, const op_t &op )$/;"	f	class:opndcoll_rfu_t::arbiter_t
allocate_barrier	shader.cc	/^void barrier_set_t::allocate_barrier( unsigned cta_id, warp_set_t warps )$/;"	f	class:barrier_set_t
allocate_cu	shader.cc	/^void opndcoll_rfu_t::allocate_cu( unsigned port_num )$/;"	f	class:opndcoll_rfu_t
allocate_for_read	shader.h	/^      void allocate_for_read( unsigned bank, const op_t &op )$/;"	f	class:opndcoll_rfu_t::arbiter_t
allocate_reads	shader.cc	/^std::list<opndcoll_rfu_t::op_t> opndcoll_rfu_t::arbiter_t::allocate_reads() $/;"	f	class:opndcoll_rfu_t::arbiter_t
allocate_reads	shader.cc	/^void opndcoll_rfu_t::allocate_reads()$/;"	f	class:opndcoll_rfu_t
allocate_space	coherence_manager.cc	/^void coherence_tag_array::allocate_space() {$/;"	f	class:coherence_tag_array
allocate_to_cid	commit_unit.cc	/^void commit_unit::allocate_to_cid(int commit_id, enum mf_type type)$/;"	f	class:commit_unit
allocation_policy_t	gpu-cache.h	/^enum allocation_policy_t {$/;"	g
allocation_t	shader.h	/^      allocation_t() { m_allocation = NO_ALLOC; }$/;"	f	class:opndcoll_rfu_t::allocation_t
allocation_t	shader.h	/^   class allocation_t {$/;"	c	class:opndcoll_rfu_t
append	commit_unit.cc	/^void cu_access_set::append(new_addr_type addr)$/;"	f	class:cu_access_set
append_coalesced_op	commit_unit.cc	/^void commit_unit::cu_mem_acc::append_coalesced_op(new_addr_type block_addr, cu_mem_acc &mem_op) $/;"	f	class:commit_unit::cu_mem_acc
append_coalesced_packet	mem_fetch.cc	/^void mem_fetch::append_coalesced_packet(mem_fetch *mf)$/;"	f	class:mem_fetch
arbiter_t	shader.h	/^      arbiter_t()$/;"	f	class:opndcoll_rfu_t::arbiter_t
arbiter_t	shader.h	/^   class arbiter_t {$/;"	c	class:opndcoll_rfu_t
arbitration_metadata	l2cache.cc	/^memory_partition_unit::arbitration_metadata::arbitration_metadata(const struct memory_config *config) $/;"	f	class:memory_partition_unit::arbitration_metadata
arbitration_metadata	l2cache.h	/^   class arbitration_metadata$/;"	c	class:memory_partition_unit
assign_tm_manager	shader.cc	/^void tx_log_walker::assign_tm_manager(int warp_id, int lane_id)$/;"	f	class:tx_log_walker
at_retire_ptr	commit_unit.cc	/^void commit_entry::at_retire_ptr(class commit_unit_stats &stats, unsigned time)$/;"	f	class:commit_entry
at_retire_ptr_logical	commit_unit.cc	/^void commit_entry::at_retire_ptr_logical(class commit_unit_stats &stats, unsigned time)$/;"	f	class:commit_entry
atag_cachemiss	shader.h	/^      bool atag_cachemiss;$/;"	m	struct:tx_log_walker::log_send_status_t
atag_read	shader.h	/^      bool atag_read;$/;"	m	struct:tx_log_walker::log_send_status_t
available_for_fetch	shader.cc	/^bool barrier_set_t::available_for_fetch( unsigned warp_id ) const$/;"	f	class:barrier_set_t
ave_mrqs	dram.h	/^   unsigned int ave_mrqs;$/;"	m	class:dram_t
ave_mrqs_partial	dram.h	/^   unsigned int ave_mrqs_partial;$/;"	m	class:dram_t
average_duty_cycle	power_stat.h	/^   float average_duty_cycle;$/;"	m	class:power_core_stat_t
average_pipeline_duty_cycle	gpu-sim.h	/^   float * average_pipeline_duty_cycle;$/;"	m	class:gpgpu_sim
avg_set_util	gpu-cache.h	/^    unsigned avg_set_util; $/;"	m	struct:cache_sub_stats
backup_register_value	shader.cc	/^void history_file_t::backup_register_value(unsigned wid, unsigned reg, unsigned bank) $/;"	f	class:history_file_t
bandwidth_management	gpu-cache.cc	/^baseline_cache::bandwidth_management::bandwidth_management(cache_config &config) $/;"	f	class:baseline_cache::bandwidth_management
bandwidth_management	gpu-cache.h	/^    class bandwidth_management $/;"	c	class:baseline_cache
bank_idle	shader.h	/^      bool bank_idle( unsigned bank ) const$/;"	f	class:opndcoll_rfu_t::arbiter_t
bank_t	dram.h	/^struct bank_t$/;"	s
bankgrp_t	dram.h	/^struct bankgrp_t$/;"	s
bankreads	mem_latency_stat.h	/^   unsigned int ***bankreads; \/\/bankreads[shader id][dram chip id][bank id]$/;"	m	class:memory_stats_t
bankwrites	mem_latency_stat.h	/^   unsigned int ***bankwrites; \/\/bankwrites[shader id][dram chip id][bank id]$/;"	m	class:memory_stats_t
barrier_set_t	shader.cc	/^barrier_set_t::barrier_set_t( unsigned max_warps_per_core, unsigned max_cta_per_core )$/;"	f	class:barrier_set_t
barrier_set_t	shader.h	/^class barrier_set_t {$/;"	c
baseline_cache	gpu-cache.h	/^    baseline_cache( const char *name, cache_config &config, int core_id, int type_id, mem_fetch_interface *memport,$/;"	f	class:baseline_cache
baseline_cache	gpu-cache.h	/^    baseline_cache( const char *name,$/;"	f	class:baseline_cache
baseline_cache	gpu-cache.h	/^class baseline_cache : public cache_t {$/;"	c
begin_callback	shader.cc	/^void shader_core_ctx::begin_callback( unsigned thread_id, unsigned warp_id, address_type restart_pc )$/;"	f	class:shader_core_ctx
binned_histogram	histogram.cc	/^binned_histogram::binned_histogram (const binned_histogram& other)$/;"	f	class:binned_histogram
binned_histogram	histogram.cc	/^binned_histogram::binned_histogram (std::string name, int nbins, int* bins) $/;"	f	class:binned_histogram
binned_histogram	histogram.h	/^class binned_histogram {$/;"	c
bk	addrdec.h	/^   unsigned bk;$/;"	m	struct:addrdec_t
bk	dram.h	/^   bank_t **bk;$/;"	m	class:dram_t
bk	dram.h	/^   unsigned int bk;$/;"	m	class:dram_req_t
bk_tag_length	gpu-sim.h	/^   unsigned bk_tag_length; \/\/number of bits that define a bank inside a bank group$/;"	m	struct:memory_config
bkgrp	dram.h	/^   bankgrp_t **bkgrp;$/;"	m	class:dram_t
bkgrpindex	dram.h	/^   unsigned int bkgrpindex;$/;"	m	struct:bank_t
blk_info	tm_conflict_detector.h	/^        blk_info() { m_valid = false; m_marked=false;}$/;"	f	struct:tm_conflict_detector::blk_info
blk_info	tm_conflict_detector.h	/^    struct blk_info {$/;"	s	class:tm_conflict_detector
block_addr	gpu-cache.h	/^    new_addr_type block_addr( new_addr_type addr ) const$/;"	f	class:cache_config
borrow_credit	l2cache.cc	/^void memory_partition_unit::arbitration_metadata::borrow_credit(int inner_sub_partition_id) $/;"	f	class:memory_partition_unit::arbitration_metadata
burst	addrdec.h	/^   unsigned burst;$/;"	m	struct:addrdec_t
busW	gpu-sim.h	/^   unsigned busW;$/;"	m	struct:memory_config
busy	gpu-cache.h	/^    bool busy() const {return false;}$/;"	f	class:mshr_table
busy	l2cache.cc	/^bool memory_partition_unit::busy() const $/;"	f	class:memory_partition_unit
busy	l2cache.cc	/^bool memory_sub_partition::busy() const $/;"	f	class:memory_sub_partition
bwutil	dram.h	/^   unsigned int bwutil;$/;"	m	class:dram_t
bwutil_partial	dram.h	/^   unsigned int bwutil_partial;$/;"	m	class:dram_t
c_null_wid	shader.h	/^   static const unsigned c_null_wid = -1; $/;"	m	class:history_file_t
cache_access_logger_types	stat-tool.cc	/^enum cache_access_logger_types {$/;"	g	file:
cache_block_state	gpu-cache.h	/^enum cache_block_state {$/;"	g
cache_block_t	gpu-cache.h	/^    cache_block_t()$/;"	f	struct:cache_block_t
cache_block_t	gpu-cache.h	/^struct cache_block_t {$/;"	s
cache_config	gpu-cache.h	/^    cache_config() $/;"	f	class:cache_config
cache_config	gpu-cache.h	/^class cache_config {$/;"	c
cache_cycle	l2cache.cc	/^void memory_partition_unit::cache_cycle(unsigned cycle) $/;"	f	class:memory_partition_unit
cache_cycle	l2cache.cc	/^void memory_sub_partition::cache_cycle( unsigned cycle )$/;"	f	class:memory_sub_partition
cache_event	gpu-cache.h	/^enum cache_event {$/;"	g
cache_flush	shader.cc	/^void shader_core_ctx::cache_flush()$/;"	f	class:shader_core_ctx
cache_flush	shader.cc	/^void simt_core_cluster::cache_flush()$/;"	f	class:simt_core_cluster
cache_request_status	gpu-cache.h	/^enum cache_request_status {$/;"	g
cache_request_status_str	gpu-cache.cc	/^const char * cache_request_status_str(enum cache_request_status status) $/;"	f
cache_stats	gpu-cache.cc	/^cache_stats::cache_stats(const cache_config * config){$/;"	f	class:cache_stats
cache_stats	gpu-cache.h	/^class cache_stats {$/;"	c
cache_status	gpu-cache.h	/^    FuncCache cache_status;$/;"	m	class:cache_config
cache_sub_stats	gpu-cache.h	/^    cache_sub_stats(){$/;"	f	struct:cache_sub_stats
cache_sub_stats	gpu-cache.h	/^struct cache_sub_stats{$/;"	s
cache_t	gpu-cache.h	/^class cache_t {$/;"	c
calculate_dist	visualizer.cc	/^   void calculate_dist() {$/;"	f	class:my_time_vector
calculate_ld_dist	visualizer.cc	/^   void calculate_ld_dist(void) {$/;"	f	class:my_time_vector	file:
calculate_st_dist	visualizer.cc	/^   void calculate_st_dist(void) {$/;"	f	class:my_time_vector	file:
can_issue	shader.h	/^    virtual bool can_issue( const warp_inst_t &inst ) const { return m_dispatch_reg->empty() && !occupied.test(inst.latency); }$/;"	f	class:simd_function_unit
can_issue	shader.h	/^    virtual bool can_issue( const warp_inst_t &inst ) const$/;"	f	class:ldst_unit
can_issue	shader.h	/^    virtual bool can_issue( const warp_inst_t &inst ) const$/;"	f	class:pipelined_simd_unit
can_issue	shader.h	/^    virtual bool can_issue( const warp_inst_t &inst ) const$/;"	f	class:sfu
can_issue	shader.h	/^    virtual bool can_issue( const warp_inst_t &inst ) const$/;"	f	class:sp_unit
can_issue_to_dram	l2cache.cc	/^bool memory_partition_unit::can_issue_to_dram(int inner_sub_partition_id) $/;"	f	class:memory_partition_unit
can_start_kernel	gpu-sim.cc	/^bool gpgpu_sim::can_start_kernel()$/;"	f	class:gpgpu_sim
capacity	gpu-cache.h	/^        unsigned capacity() const { return m_size; }$/;"	f	class:tex_cache::fifo
cflog_print	stat-tool.cc	/^void cflog_print(FILE *fout) $/;"	f
cflog_snapshot	stat-tool.cc	/^void cflog_snapshot( int logger_id, unsigned long long  cycle ) $/;"	f
cflog_update_thread_pc	stat-tool.cc	/^void cflog_update_thread_pc( int logger_id, int thread_id, address_type pc ) $/;"	f
cflog_visualizer_gzprint	stat-tool.cc	/^void cflog_visualizer_gzprint(gzFile fout) $/;"	f
cflog_visualizer_print	stat-tool.cc	/^void cflog_visualizer_print(FILE *fout) $/;"	f
change_cache_config	gpu-sim.cc	/^void gpgpu_sim::change_cache_config(FuncCache cache_config)$/;"	f	class:gpgpu_sim
check	shader.cc	/^   bool check(addr_t address_tag, int thread_id) $/;"	f	class:ownership_table
checkCollision	scoreboard.cc	/^bool Scoreboard::checkCollision( unsigned wid, const class inst_t *inst ) const$/;"	f	class:Scoreboard
checkCollision	scoreboard.cc	/^bool SimpleScoreboard::checkCollision( unsigned wid, const class inst_t *inst ) const$/;"	f	class:SimpleScoreboard
checkExecutionStatusAndUpdate	shader.cc	/^void shader_core_ctx::checkExecutionStatusAndUpdate(warp_inst_t &inst, unsigned t, unsigned tid)$/;"	f	class:shader_core_ctx
checkTMToken	scoreboard.cc	/^bool Scoreboard::checkTMToken(unsigned wid, const inst_t *inst) const $/;"	f	class:Scoreboard
check_and_advance_commit_ptr	commit_unit.cc	/^void commit_unit::check_and_advance_commit_ptr(unsigned long long time)$/;"	f	class:commit_unit
check_and_advance_commit_ptr	commit_unit.cc	/^void commit_unit_logical::check_and_advance_commit_ptr(unsigned long long time)$/;"	f	class:commit_unit_logical
check_and_advance_commit_ptr_vwait_nostall	commit_unit.cc	/^void commit_unit::check_and_advance_commit_ptr_vwait_nostall(unsigned long long time)$/;"	f	class:commit_unit
check_and_advance_fcd_ptr	commit_unit.cc	/^void commit_unit::check_and_advance_fcd_ptr(unsigned long long time)$/;"	f	class:commit_unit
check_and_advance_fcd_ptr_warp_level	commit_unit.cc	/^void commit_unit::check_and_advance_fcd_ptr_warp_level(unsigned long long time)$/;"	f	class:commit_unit
check_and_advance_pass_ptr	commit_unit.cc	/^void commit_unit::check_and_advance_pass_ptr(unsigned long long time) $/;"	f	class:commit_unit
check_and_advance_pass_ptr_vwait_nostall	commit_unit.cc	/^void commit_unit::check_and_advance_pass_ptr_vwait_nostall(unsigned long long time)$/;"	f	class:commit_unit
check_and_advance_retire_ptr	commit_unit.cc	/^void commit_unit::check_and_advance_retire_ptr(unsigned long long time)$/;"	f	class:commit_unit
check_and_advance_retire_ptr	commit_unit.cc	/^void commit_unit_logical::check_and_advance_retire_ptr(unsigned long long time)$/;"	f	class:commit_unit_logical
check_and_advance_retire_ptr_vwait_nostall	commit_unit.cc	/^void commit_unit::check_and_advance_retire_ptr_vwait_nostall(unsigned long long time)$/;"	f	class:commit_unit
check_conflict_for_read	commit_unit.cc	/^bool commit_unit::check_conflict_for_read(int commit_id, new_addr_type read_addr)$/;"	f	class:commit_unit
check_conflict_for_write	commit_unit.cc	/^void commit_unit::check_conflict_for_write(int commit_id, new_addr_type write_addr)$/;"	f	class:commit_unit
check_cu_access	commit_unit.cc	/^enum cu_mem_op commit_unit::check_cu_access( mem_fetch *mf ) $/;"	f	class:commit_unit
check_entry	commit_unit.cc	/^bool conflict_table_perfect::check_entry(new_addr_type addr, int cid) const$/;"	f	class:conflict_table_perfect
check_ld_update	visualizer.cc	/^   void check_ld_update(unsigned int uid,unsigned int slot, long int latency) { $/;"	f	class:my_time_vector
check_mshr_parameters	gpu-cache.h	/^    void check_mshr_parameters( unsigned num_entries, unsigned max_merged )$/;"	f	class:mshr_table
check_n_derive	commit_unit.cc	/^void commit_unit_options::check_n_derive()$/;"	f	class:commit_unit_options
check_read_conflict	commit_unit.cc	/^bool conflict_detector::check_read_conflict(new_addr_type addr, int cid, int retire_cid_at_fill, int& conflicting_cid) $/;"	f	class:conflict_detector
check_read_conflict	commit_unit.cc	/^bool conflict_table_hash::check_read_conflict(new_addr_type addr, int cid, int retire_cid_at_fill, int& conflicting_cid) const$/;"	f	class:conflict_table_hash
check_read_conflict	commit_unit.cc	/^bool conflict_table_perfect::check_read_conflict(new_addr_type addr, int cid, int retire_cid_at_fill, int& conflicting_cid) {$/;"	f	class:conflict_table_perfect
check_read_set_version	commit_unit.cc	/^void commit_unit::check_read_set_version(const commit_entry &ce)$/;"	f	class:commit_unit
check_st_update	visualizer.cc	/^   void check_st_update(unsigned int uid,unsigned int slot, long int latency) { $/;"	f	class:my_time_vector
check_time_vector_update	visualizer.cc	/^void check_time_vector_update(unsigned int uid,int slot ,long int latency,int type) $/;"	f
check_valid	gpu-cache.cc	/^bool cache_stats::check_valid(int type, int status) const{$/;"	f	class:cache_stats
chip	addrdec.h	/^   unsigned chip;$/;"	m	struct:addrdec_t
cid2tid	shader.cc	/^int tx_log_walker::cid2tid(int commit_id) const$/;"	f	class:tx_log_walker
cid_pointer_stats	commit_unit.cc	/^      cid_pointer_stats (const char *name) $/;"	f	struct:commit_unit_stats::cid_pointer_stats
cid_pointer_stats	commit_unit.cc	/^   struct cid_pointer_stats {$/;"	s	class:commit_unit_stats	file:
cid_to_sid	shader.h	/^    unsigned cid_to_sid( unsigned cid, unsigned cluster_id ) const { return cluster_id*n_simt_cores_per_cluster + cid; }$/;"	f	struct:shader_core_config
classify_memfetch	traffic_breakdown.cc	/^std::string traffic_breakdown::classify_memfetch(class mem_fetch * mf)$/;"	f	class:traffic_breakdown
clear	gpu-cache.cc	/^void cache_stats::clear(){$/;"	f	class:cache_stats
clear	gpu-cache.h	/^    void clear(){$/;"	f	struct:cache_sub_stats
clear	tm_conflict_detector.h	/^        void clear() { m_read_set.reset(); }$/;"	f	struct:tm_conflict_detector::blk_info
clear_commit_pending	commit_unit.h	/^    void clear_commit_pending(unsigned mpid) { $/;"	f	class:commit_entry
clear_executed_kernel_info	gpu-sim.cc	/^void gpgpu_sim::clear_executed_kernel_info()$/;"	f	class:gpgpu_sim
clear_imiss_pending	shader.h	/^    void clear_imiss_pending() { m_imiss_pending=false; }$/;"	f	class:shd_warp_t
clear_is_aborted	mem_fetch.h	/^   void clear_is_aborted() { m_is_aborted = false; }$/;"	f	class:mem_fetch
clear_is_stalled	mem_fetch.h	/^   void clear_is_stalled() { m_is_stalled = false; }$/;"	f	class:mem_fetch
clear_log_cache_usage	shader.cc	/^void tx_log_walker::clear_log_cache_usage(unsigned warp_id, const tm_warp_info &warp_info, bool read_log) $/;"	f	class:tx_log_walker
clear_membar	shader.h	/^    void clear_membar() { m_membar=false; }$/;"	f	class:shd_warp_t
clear_stalled	mem_fetch.h	/^   void clear_stalled(int lane) { m_stalled_mask.reset(lane); }$/;"	f	class:mem_fetch
clear_time_map_vectors	visualizer.cc	/^   void clear_time_map_vectors(void) {   $/;"	f	class:my_time_vector
clear_writes	commit_unit.cc	/^void conflict_detector::clear_writes(commit_entry &ce) {$/;"	f	class:conflict_detector
clear_writes	commit_unit.cc	/^void conflict_table_perfect::clear_writes(commit_entry &ce) {$/;"	f	class:conflict_table_perfect
clock_multiplier	shader.cc	/^unsigned ldst_unit::clock_multiplier() const$/;"	f	class:ldst_unit
clock_multiplier	shader.h	/^    virtual unsigned clock_multiplier() const { return 1; }$/;"	f	class:simd_function_unit
coalesce_ops_to_queue	commit_unit.cc	/^void commit_unit::coalesce_ops_to_queue(enum cu_mem_op operation)$/;"	f	class:commit_unit
coalesced_segment	shader.cc	/^address_type coalesced_segment(address_type addr, unsigned segment_size_lg2bytes)$/;"	f
coh_model	shader.h	/^    unsigned coh_model; \/\/ enable\/disable$/;"	m	struct:shader_core_config
coh_tm_flush_cache	shader.h	/^    unsigned coh_tm_flush_cache; \/\/ enable\/disable$/;"	m	struct:shader_core_config
coh_tm_only	shader.h	/^    unsigned coh_tm_only; \/\/ enable\/disable$/;"	m	struct:shader_core_config
coherence_cache_block_state	coherence_manager.h	/^enum coherence_cache_block_state {$/;"	g
coherence_cache_block_t	coherence_manager.h	/^    coherence_cache_block_t()$/;"	f	struct:coherence_cache_block_t
coherence_cache_block_t	coherence_manager.h	/^struct coherence_cache_block_t {$/;"	s
coherence_cache_request_status	coherence_manager.h	/^    enum coherence_cache_request_status {$/;"	g
coherence_directory_block_t	coherence_manager.h	/^    coherence_directory_block_t()$/;"	f	struct:coherence_directory_block_t
coherence_directory_block_t	coherence_manager.h	/^struct coherence_directory_block_t {$/;"	s
coherence_manager	coherence_manager.cc	/^coherence_manager::coherence_manager( const shader_core_config *shader_config ) :$/;"	f	class:coherence_manager
coherence_manager	coherence_manager.h	/^class coherence_manager$/;"	c
coherence_tag_array	coherence_manager.cc	/^coherence_tag_array::coherence_tag_array( const cache_config &config, unsigned uid)$/;"	f	class:coherence_tag_array
coherence_tag_array	coherence_manager.h	/^class coherence_tag_array {$/;"	c
col	addrdec.h	/^   unsigned col;$/;"	m	struct:addrdec_t
col	dram.h	/^   unsigned int col;$/;"	m	class:dram_req_t
collect_intra_warpcd_uarch_activity_stats	shader.cc	/^void tx_log_walker::collect_intra_warpcd_uarch_activity_stats(iwcd_uarch_info &uarch_activity) $/;"	f	class:tx_log_walker
collect_operand	shader.h	/^      void collect_operand( unsigned op )$/;"	f	class:opndcoll_rfu_t::collector_unit_t
collector_unit_t	shader.h	/^      collector_unit_t()$/;"	f	class:opndcoll_rfu_t::collector_unit_t
collector_unit_t	shader.h	/^   class collector_unit_t {$/;"	c	class:opndcoll_rfu_t
commit_ack_pending	commit_unit.cc	/^bool warp_commit_entry::commit_ack_pending(const commit_entry& cmt_entry) const$/;"	f	class:warp_commit_entry
commit_callback	shader.cc	/^void shader_core_ctx::commit_callback( unsigned thread_id, unsigned warp_id, address_type commit_pc )$/;"	f	class:shader_core_ctx
commit_clear	shader.cc	/^void history_file_t::commit_clear() $/;"	f	class:history_file_t
commit_done_ack	commit_unit.cc	/^void commit_unit::commit_done_ack(commit_entry &ce) $/;"	f	class:commit_unit
commit_entry	commit_unit.cc	/^commit_entry::commit_entry(int commit_id)$/;"	f	class:commit_entry
commit_entry	commit_unit.h	/^class commit_entry $/;"	c
commit_entry_table_t	commit_unit.h	/^    typedef std::deque<commit_entry> commit_entry_table_t;$/;"	t	class:commit_unit
commit_id	commit_unit.h	/^       int commit_id;$/;"	m	class:commit_unit::cu_mem_acc
commit_id	commit_unit.h	/^      int commit_id;$/;"	m	struct:conflict_table_hash::conflict_table_hash_entry
commit_id	commit_unit.h	/^      int commit_id;$/;"	m	struct:conflict_table_perfect::conflict_table_entry
commit_id_thread_lookup	shader.h	/^   typedef std::unordered_map<int,int> commit_id_thread_lookup;$/;"	t	class:tx_log_walker
commit_ready	shader.cc	/^bool tx_log_walker::commit_ready()$/;"	f	class:tx_log_walker
commit_state	commit_unit.h	/^enum commit_state $/;"	g
commit_state_str	commit_unit.cc	/^static const char* commit_state_str[] = {$/;"	v	file:
commit_tx_state_t	shader.h	/^   enum commit_tx_state_t {$/;"	g	class:tx_log_walker
commit_tx_t	shader.h	/^      commit_tx_t() : m_tm_manager(NULL) { reset(); }$/;"	f	struct:tx_log_walker::commit_tx_t
commit_tx_t	shader.h	/^   struct commit_tx_t {$/;"	s	class:tx_log_walker
commit_unit	commit_unit.cc	/^commit_unit::commit_unit( const memory_config *memory_config, $/;"	f	class:commit_unit
commit_unit	commit_unit.h	/^class commit_unit $/;"	c
commit_unit_logical	commit_unit.h	/^    commit_unit_logical( const memory_config *memory_config, $/;"	f	class:commit_unit_logical
commit_unit_logical	commit_unit.h	/^class commit_unit_logical : public commit_unit {$/;"	c
commit_unit_mf_allocator	commit_unit.cc	/^   commit_unit_mf_allocator( const memory_config *config )$/;"	f	class:commit_unit_mf_allocator
commit_unit_mf_allocator	commit_unit.cc	/^class commit_unit_mf_allocator : public mem_fetch_allocator {$/;"	c	file:
commit_unit_options	commit_unit.cc	/^   commit_unit_options() $/;"	f	class:commit_unit_options
commit_unit_options	commit_unit.cc	/^class commit_unit_options : public OptionChecker $/;"	c	file:
commit_unit_reg_options	commit_unit.cc	/^void commit_unit_reg_options(option_parser_t opp)$/;"	f
commit_unit_reply_t	shader.h	/^      typedef std::bitset<16> commit_unit_reply_t; $/;"	t	struct:tx_log_walker::commit_tx_t
commit_unit_statistics	commit_unit.cc	/^void commit_unit_statistics(FILE *fout)$/;"	f
commit_unit_stats	commit_unit.cc	/^   commit_unit_stats()$/;"	f	class:commit_unit_stats
commit_unit_stats	commit_unit.cc	/^class commit_unit_stats$/;"	c	file:
commit_warp_cleanup	shader.cc	/^void shader_core_ctx::commit_warp_cleanup(unsigned warp_id)$/;"	f	class:shader_core_ctx
commit_write_done	commit_unit.h	/^    void commit_write_done() { m_n_commit_write_pending -= 1; assert(m_n_commit_write_pending >= 0); }$/;"	f	class:commit_entry
commit_write_pending	commit_unit.h	/^    bool commit_write_pending() const { return (m_n_commit_write_pending != 0); }$/;"	f	class:commit_entry
concrete_scheduler	shader.h	/^enum concrete_scheduler$/;"	g
concurrent_row_access	mem_latency_stat.h	/^   unsigned int **concurrent_row_access; \/\/concurrent_row_access[dram chip id][bank id]$/;"	m	class:memory_stats_t
conflict_detector	commit_unit.cc	/^conflict_detector::conflict_detector(unsigned n_hash_sets, unsigned n_hash_ways, unsigned bf_size, unsigned bf_n_funcs, unsigned addr_granularity)$/;"	f	class:conflict_detector
conflict_detector	commit_unit.h	/^class conflict_detector {$/;"	c
conflict_table_entry	commit_unit.h	/^      conflict_table_entry(int cid = 0) : commit_id(cid), read_counter(0), active(true) {}$/;"	f	struct:conflict_table_perfect::conflict_table_entry
conflict_table_entry	commit_unit.h	/^   struct conflict_table_entry {$/;"	s	class:conflict_table_perfect
conflict_table_hash	commit_unit.cc	/^conflict_table_hash::conflict_table_hash(unsigned n_sets, unsigned n_ways)$/;"	f	class:conflict_table_hash
conflict_table_hash	commit_unit.h	/^class conflict_table_hash {$/;"	c
conflict_table_hash_entry	commit_unit.h	/^      conflict_table_hash_entry(new_addr_type addr=0, int cid=0) : addr(addr), commit_id(cid), valid(false) {}$/;"	f	struct:conflict_table_hash::conflict_table_hash_entry
conflict_table_hash_entry	commit_unit.h	/^   struct conflict_table_hash_entry {$/;"	s	class:conflict_table_hash
conflict_table_perfect	commit_unit.cc	/^conflict_table_perfect::conflict_table_perfect(unsigned addr_granularity)$/;"	f	class:conflict_table_perfect
conflict_table_perfect	commit_unit.h	/^class conflict_table_perfect {$/;"	c
conflict_table_t	commit_unit.h	/^   typedef std::map<new_addr_type,conflict_table_entry> conflict_table_t;$/;"	t	class:conflict_table_perfect
constant_cycle	shader.cc	/^bool ldst_unit::constant_cycle( warp_inst_t &inst, mem_stage_stall_type &rc_fail, mem_stage_access_type &fail_type)$/;"	f	class:ldst_unit
core_cache_stats	power_stat.h	/^    class cache_stats core_cache_stats[NUM_STAT_IDX]; \/\/ Total core stats$/;"	m	struct:mem_power_stats_pod	typeref:class:mem_power_stats_pod::cache_stats
core_cycle	shader.cc	/^void simt_core_cluster::core_cycle()$/;"	f	class:simt_core_cluster
core_freq	gpu-sim.h	/^    double core_freq;$/;"	m	class:gpgpu_sim_config
core_period	gpu-sim.h	/^    double core_period;$/;"	m	class:gpgpu_sim_config
core_profile_thread_states	shader.cc	/^void simt_core_cluster::core_profile_thread_states()$/;"	f	class:simt_core_cluster
core_time	gpu-sim.h	/^   double core_time;$/;"	m	class:gpgpu_sim
count_active_entries	commit_unit.cc	/^int conflict_table_perfect::count_active_entries() const {$/;"	f	class:conflict_table_perfect
count_sharers	coherence_manager.h	/^    unsigned count_sharers() {$/;"	f	struct:coherence_directory_block_t
create_thread_CFlogger	stat-tool.cc	/^void create_thread_CFlogger( int n_loggers, int n_threads, address_type start_pc, unsigned long long  logging_interval) $/;"	f
create_tx_packet	shader.cc	/^mem_fetch* tx_log_walker::create_tx_packet(enum mf_type type, const warp_inst_t &inst, int commit_id, unsigned dst_cu, address_type addr, unsigned size, bool wr)$/;"	f	class:tx_log_walker
cta_to_warp_t	shader.h	/^   typedef std::map<unsigned, warp_set_t >  cta_to_warp_t;$/;"	t	class:barrier_set_t
cu_access_set	commit_unit.cc	/^cu_access_set::cu_access_set()$/;"	f	class:cu_access_set
cu_access_set	commit_unit.h	/^class cu_access_set$/;"	c
cu_alloc_init_timeout	shader.h	/^    unsigned cu_alloc_init_timeout;$/;"	m	struct:shader_core_config
cu_alloc_max_timeout	shader.h	/^    unsigned cu_alloc_max_timeout;$/;"	m	struct:shader_core_config
cu_commit_ack_traffic	shader.h	/^    bool cu_commit_ack_traffic; \/\/ generate traffic for commit done ack$/;"	m	struct:shader_core_config
cu_finite	shader.h	/^    bool cu_finite;$/;"	m	struct:shader_core_config
cu_mem_acc	commit_unit.h	/^       cu_mem_acc(int cid = -1, new_addr_type adr = 0xDEADBEEF, enum cu_mem_op op = NON_CU_OP, unsigned time = -1) $/;"	f	class:commit_unit::cu_mem_acc
cu_mem_acc	commit_unit.h	/^    class cu_mem_acc {$/;"	c	class:commit_unit
cu_mem_fetch_lookup	commit_unit.h	/^    typedef tr1_hash_map<mem_fetch*, cu_mem_acc> cu_mem_fetch_lookup; $/;"	t	class:commit_unit
cu_mem_op	commit_unit.h	/^enum cu_mem_op $/;"	g
cu_revalidation_lookup	commit_unit.h	/^    typedef std::multimap<int, int> cu_revalidation_lookup; \/\/ <retire CID, revalidate CID> $/;"	t	class:commit_unit
cu_sets_t	shader.h	/^   typedef std::map<unsigned \/* collector set *\/, std::vector<collector_unit_t> \/*collector sets*\/ > cu_sets_t;$/;"	t	class:opndcoll_rfu_t
cu_size	shader.h	/^    unsigned cu_size;$/;"	m	struct:shader_core_config
curr_row	dram.h	/^   unsigned int curr_row;$/;"	m	struct:bank_t
curr_row_service_time	dram_sched.h	/^   unsigned *curr_row_service_time; \/\/one set of variables for each bank.$/;"	m	class:frfcfs_scheduler
cycle	commit_unit.cc	/^void commit_unit::cycle(unsigned long long time)$/;"	f	class:commit_unit
cycle	commit_unit.cc	/^void commit_unit_logical::cycle(unsigned long long time)$/;"	f	class:commit_unit_logical
cycle	dram.cc	/^void dram_t::cycle()$/;"	f	class:dram_t
cycle	gpu-cache.cc	/^void baseline_cache::cycle(){$/;"	f	class:baseline_cache
cycle	gpu-cache.cc	/^void tex_cache::cycle(){$/;"	f	class:tex_cache
cycle	gpu-sim.cc	/^void gpgpu_sim::cycle()$/;"	f	class:gpgpu_sim
cycle	shader.cc	/^void ldst_unit::cycle()$/;"	f	class:ldst_unit
cycle	shader.cc	/^void scheduler_unit::cycle()$/;"	f	class:scheduler_unit
cycle	shader.cc	/^void shader_core_ctx::cycle()$/;"	f	class:shader_core_ctx
cycle	shader.cc	/^void tx_log_walker::cycle()$/;"	f	class:tx_log_walker
cycle	shader.cc	/^void tx_log_walker_warpc::cycle()$/;"	f	class:tx_log_walker_warpc
cycle	shader.cc	/^void tx_log_walker_warpc_logical::cycle() {$/;"	f	class:tx_log_walker_warpc_logical
cycle	shader.h	/^    virtual void cycle() $/;"	f	class:pipelined_simd_unit
cycle	tm_conflict_detector.h	/^    void cycle() $/;"	f	class:tm_tid_vendor
cycle	tm_conflict_detector.h	/^    void cycle()$/;"	f	class:tm_conflict_detector
data	dram.h	/^   class mem_fetch * data;$/;"	m	class:dram_req_t	typeref:class:dram_req_t::mem_fetch
data_block	gpu-cache.h	/^        data_block() { m_valid = false; }$/;"	f	struct:tex_cache::data_block
data_block	gpu-cache.h	/^    struct data_block {$/;"	s	class:tex_cache
data_cache	gpu-cache.h	/^    data_cache( const char *name, cache_config &config,$/;"	f	class:data_cache
data_cache	gpu-cache.h	/^    data_cache( const char *name,$/;"	f	class:data_cache
data_cache	gpu-cache.h	/^class data_cache : public baseline_cache {$/;"	c
data_cachemiss	shader.h	/^      bool data_cachemiss;$/;"	m	struct:tx_log_walker::log_send_status_t
data_collection	dram_sched.cc	/^void frfcfs_scheduler::data_collection(unsigned int bank)$/;"	f	class:frfcfs_scheduler
data_command_freq_ratio	gpu-sim.h	/^   unsigned data_command_freq_ratio; \/\/ frequency ratio between DRAM data bus and command bus (2 for GDDR3, 4 for GDDR5)$/;"	m	struct:memory_config
data_hazard_t	scoreboard.h	/^enum data_hazard_t {$/;"	g
data_port_busy_cycles	gpu-cache.h	/^    unsigned long long data_port_busy_cycles; $/;"	m	struct:cache_sub_stats
data_port_free	gpu-cache.cc	/^bool baseline_cache::bandwidth_management::data_port_free() const$/;"	f	class:baseline_cache::bandwidth_management
data_port_free	gpu-cache.h	/^    bool data_port_free() const { return m_bandwidth_management.data_port_free(); } $/;"	f	class:baseline_cache
data_port_free	gpu-cache.h	/^    bool data_port_free() const { return true; }$/;"	f	class:tex_cache
data_read	shader.h	/^      bool data_read;$/;"	m	struct:tx_log_walker::log_send_status_t
deadlock_check	gpu-sim.cc	/^void gpgpu_sim::deadlock_check()$/;"	f	class:gpgpu_sim
deallocate_barrier	shader.cc	/^void barrier_set_t::deallocate_barrier( unsigned cta_id )$/;"	f	class:barrier_set_t
dec_inflight_insn	scoreboard.cc	/^void Scoreboard::dec_inflight_insn(unsigned warp_id) $/;"	f	class:Scoreboard
dec_inst_in_pipeline	shader.cc	/^void shader_core_ctx::dec_inst_in_pipeline( const warp_inst_t &inst )$/;"	f	class:shader_core_ctx
dec_inst_in_pipeline	shader.h	/^    void dec_inst_in_pipeline() $/;"	f	class:shd_warp_t
dec_n_atomic	shader.h	/^    void dec_n_atomic(unsigned n) { m_n_atomic-=n; }$/;"	f	class:shd_warp_t
dec_n_logical_tm_req	shader.h	/^    void dec_n_logical_tm_req(unsigned n) { m_n_logical_tm_req-=n; }$/;"	f	class:shd_warp_t
dec_n_logical_tm_req_per_thread	shader.h	/^    void dec_n_logical_tm_req_per_thread(unsigned tid) { m_n_logical_tm_req_per_thread[tid]--; }$/;"	f	class:shd_warp_t
dec_store_req	shader.h	/^    void dec_store_req() $/;"	f	class:shd_warp_t
decode	shader.cc	/^void shader_core_ctx::decode()$/;"	f	class:shader_core_ctx
decrement_atomic_count	shader.cc	/^void shader_core_ctx::decrement_atomic_count( unsigned wid, unsigned n )$/;"	f	class:shader_core_ctx
decrement_logical_tm_req_count	shader.cc	/^void shader_core_ctx::decrement_logical_tm_req_count( unsigned wid, unsigned n )$/;"	f	class:shader_core_ctx
delayfcd_reads_done	commit_unit.h	/^    bool delayfcd_reads_done() const { return m_delayfcd_reads_checked == read_set().get_linear_buffer().size(); }$/;"	f	class:commit_entry
delayfcd_writes_done	commit_unit.h	/^    bool delayfcd_writes_done() const { return m_delayfcd_writes_stored == write_set().get_linear_buffer().size(); }$/;"	f	class:commit_entry
delete_bloomfilter	commit_unit.cc	/^void cu_access_set::delete_bloomfilter()$/;"	f	class:cu_access_set
delete_ptx_thread_tm_manager	shader.cc	/^void tx_log_walker::delete_ptx_thread_tm_manager(int warp_id, int lane_id)$/;"	f	class:tx_log_walker
delete_tm_manager	commit_unit.cc	/^void commit_entry::delete_tm_manager()$/;"	f	class:commit_entry
delete_tm_manager	shader.cc	/^void tx_log_walker::commit_tx_t::delete_tm_manager()$/;"	f	class:tx_log_walker::commit_tx_t
destroy_thread_CFlogger	stat-tool.cc	/^void destroy_thread_CFlogger( ) $/;"	f
disableTMToken	scoreboard.h	/^    void disableTMToken() { m_enable_tm_token = false; }$/;"	f	class:Scoreboard
disabled	gpu-cache.h	/^    bool disabled() const { return m_disabled;}$/;"	f	class:cache_config
dispatch	shader.cc	/^void opndcoll_rfu_t::collector_unit_t::dispatch()$/;"	f	class:opndcoll_rfu_t::collector_unit_t
dispatch_ready_cu	shader.cc	/^void opndcoll_rfu_t::dispatch_ready_cu()$/;"	f	class:opndcoll_rfu_t
dispatch_unit_t	shader.h	/^      dispatch_unit_t(std::vector<collector_unit_t>* cus) $/;"	f	class:opndcoll_rfu_t::dispatch_unit_t
dispatch_unit_t	shader.h	/^   class dispatch_unit_t {$/;"	c	class:opndcoll_rfu_t
display	gpu-cache.cc	/^void mshr_table::display( FILE *fp ) const{$/;"	f	class:mshr_table
display	gpu-cache.cc	/^void tag_array::display( FILE *fout ) const $/;"	f	class:tag_array
display_pipeline	shader.cc	/^void shader_core_ctx::display_pipeline(FILE *fout, int print_mem, int mask ) const$/;"	f	class:shader_core_ctx
display_pipeline	shader.cc	/^void simt_core_cluster::display_pipeline( unsigned sid, FILE *fout, int print_mem, int mask )$/;"	f	class:simt_core_cluster
display_simt_state	shader.cc	/^void shader_core_ctx::display_simt_state(FILE *fout, int mask ) const$/;"	f	class:shader_core_ctx
display_state	gpu-cache.cc	/^void baseline_cache::display_state( FILE *fp, bool detail ) const{$/;"	f	class:baseline_cache
display_state	gpu-cache.cc	/^void tex_cache::display_state( FILE *fp ) const$/;"	f	class:tex_cache
do_atomic	mem_fetch.cc	/^void mem_fetch::do_atomic()$/;"	f	class:mem_fetch
do_logical_tm	mem_fetch.cc	/^void mem_fetch::do_logical_tm()$/;"	f	class:mem_fetch
do_on_warp_issued	shader.cc	/^two_level_active_scheduler::do_on_warp_issued( unsigned warp_id,$/;"	f	class:two_level_active_scheduler
do_on_warp_issued	shader.cc	/^void scheduler_unit::do_on_warp_issued( unsigned warp_id,$/;"	f	class:scheduler_unit
doneTMCommit	scoreboard.cc	/^void Scoreboard::doneTMCommit() $/;"	f	class:Scoreboard
doneTxCommit	scoreboard.cc	/^void Scoreboard::doneTxCommit(unsigned warp_id)$/;"	f	class:Scoreboard
doneTxRestart	scoreboard.cc	/^void Scoreboard::doneTxRestart(unsigned warp_id) $/;"	f	class:Scoreboard
done_adding_supervised_warps	shader.h	/^    virtual void done_adding_supervised_warps() {$/;"	f	class:gto_scheduler
done_adding_supervised_warps	shader.h	/^    virtual void done_adding_supervised_warps() {$/;"	f	class:lrr_scheduler
done_adding_supervised_warps	shader.h	/^    virtual void done_adding_supervised_warps() {$/;"	f	class:scheduler_unit
done_adding_supervised_warps	shader.h	/^    virtual void done_adding_supervised_warps() {$/;"	f	class:swl_scheduler
done_adding_supervised_warps	shader.h	/^    virtual void done_adding_supervised_warps() {$/;"	f	class:two_level_active_scheduler
done_exit	shader.h	/^    bool done_exit() const { return m_done_exit; }$/;"	f	class:shd_warp_t
done_revalidation_wait	commit_unit.cc	/^void commit_unit::done_revalidation_wait(commit_entry &ce)$/;"	f	class:commit_unit
done_send_rs	shader.cc	/^void tx_log_walker_warpc::done_send_rs(warp_commit_tx_t &cmt_warp) $/;"	f	class:tx_log_walker_warpc
done_send_rs	shader.h	/^   virtual void done_send_rs(warp_commit_tx_t &cmt_warp) {}; $/;"	f	class:tx_log_walker
done_send_ws	shader.cc	/^void tx_log_walker_warpc::done_send_ws(warp_commit_tx_t &cmt_warp)$/;"	f	class:tx_log_walker_warpc
done_send_ws	shader.cc	/^void tx_log_walker_warpc_logical::done_send_ws(warp_commit_tx_t &cmt_warp)$/;"	f	class:tx_log_walker_warpc_logical
done_send_ws	shader.h	/^   virtual void done_send_ws(warp_commit_tx_t &cmt_warp) {}; $/;"	f	class:tx_log_walker
done_validation_wait	commit_unit.cc	/^void commit_unit::done_validation_wait(commit_entry &ce)$/;"	f	class:commit_unit
dq_lat_table	mem_latency_stat.h	/^   unsigned dq_lat_table[32];$/;"	m	class:memory_stats_t
dqbytes	dram.h	/^   unsigned int dqbytes;$/;"	m	class:dram_req_t
dram_L2_queue_full	l2cache.cc	/^bool memory_sub_partition::dram_L2_queue_full() const$/;"	f	class:memory_sub_partition
dram_L2_queue_push	l2cache.cc	/^void memory_sub_partition::dram_L2_queue_push( class mem_fetch* mf )$/;"	f	class:memory_sub_partition
dram_atom_size	gpu-sim.h	/^   unsigned dram_atom_size; \/\/ number of bytes transferred per read or write command $/;"	m	struct:memory_config
dram_ctrl_t	gpu-sim.h	/^enum dram_ctrl_t {$/;"	g
dram_cycle	l2cache.cc	/^void memory_partition_unit::dram_cycle() $/;"	f	class:memory_partition_unit
dram_delay_t	l2cache.h	/^   struct dram_delay_t$/;"	s	class:memory_partition_unit
dram_eff_bins	dram.h	/^   unsigned int dram_eff_bins[10];$/;"	m	class:dram_t
dram_freq	gpu-sim.h	/^    double dram_freq;$/;"	m	class:gpgpu_sim_config
dram_latency	gpu-sim.h	/^   unsigned dram_latency;$/;"	m	struct:memory_config
dram_log	gpu-sim.cc	/^void dram_t::dram_log( int task ) $/;"	f	class:dram_t
dram_period	gpu-sim.h	/^    double dram_period;$/;"	m	class:gpgpu_sim_config
dram_req_t	dram.cc	/^dram_req_t::dram_req_t( class mem_fetch *mf )$/;"	f	class:dram_req_t
dram_req_t	dram.h	/^class dram_req_t {$/;"	c
dram_sched_h_INCLUDED	dram_sched.h	29;"	d
dram_t	dram.cc	/^dram_t::dram_t( unsigned int partition_id, const struct memory_config *config, memory_stats_t *stats,$/;"	f	class:dram_t
dram_t	dram.h	/^class dram_t $/;"	c
dram_time	gpu-sim.h	/^   double dram_time;$/;"	m	class:gpgpu_sim
dram_util_bins	dram.h	/^   unsigned int dram_util_bins[10];$/;"	m	class:dram_t
dump	commit_unit.cc	/^void commit_unit::dump()$/;"	f	class:commit_unit
dump	commit_unit.cc	/^void warp_commit_entry::dump(FILE *fout) const$/;"	f	class:warp_commit_entry
dump	shader.cc	/^void barrier_set_t::dump() const$/;"	f	class:barrier_set_t
dump	shader.cc	/^void opndcoll_rfu_t::collector_unit_t::dump(FILE *fp, const shader_core_ctx *shader ) const$/;"	f	class:opndcoll_rfu_t::collector_unit_t
dump	shader.h	/^      void dump(FILE *fp) const $/;"	f	class:opndcoll_rfu_t::op_t
dump	shader.h	/^      void dump(FILE *fp) const {$/;"	f	class:opndcoll_rfu_t::allocation_t
dump	shader.h	/^      void dump(FILE *fp) const$/;"	f	class:opndcoll_rfu_t::arbiter_t
dump	shader.h	/^   void dump( FILE *fp ) const$/;"	f	class:opndcoll_rfu_t
dump_pipeline	gpu-sim.cc	/^void gpgpu_sim::dump_pipeline( int mask, int s, int m ) const$/;"	f	class:gpgpu_sim
dump_sharer_histogram	coherence_manager.cc	/^void coherence_manager::dump_sharer_histogram(unsigned time) {$/;"	f	class:coherence_manager
dump_timestamps	commit_unit.cc	/^void commit_entry::dump_timestamps()$/;"	f	class:commit_entry
dump_warp_state	gpu-sim.cc	/^void shader_core_ctx::dump_warp_state( FILE *fout ) const$/;"	f	class:shader_core_ctx
element_exist_stack	stack.cc	/^int element_exist_stack(Stack *S, address_type value) {$/;"	f
empty	delayqueue.h	/^   bool empty() const { return m_head == NULL; }$/;"	f	class:fifo_pipeline
empty	gpu-cache.h	/^        bool empty() const { return m_num == 0; }$/;"	f	class:tex_cache::fifo
empty	l2cache.h	/^    bool empty() { return m_stall_queue.size() == 0; }$/;"	f	class:tm_req_stall_queue
empty	l2cache.h	/^    bool empty(addr_t addr) { return m_stall_queue.count(addr) == 0; }$/;"	f	class:tm_req_stall_queue
empty_stack	stack.cc	/^int empty_stack(Stack *S) {$/;"	f
enableTMToken	scoreboard.h	/^    void enableTMToken() { m_enable_tm_token = true; }$/;"	f	class:Scoreboard
enter_acq_cu_entries	shader.cc	/^void tx_log_walker::commit_tx_t::enter_acq_cu_entries(unsigned n_commit_unit, unsigned init_timeout)$/;"	f	class:tx_log_walker::commit_tx_t
enter_send_ack_cleanup	shader.cc	/^void tx_log_walker::commit_tx_t::enter_send_ack_cleanup(unsigned n_commit_unit)$/;"	f	class:tx_log_walker::commit_tx_t
enter_write_cu_reply	shader.cc	/^void tx_log_walker::commit_tx_t::enter_write_cu_reply(unsigned n_commit_unit)$/;"	f	class:tx_log_walker::commit_tx_t
entry_id	shader.h	/^      int entry_id; $/;"	m	struct:tx_log_walker::log_send_status_t
event_queue_empty	shader.h	/^      bool event_queue_empty() const { return m_event_q.empty(); } $/;"	f	class:tx_log_walker::iwcd_uarch_info
event_type	shader.h	/^      enum event_type {$/;"	g	class:tx_log_walker::iwcd_uarch_info
event_warp_issued	shader.cc	/^void shader_core_stats::event_warp_issued( unsigned s_id, unsigned warp_id, unsigned num_issued, unsigned dynamic_warp_id ) {$/;"	f	class:shader_core_stats
execute	shader.cc	/^void shader_core_ctx::execute()$/;"	f	class:shader_core_ctx
executed_kernel_info_string	gpu-sim.cc	/^std::string gpgpu_sim::executed_kernel_info_string() $/;"	f	class:gpgpu_sim
exit_parse_error	gpu-cache.h	/^    void exit_parse_error()$/;"	f	class:cache_config
extra_mf_fields	gpu-cache.h	/^        extra_mf_fields( new_addr_type a, unsigned i, unsigned d ) $/;"	f	struct:baseline_cache::extra_mf_fields
extra_mf_fields	gpu-cache.h	/^        extra_mf_fields( unsigned i ) $/;"	f	struct:tex_cache::extra_mf_fields
extra_mf_fields	gpu-cache.h	/^        extra_mf_fields()  { m_valid = false;}$/;"	f	struct:baseline_cache::extra_mf_fields
extra_mf_fields	gpu-cache.h	/^        extra_mf_fields()  { m_valid = false;}$/;"	f	struct:tex_cache::extra_mf_fields
extra_mf_fields	gpu-cache.h	/^    struct extra_mf_fields {$/;"	s	class:baseline_cache
extra_mf_fields	gpu-cache.h	/^    struct extra_mf_fields {$/;"	s	class:tex_cache
extra_mf_fields	shader.h	/^       extra_mf_fields( unsigned wid, unsigned tid, enum log_acc_type_t log_type, enum log_acc_type_t acc_type ) {$/;"	f	struct:tx_log_walker::extra_mf_fields
extra_mf_fields	shader.h	/^       extra_mf_fields()  { m_valid = false;}$/;"	f	struct:tx_log_walker::extra_mf_fields
extra_mf_fields	shader.h	/^   struct extra_mf_fields {$/;"	s	class:tx_log_walker
extra_mf_fields_lookup	gpu-cache.h	/^    typedef std::map<mem_fetch*,extra_mf_fields> extra_mf_fields_lookup;$/;"	t	class:baseline_cache
extra_mf_fields_lookup	gpu-cache.h	/^    typedef std::map<mem_fetch*,extra_mf_fields> extra_mf_fields_lookup;$/;"	t	class:tex_cache
extra_mf_fields_lookup	shader.h	/^   typedef std::map<mem_fetch*,extra_mf_fields> extra_mf_fields_lookup;$/;"	t	class:tx_log_walker
fail	commit_unit.h	/^    bool fail() const { return m_fail; }$/;"	f	class:commit_entry
fetch	shader.cc	/^void shader_core_ctx::fetch()$/;"	f	class:shader_core_ctx
fetch_unit_response_buffer_full	shader.cc	/^bool shader_core_ctx::fetch_unit_response_buffer_full() const$/;"	f	class:shader_core_ctx
fifo	gpu-cache.h	/^        fifo( unsigned size ) $/;"	f	class:tex_cache::fifo
fifo	gpu-cache.h	/^    template<class T> class fifo {$/;"	c	class:tex_cache
fifo_data	delayqueue.h	/^struct fifo_data {$/;"	s
fifo_pipeline	delayqueue.h	/^   fifo_pipeline(const char* nm, unsigned int minlen, unsigned int maxlen ) $/;"	f	class:fifo_pipeline
fifo_pipeline	delayqueue.h	/^class fifo_pipeline {$/;"	c
fill	gpu-cache.cc	/^void baseline_cache::fill(mem_fetch *mf, unsigned time){$/;"	f	class:baseline_cache
fill	gpu-cache.cc	/^void tag_array::fill( new_addr_type addr, unsigned time, bool wr )$/;"	f	class:tag_array
fill	gpu-cache.cc	/^void tag_array::fill( unsigned index, unsigned time, bool wr ) $/;"	f	class:tag_array
fill	gpu-cache.cc	/^void tex_cache::fill( mem_fetch *mf, unsigned time )$/;"	f	class:tex_cache
fill	gpu-cache.h	/^    void fill( unsigned time )$/;"	f	struct:cache_block_t
fill	shader.cc	/^void ldst_unit::fill( mem_fetch *mf )$/;"	f	class:ldst_unit
fill_port_busy_cycles	gpu-cache.h	/^    unsigned long long fill_port_busy_cycles; $/;"	m	struct:cache_sub_stats
fill_port_free	gpu-cache.cc	/^bool baseline_cache::bandwidth_management::fill_port_free() const$/;"	f	class:baseline_cache::bandwidth_management
fill_port_free	gpu-cache.h	/^    bool fill_port_free() const { return m_bandwidth_management.fill_port_free(); } $/;"	f	class:baseline_cache
fill_port_free	gpu-cache.h	/^    bool fill_port_free() const { return true; }$/;"	f	class:tex_cache
find_ready	shader.h	/^      collector_unit_t *find_ready()$/;"	f	class:opndcoll_rfu_t::dispatch_unit_t
finished_kernel	gpu-sim.cc	/^unsigned gpgpu_sim::finished_kernel()$/;"	f	class:gpgpu_sim
flush	coherence_manager.cc	/^void coherence_tag_array::flush()$/;"	f	class:coherence_tag_array
flush	gpu-cache.cc	/^void tag_array::flush() $/;"	f	class:tag_array
flush	gpu-cache.h	/^    void flush(){m_tag_array->flush();}$/;"	f	class:baseline_cache
flush	shader.cc	/^void ldst_unit::flush(){$/;"	f	class:ldst_unit
flushL2	l2cache.cc	/^unsigned memory_sub_partition::flushL2() $/;"	f	class:memory_sub_partition
flush_cache	coherence_manager.cc	/^void coherence_manager::flush_cache(unsigned hwtid)$/;"	f	class:coherence_manager
fprint	histogram.cc	/^void binned_histogram::fprint (FILE *fout) const$/;"	f	class:binned_histogram
fragment_entry	gpu-cache.h	/^        fragment_entry( mem_fetch *mf, unsigned idx, bool m, unsigned d )$/;"	f	struct:tex_cache::fragment_entry
fragment_entry	gpu-cache.h	/^        fragment_entry() {}$/;"	f	struct:tex_cache::fragment_entry
fragment_entry	gpu-cache.h	/^    struct fragment_entry {$/;"	s	class:tex_cache
free_stack	stack.cc	/^void free_stack(Stack *S) {$/;"	f
frfcfs_scheduler	dram_sched.cc	/^frfcfs_scheduler::frfcfs_scheduler( const memory_config *config, dram_t *dm, memory_stats_t *stats )$/;"	f	class:frfcfs_scheduler
frfcfs_scheduler	dram_sched.h	/^class frfcfs_scheduler {$/;"	c
full	commit_unit.cc	/^bool commit_unit::full()$/;"	f	class:commit_unit
full	delayqueue.h	/^   bool full() const { return (m_max_len && m_length >= m_max_len); }$/;"	f	class:fifo_pipeline
full	dram.cc	/^bool dram_t::full() const $/;"	f	class:dram_t
full	gpu-cache.cc	/^bool mshr_table::full( new_addr_type block_addr ) const{$/;"	f	class:mshr_table
full	gpu-cache.h	/^        bool full() const { return m_num == m_size; }$/;"	f	class:tex_cache::fifo
full	l2cache.cc	/^bool memory_sub_partition::full() const$/;"	f	class:memory_sub_partition
full	l2cache.h	/^        virtual bool full(unsigned size, bool write) const {$/;"	f	class:L2icnt_interface
full	l2cache.h	/^    bool full(addr_t addr) { $/;"	f	class:tm_req_stall_queue
full	l2cache.h	/^    virtual bool full( unsigned size, bool write) const $/;"	f	class:L2interface
full	shader.h	/^    virtual bool full( unsigned size, bool write ) const $/;"	f	class:perfect_memory_interface
full	shader.h	/^    virtual bool full( unsigned size, bool write ) const $/;"	f	class:shader_memory_interface
full	tm_conflict_detector.h	/^    bool full() const$/;"	f	class:tm_tid_vendor
full_stack	stack.cc	/^int full_stack(Stack *S) {$/;"	f
func_exec_inst	shader.cc	/^void shader_core_ctx::func_exec_inst( warp_inst_t &inst )$/;"	f	class:shader_core_ctx
functional_done	shader.cc	/^bool shd_warp_t::functional_done() const$/;"	f	class:shd_warp_t
g_cu_options	commit_unit.cc	/^static commit_unit_options g_cu_options; $/;"	v	file:
g_cu_stats	commit_unit.cc	/^static commit_unit_stats g_cu_stats; $/;"	v	file:
g_debug_dcache_write_miss	gpu-cache.cc	/^unsigned g_debug_dcache_write_miss = 0;$/;"	v
g_interactive_debugger_enabled	gpu-sim.cc	/^bool g_interactive_debugger_enabled=false;$/;"	v
g_metric_trace_filename	gpu-sim.h	/^    char *g_metric_trace_filename;$/;"	m	struct:power_config
g_my_time_vector	visualizer.cc	/^my_time_vector* g_my_time_vector; $/;"	v
g_network_config_filename	icnt_wrapper.cc	/^char* g_network_config_filename;$/;"	v
g_network_mode	icnt_wrapper.cc	/^int   g_network_mode;$/;"	v
g_power_config_name	gpu-sim.h	/^	char *g_power_config_name;$/;"	m	struct:power_config
g_power_filename	gpu-sim.h	/^    char *g_power_filename;$/;"	m	struct:power_config
g_power_per_cycle_dump	gpu-sim.h	/^    bool g_power_per_cycle_dump;$/;"	m	struct:power_config
g_power_simulation_enabled	gpu-sim.h	/^    bool g_power_simulation_enabled;$/;"	m	struct:power_config
g_power_simulator_debug	gpu-sim.h	/^    bool g_power_simulator_debug;$/;"	m	struct:power_config
g_power_trace_enabled	gpu-sim.h	/^    bool g_power_trace_enabled;$/;"	m	struct:power_config
g_power_trace_filename	gpu-sim.h	/^    char *g_power_trace_filename;$/;"	m	struct:power_config
g_power_trace_zlevel	gpu-sim.h	/^    int g_power_trace_zlevel;$/;"	m	struct:power_config
g_scb_options	scoreboard.cc	/^scoreboard_options g_scb_options; $/;"	v
g_scoreboard	scoreboard.cc	/^global_scoreboard g_scoreboard; $/;"	v
g_single_step	gpu-sim.cc	/^unsigned long long g_single_step=0; \/\/ set this in gdb to single step the pipeline$/;"	v
g_steady_power_levels_enabled	gpu-sim.h	/^    bool g_steady_power_levels_enabled;$/;"	m	struct:power_config
g_steady_state_tracking_filename	gpu-sim.h	/^    char * g_steady_state_tracking_filename;$/;"	m	struct:power_config
g_use_nonlinear_model	gpu-sim.h	/^    bool g_use_nonlinear_model;$/;"	m	struct:power_config
g_visualizer_enabled	gpu-sim.h	/^    bool  g_visualizer_enabled;$/;"	m	class:gpgpu_sim_config
g_visualizer_filename	gpu-sim.h	/^    char *g_visualizer_filename;$/;"	m	class:gpgpu_sim_config
g_visualizer_zlevel	gpu-sim.h	/^    int   g_visualizer_zlevel;$/;"	m	class:gpgpu_sim_config
gap	addrdec.h	/^   unsigned int gap;$/;"	m	class:linear_to_raw_address_translation
generate_cu_alloc	shader.cc	/^void tx_log_walker::generate_cu_alloc(const warp_inst_t &inst, commit_tx_t &tp)$/;"	f	class:tx_log_walker
generate_done_fill	shader.cc	/^void tx_log_walker::generate_done_fill(const warp_inst_t &inst, commit_tx_t &tp)$/;"	f	class:tx_log_walker
generate_done_fill_coalesced	shader.cc	/^void tx_log_walker_warpc::generate_done_fill_coalesced(const warp_inst_t &inst, commit_tx_t &tp)$/;"	f	class:tx_log_walker_warpc
generate_skip	shader.cc	/^void tx_log_walker::generate_skip(const warp_inst_t &inst, commit_tx_t &tp, int lane_id)$/;"	f	class:tx_log_walker
getDataHazardType	scoreboard.cc	/^data_hazard_t Scoreboard::getDataHazardType(unsigned wid, const inst_t *inst) const$/;"	f	class:Scoreboard
getMemoryConfig	gpu-sim.cc	/^const struct memory_config * gpgpu_sim::getMemoryConfig()$/;"	f	class:gpgpu_sim
getSIMTCluster	gpu-sim.cc	/^simt_core_cluster * gpgpu_sim::getSIMTCluster()$/;"	f	class:gpgpu_sim
getShaderCoreConfig	gpu-sim.cc	/^const struct shader_core_config * gpgpu_sim::getShaderCoreConfig()$/;"	f	class:gpgpu_sim
get_L1C_sub_stats	shader.cc	/^void ldst_unit::get_L1C_sub_stats(struct cache_sub_stats &css) const{$/;"	f	class:ldst_unit
get_L1C_sub_stats	shader.cc	/^void shader_core_ctx::get_L1C_sub_stats(struct cache_sub_stats &css) const{$/;"	f	class:shader_core_ctx
get_L1C_sub_stats	shader.cc	/^void simt_core_cluster::get_L1C_sub_stats(struct cache_sub_stats &css) const{$/;"	f	class:simt_core_cluster
get_L1D_sub_stats	shader.cc	/^void ldst_unit::get_L1D_sub_stats(struct cache_sub_stats &css) const{$/;"	f	class:ldst_unit
get_L1D_sub_stats	shader.cc	/^void shader_core_ctx::get_L1D_sub_stats(struct cache_sub_stats &css) const{$/;"	f	class:shader_core_ctx
get_L1D_sub_stats	shader.cc	/^void simt_core_cluster::get_L1D_sub_stats(struct cache_sub_stats &css) const{$/;"	f	class:simt_core_cluster
get_L1I_sub_stats	shader.cc	/^void shader_core_ctx::get_L1I_sub_stats(struct cache_sub_stats &css) const{$/;"	f	class:shader_core_ctx
get_L1I_sub_stats	shader.cc	/^void simt_core_cluster::get_L1I_sub_stats(struct cache_sub_stats &css) const{$/;"	f	class:simt_core_cluster
get_L1T_sub_stats	shader.cc	/^void ldst_unit::get_L1T_sub_stats(struct cache_sub_stats &css) const{$/;"	f	class:ldst_unit
get_L1T_sub_stats	shader.cc	/^void shader_core_ctx::get_L1T_sub_stats(struct cache_sub_stats &css) const{$/;"	f	class:shader_core_ctx
get_L1T_sub_stats	shader.cc	/^void simt_core_cluster::get_L1T_sub_stats(struct cache_sub_stats &css) const{$/;"	f	class:simt_core_cluster
get_L2cache_sub_stats	l2cache.cc	/^void memory_sub_partition::get_L2cache_sub_stats(struct cache_sub_stats &css) const{$/;"	f	class:memory_sub_partition
get_access_byte_mask	mem_fetch.h	/^   mem_access_byte_mask_t get_access_byte_mask() const { return m_access.get_byte_mask(); }$/;"	f	class:mem_fetch
get_access_type	mem_fetch.h	/^   enum mem_access_type get_access_type() const { return m_access.get_type(); }$/;"	f	class:mem_fetch
get_access_warp_mask	mem_fetch.h	/^   const active_mask_t& get_access_warp_mask() const { return m_access.get_warp_mask(); }$/;"	f	class:mem_fetch
get_active_count	shader.h	/^      unsigned get_active_count() const { return m_warp->active_count(); }$/;"	f	class:opndcoll_rfu_t::collector_unit_t
get_active_count	shader.h	/^      unsigned get_active_count() const$/;"	f	class:opndcoll_rfu_t::op_t
get_active_lanes_in_pipeline	shader.h	/^    virtual unsigned get_active_lanes_in_pipeline()$/;"	f	class:pipelined_simd_unit
get_active_mask	shader.h	/^      const active_mask_t & get_active_mask() const { return m_warp->get_active_mask(); }$/;"	f	class:opndcoll_rfu_t::collector_unit_t
get_active_mask	shader.h	/^      const active_mask_t & get_active_mask()$/;"	f	class:opndcoll_rfu_t::op_t
get_addr	mem_fetch.h	/^   new_addr_type get_addr() const { return m_access.get_addr(); }$/;"	f	class:mem_fetch
get_aliasing_depth	shader.cc	/^   void get_aliasing_depth( int &avg, int &max, int &usage ) const $/;"	f	class:ownership_table
get_allocated_size	commit_unit.h	/^    unsigned get_allocated_size() const {$/;"	f	class:commit_unit
get_bank	shader.h	/^      unsigned get_bank() const { return m_bank; }$/;"	f	class:opndcoll_rfu_t::op_t
get_block	gpu-cache.h	/^    cache_block_t &get_block(unsigned idx) { return m_lines[idx]; }$/;"	f	class:tag_array
get_busy	commit_unit.cc	/^bool commit_unit::get_busy()$/;"	f	class:commit_unit
get_byte_mask	mem_fetch.h	/^   mem_access_byte_mask_t get_byte_mask() const { return m_access.get_byte_mask(); }$/;"	f	class:mem_fetch
get_cache_config	gpu-sim.cc	/^FuncCache gpgpu_sim::get_cache_config(std::string kernel_name)$/;"	f	class:gpgpu_sim
get_cache_misses	power_stat.h	/^    unsigned get_cache_misses(){$/;"	f	class:power_stat_t
get_cache_read_misses	power_stat.h	/^    unsigned get_cache_read_misses(){$/;"	f	class:power_stat_t
get_cache_stats	shader.cc	/^void ldst_unit::get_cache_stats(cache_stats &cs) {$/;"	f	class:ldst_unit
get_cache_stats	shader.cc	/^void shader_core_ctx::get_cache_stats(cache_stats &cs){$/;"	f	class:shader_core_ctx
get_cache_stats	shader.cc	/^void simt_core_cluster::get_cache_stats(cache_stats &cs) const{$/;"	f	class:simt_core_cluster
get_cache_status	gpu-cache.h	/^    FuncCache get_cache_status() {return cache_status;}$/;"	f	class:cache_config
get_cache_write_misses	power_stat.h	/^    unsigned get_cache_write_misses(){$/;"	f	class:power_stat_t
get_coalesced_packet_list	mem_fetch.cc	/^std::list<mem_fetch*>& mem_fetch::get_coalesced_packet_list() $/;"	f	class:mem_fetch
get_coherence_manager	gpu-sim.h	/^   coherence_manager* get_coherence_manager() { return m_coherence_manager; }$/;"	f	class:gpgpu_sim
get_commit_entry	commit_unit.cc	/^commit_entry& commit_unit::get_commit_entry(int commit_id)$/;"	f	class:commit_unit
get_commit_id	commit_unit.h	/^    int get_commit_id() const { return m_commit_id; }$/;"	f	class:commit_entry
get_commit_id	mem_fetch.h	/^   int get_commit_id( ) { return m_commit_id; }$/;"	f	class:mem_fetch
get_commit_ids	commit_unit.h	/^   const std::vector<int>& get_commit_ids() const { return m_commit_ids; }$/;"	f	class:warp_commit_entry
get_commit_pending_ptr	mem_fetch.h	/^   std::bitset<16>* get_commit_pending_ptr() { return m_commit_pending_flag; }$/;"	f	class:mem_fetch
get_commit_unit_generated	mem_fetch.h	/^   bool get_commit_unit_generated() { return m_commit_unit_generated; }$/;"	f	class:mem_fetch
get_committed_inst	power_stat.h	/^    unsigned get_committed_inst(){$/;"	f	class:power_stat_t
get_config	gpu-sim.h	/^   const gpgpu_sim_config &get_config() const { return m_config; }$/;"	f	class:gpgpu_sim
get_config	shader.h	/^    const shader_core_config *get_config() const { return m_config; }$/;"	f	class:shader_core_ctx
get_constant_c_accesses	power_stat.h	/^    unsigned get_constant_c_accesses(){$/;"	f	class:power_stat_t
get_constant_c_hits	power_stat.h	/^    unsigned get_constant_c_hits(){$/;"	f	class:power_stat_t
get_constant_c_misses	power_stat.h	/^    unsigned get_constant_c_misses(){$/;"	f	class:power_stat_t
get_cta_id	shader.h	/^    unsigned get_cta_id() const { return m_cta_id; }$/;"	f	class:shd_warp_t
get_ctp	shader.cc	/^tx_log_walker::commit_tx_t* tx_log_walker::get_ctp(int tid)$/;"	f	class:tx_log_walker
get_ctrl_size	mem_fetch.h	/^   unsigned get_ctrl_size() const { return m_ctrl_size; }$/;"	f	class:mem_fetch
get_current_wid	shader.h	/^   unsigned get_current_wid() const { return m_current_wid; } $/;"	f	class:history_file_t
get_data_size	mem_fetch.h	/^   unsigned get_data_size() const { return m_data_size; }$/;"	f	class:mem_fetch
get_directory_sharer_histogram	coherence_manager.cc	/^linear_histogram coherence_manager::get_directory_sharer_histogram() {$/;"	f	class:coherence_manager
get_dram_act	power_stat.h	/^    unsigned get_dram_act(){$/;"	f	class:power_stat_t
get_dram_activity	power_stat.h	/^    unsigned get_dram_activity(){$/;"	f	class:power_stat_t
get_dram_cmd	power_stat.h	/^    unsigned get_dram_cmd(){$/;"	f	class:power_stat_t
get_dram_nop	power_stat.h	/^    unsigned get_dram_nop(){$/;"	f	class:power_stat_t
get_dram_pre	power_stat.h	/^    unsigned get_dram_pre(){$/;"	f	class:power_stat_t
get_dram_rd	power_stat.h	/^    unsigned get_dram_rd(){$/;"	f	class:power_stat_t
get_dram_req	power_stat.h	/^    unsigned get_dram_req(){$/;"	f	class:power_stat_t
get_dram_wr	power_stat.h	/^    unsigned get_dram_wr(){$/;"	f	class:power_stat_t
get_dynamic_warp_id	shader.h	/^    unsigned get_dynamic_warp_id() const { return m_dynamic_warp_id; }$/;"	f	class:shd_warp_t
get_dynamic_warp_issue	shader.h	/^    const std::vector< std::vector<unsigned> >& get_dynamic_warp_issue() const$/;"	f	class:shader_core_stats
get_fill_addr	mem_fetch.h	/^   new_addr_type get_fill_addr() const { return m_access.get_fill_addr(); }$/;"	f	class:mem_fetch
get_final	commit_unit.h	/^    bool get_final() const { return m_final_pass; }$/;"	f	class:commit_entry
get_fpdiv_accessess	power_stat.h	/^    unsigned get_fpdiv_accessess(){$/;"	f	class:power_stat_t
get_fpmul_accessess	power_stat.h	/^    unsigned get_fpmul_accessess(){$/;"	f	class:power_stat_t
get_full_line_mask	gpu-cache.h	/^    const mem_access_byte_mask_t& get_full_line_mask() const$/;"	f	class:cache_config
get_func_thread_info	shader.cc	/^class ptx_thread_info* shader_core_ctx::get_func_thread_info(unsigned tid) const $/;"	f	class:shader_core_ctx
get_functional_thread	shader.h	/^    ptx_thread_info *get_functional_thread( unsigned sid)$/;"	f	class:simt_core_cluster
get_functional_thread	shader.h	/^    ptx_thread_info *get_functional_thread() $/;"	f	class:shader_core_ctx
get_gpu	shader.h	/^    gpgpu_sim *get_gpu() { return m_gpu; }$/;"	f	class:simt_core_cluster
get_ialu_accessess	power_stat.h	/^    unsigned get_ialu_accessess(){$/;"	f	class:power_stat_t
get_icnt_mem_to_simt	power_stat.h	/^    long get_icnt_mem_to_simt(){$/;"	f	class:power_stat_t
get_icnt_power_stats	shader.cc	/^void shader_core_ctx::get_icnt_power_stats(long &n_simt_to_mem, long &n_mem_to_simt) const{$/;"	f	class:shader_core_ctx
get_icnt_receive_time	mem_fetch.h	/^   unsigned get_icnt_receive_time() const { return m_icnt_receive_time; }$/;"	f	class:mem_fetch
get_icnt_simt_to_mem	power_stat.h	/^    long get_icnt_simt_to_mem(){$/;"	f	class:power_stat_t
get_icnt_stats	shader.cc	/^void simt_core_cluster::get_icnt_stats(long &n_simt_to_mem, long &n_mem_to_simt) const {$/;"	f	class:simt_core_cluster
get_id	l2cache.h	/^   unsigned get_id() const { return m_id; } $/;"	f	class:memory_sub_partition
get_id	shader.h	/^      unsigned get_id() const { return m_cuid; } \/\/ returns CU hw id$/;"	f	class:opndcoll_rfu_t::collector_unit_t
get_inst	mem_fetch.h	/^   const warp_inst_t &get_inst() { return m_inst; }$/;"	f	class:mem_fetch
get_inst_c_accesses	power_stat.h	/^    unsigned get_inst_c_accesses(){$/;"	f	class:power_stat_t
get_inst_c_hits	power_stat.h	/^    unsigned get_inst_c_hits(){$/;"	f	class:power_stat_t
get_inst_c_misses	power_stat.h	/^    unsigned get_inst_c_misses(){$/;"	f	class:power_stat_t
get_intdiv_accessess	power_stat.h	/^    unsigned get_intdiv_accessess(){$/;"	f	class:power_stat_t
get_interval	stat-tool.h	/^   const unsigned long long & get_interval() const { return m_snap_shot_interval;}$/;"	f	class:snap_shot_trigger
get_intmul24_accessess	power_stat.h	/^    unsigned get_intmul24_accessess(){$/;"	f	class:power_stat_t
get_intmul32_accessess	power_stat.h	/^    unsigned get_intmul32_accessess(){$/;"	f	class:power_stat_t
get_intmul_accessess	power_stat.h	/^    unsigned get_intmul_accessess(){$/;"	f	class:power_stat_t
get_is_write	mem_fetch.h	/^   bool     get_is_write() const { return m_access.is_write(); }$/;"	f	class:mem_fetch
get_kernel	shader.h	/^    kernel_info_t *get_kernel() { return m_kernel; }$/;"	f	class:shader_core_ctx
get_l1d_read_accesses	power_stat.h	/^    unsigned get_l1d_read_accesses(){$/;"	f	class:power_stat_t
get_l1d_read_hits	power_stat.h	/^    unsigned get_l1d_read_hits(){$/;"	f	class:power_stat_t
get_l1d_read_misses	power_stat.h	/^    unsigned get_l1d_read_misses(){$/;"	f	class:power_stat_t
get_l1d_write_accesses	power_stat.h	/^    unsigned get_l1d_write_accesses(){$/;"	f	class:power_stat_t
get_l1d_write_hits	power_stat.h	/^    unsigned get_l1d_write_hits(){$/;"	f	class:power_stat_t
get_l1d_write_misses	power_stat.h	/^    unsigned get_l1d_write_misses(){$/;"	f	class:power_stat_t
get_l2_read_accesses	power_stat.h	/^    unsigned get_l2_read_accesses(){$/;"	f	class:power_stat_t
get_l2_read_hits	power_stat.h	/^    unsigned get_l2_read_hits(){$/;"	f	class:power_stat_t
get_l2_read_misses	power_stat.h	/^    unsigned get_l2_read_misses(){$/;"	f	class:power_stat_t
get_l2_write_accesses	power_stat.h	/^    unsigned get_l2_write_accesses(){$/;"	f	class:power_stat_t
get_l2_write_hits	power_stat.h	/^    unsigned get_l2_write_hits(){$/;"	f	class:power_stat_t
get_l2_write_misses	power_stat.h	/^    unsigned get_l2_write_misses(){$/;"	f	class:power_stat_t
get_lane	commit_unit.cc	/^int warp_commit_entry::get_lane(const commit_entry& cmt_entry) const $/;"	f	class:warp_commit_entry
get_length	delayqueue.h	/^   unsigned get_length() const { return m_length; }$/;"	f	class:fifo_pipeline
get_line_sz	gpu-cache.h	/^    unsigned get_line_sz() const$/;"	f	class:cache_config
get_linear_buffer	commit_unit.h	/^    const linear_buffer_t& get_linear_buffer() const { return m_linear_buffer; }$/;"	f	class:cu_access_set
get_max_commit_id	commit_unit.h	/^   int get_max_commit_id() const { return m_max_commit_id; }$/;"	f	class:warp_commit_entry
get_max_commit_id_with_skip	commit_unit.h	/^   int get_max_commit_id_with_skip() const { return m_max_commit_id_with_skip; }$/;"	f	class:warp_commit_entry
get_max_concurrent_kernel	gpu-sim.h	/^    unsigned get_max_concurrent_kernel() const { return max_concurrent_kernel; }$/;"	f	class:gpgpu_sim_config
get_max_len	delayqueue.h	/^   unsigned get_max_len() const { return m_max_len; }$/;"	f	class:fifo_pipeline
get_mem_accessess	power_stat.h	/^    unsigned get_mem_accessess(){$/;"	f	class:power_stat_t
get_mem_committed_inst	power_stat.h	/^    unsigned get_mem_committed_inst(){$/;"	f	class:power_stat_t
get_mem_config	mem_fetch.h	/^   const memory_config *get_mem_config(){return m_mem_config;}$/;"	f	class:mem_fetch
get_mem_fetch_pts	mem_fetch.h	/^   unsigned long long get_mem_fetch_pts() const { return mem_fetch_pts; } $/;"	f	class:mem_fetch
get_membar	shader.h	/^    bool get_membar() const { return m_membar; }$/;"	f	class:shd_warp_t
get_memory_partition_id	mem_fetch.h	/^   unsigned get_memory_partition_id() const { return m_raw_addr.chip; }$/;"	f	class:mem_fetch
get_more_cta_left	gpu-sim.cc	/^bool gpgpu_sim::get_more_cta_left() const$/;"	f	class:gpgpu_sim
get_mpid	l2cache.h	/^   unsigned get_mpid() const { return m_id; }$/;"	f	class:memory_partition_unit
get_n_active_cta	shader.cc	/^unsigned simt_core_cluster::get_n_active_cta() const$/;"	f	class:simt_core_cluster
get_n_active_cta	shader.h	/^    unsigned get_n_active_cta() const { return m_n_active_cta; }$/;"	f	class:shader_core_ctx
get_n_active_sms	shader.cc	/^unsigned simt_core_cluster::get_n_active_sms() const$/;"	f	class:simt_core_cluster
get_n_atomic	shader.h	/^    unsigned get_n_atomic() const { return m_n_atomic; }$/;"	f	class:shd_warp_t
get_n_completed	shader.h	/^    unsigned get_n_completed() const { return n_completed; }$/;"	f	class:shd_warp_t
get_n_element	delayqueue.h	/^   unsigned get_n_element() const { return m_n_element; }$/;"	f	class:fifo_pipeline
get_n_logical_tm_req	shader.h	/^    unsigned get_n_logical_tm_req() const { return m_n_logical_tm_req; }$/;"	f	class:shd_warp_t
get_n_logical_tm_req_per_thread	shader.h	/^    unsigned get_n_logical_tm_req_per_thread(unsigned tid) { return m_n_logical_tm_req_per_thread[tid]; }$/;"	f	class:shd_warp_t
get_next_delayfcd_read	commit_unit.cc	/^new_addr_type commit_entry::get_next_delayfcd_read()$/;"	f	class:commit_entry
get_next_delayfcd_write	commit_unit.cc	/^new_addr_type commit_entry::get_next_delayfcd_write()$/;"	f	class:commit_entry
get_next_mf	l2cache.cc	/^mem_fetch * tm_req_stall_queue::get_next_mf() {$/;"	f	class:tm_req_stall_queue
get_non_regfile_operands	power_stat.h	/^    unsigned get_non_regfile_operands(){$/;"	f	class:power_stat_t
get_not_completed	shader.cc	/^unsigned simt_core_cluster::get_not_completed() const$/;"	f	class:simt_core_cluster
get_not_completed	shader.h	/^    unsigned get_not_completed() const { return m_not_completed; }$/;"	f	class:shader_core_ctx
get_num_flits	mem_fetch.cc	/^unsigned mem_fetch::get_num_flits(bool simt_to_mem){$/;"	f	class:mem_fetch
get_num_lines	gpu-cache.h	/^    unsigned get_num_lines() const$/;"	f	class:cache_config
get_num_operands	shader.h	/^      unsigned get_num_operands() const{$/;"	f	class:opndcoll_rfu_t::collector_unit_t
get_num_regs	shader.h	/^      unsigned get_num_regs() const{$/;"	f	class:opndcoll_rfu_t::collector_unit_t
get_num_sets	gpu-cache.h	/^    unsigned get_num_sets() const $/;"	f	class:cache_config
get_oc_id	shader.h	/^      unsigned get_oc_id() const { return m_cu->get_id(); }$/;"	f	class:opndcoll_rfu_t::op_t
get_operand	shader.h	/^      unsigned get_operand() const { return m_operand; }$/;"	f	class:opndcoll_rfu_t::op_t
get_operands	shader.h	/^      const op_t *get_operands() const { return m_src_op; }$/;"	f	class:opndcoll_rfu_t::collector_unit_t
get_owner	shader.cc	/^   int get_owner(addr_t address_tag) $/;"	f	class:ownership_table
get_owner_infinite	shader.cc	/^   int get_owner_infinite(addr_t address_tag) $/;"	f	class:ownership_table
get_partition_addr	mem_fetch.h	/^   new_addr_type get_partition_addr() const { return m_partition_addr; }$/;"	f	class:mem_fetch
get_pc	mem_fetch.h	/^   address_type get_pc() const { return m_inst.empty()?-1:m_inst.pc; }$/;"	f	class:mem_fetch
get_pc	shader.h	/^    address_type get_pc() const { return m_next_pc; }$/;"	f	class:shd_warp_t
get_pdom_stack_top_info	shader.cc	/^void gpgpu_sim::get_pdom_stack_top_info( unsigned sid, unsigned tid, unsigned *pc, unsigned *rpc )$/;"	f	class:gpgpu_sim
get_pdom_stack_top_info	shader.cc	/^void shader_core_ctx::get_pdom_stack_top_info( unsigned tid, unsigned *pc, unsigned *rpc ) const$/;"	f	class:shader_core_ctx
get_pdom_stack_top_info	shader.cc	/^void simt_core_cluster::get_pdom_stack_top_info( unsigned sid, unsigned tid, unsigned *pc, unsigned *rpc ) const$/;"	f	class:simt_core_cluster
get_pipeline_duty	power_stat.h	/^    float get_pipeline_duty(){$/;"	f	class:power_stat_t
get_pmem_exempt_kernel	gpu-sim.h	/^    const char* get_pmem_exempt_kernel() const { return pmem_exempt_kernel; }$/;"	f	class:gpgpu_sim_config
get_prop	gpu-sim.cc	/^const struct cudaDeviceProp *gpgpu_sim::get_prop() const$/;"	f	class:gpgpu_sim
get_reg	shader.h	/^      unsigned get_reg() const$/;"	f	class:opndcoll_rfu_t::op_t
get_reg_string	shader.h	/^      std::string get_reg_string() const$/;"	f	class:opndcoll_rfu_t::op_t
get_regfile_reads	power_stat.h	/^    unsigned get_regfile_reads(){$/;"	f	class:power_stat_t
get_regfile_writes	power_stat.h	/^    unsigned get_regfile_writes(){$/;"	f	class:power_stat_t
get_regs_restore	shader.cc	/^std::list<unsigned> history_file_t::get_regs_restore() $/;"	f	class:history_file_t
get_regs_written	shader.cc	/^std::list<unsigned> shader_core_ctx::get_regs_written( const inst_t &fvt ) const$/;"	f	class:shader_core_ctx
get_request_uid	mem_fetch.h	/^   unsigned get_request_uid() const { return m_request_uid; }$/;"	f	class:mem_fetch
get_retire_cid_at_fill	commit_unit.h	/^    int get_retire_cid_at_fill() const { return m_retire_ptr_at_fill; }$/;"	f	class:commit_entry
get_return_timestamp	mem_fetch.h	/^   unsigned get_return_timestamp() const { return m_timestamp2; }$/;"	f	class:mem_fetch
get_revalidate	commit_unit.h	/^    bool get_revalidate() const { return m_revalidate; }$/;"	f	class:commit_entry
get_sent_icnt_traffic	commit_unit.h	/^    unsigned get_sent_icnt_traffic() const { return m_sent_icnt_traffic; } $/;"	f	class:commit_unit
get_sent_icnt_traffic	shader.h	/^   unsigned get_sent_icnt_traffic() const { return m_sent_icnt_traffic; }$/;"	f	class:tx_log_walker
get_sfu_accessess	power_stat.h	/^    unsigned get_sfu_accessess(){$/;"	f	class:power_stat_t
get_sfu_active_lanes	power_stat.h	/^    float get_sfu_active_lanes(){$/;"	f	class:power_stat_t
get_sfu_committed_inst	power_stat.h	/^    unsigned get_sfu_committed_inst(){$/;"	f	class:power_stat_t
get_shader_constant_cache_id	stat-tool.cc	/^int get_shader_constant_cache_id() { return CONSTANT; }$/;"	f
get_shader_instruction_cache_id	stat-tool.cc	/^int get_shader_instruction_cache_id() { return INSTRUCTION; }$/;"	f
get_shader_normal_cache_id	stat-tool.cc	/^int get_shader_normal_cache_id() { return NORMAL; }$/;"	f
get_shader_texture_cache_id	stat-tool.cc	/^int get_shader_texture_cache_id() { return TEXTURE; }$/;"	f
get_shmem_read_access	power_stat.h	/^    unsigned get_shmem_read_access(){$/;"	f	class:power_stat_t
get_sid	commit_unit.h	/^    int get_sid() const { return m_sid; }$/;"	f	class:commit_entry
get_sid	commit_unit.h	/^   int get_sid() const { return m_sid; }$/;"	f	class:warp_commit_entry
get_sid	mem_fetch.h	/^   unsigned get_sid() const { return m_sid; }$/;"	f	class:mem_fetch
get_sid	scoreboard.h	/^    int get_sid() const { return m_sid; }$/;"	f	class:Scoreboard
get_sid	shader.h	/^    unsigned get_sid() const { return m_sid; }$/;"	f	class:shader_core_ctx
get_sid	shader.h	/^inline int scheduler_unit::get_sid() const { return m_shader->get_sid(); }$/;"	f	class:scheduler_unit
get_size	shader.cc	/^   size_t get_size() const $/;"	f	class:ownership_table
get_sp_accessess	power_stat.h	/^    unsigned get_sp_accessess(){$/;"	f	class:power_stat_t
get_sp_active_lanes	power_stat.h	/^    float get_sp_active_lanes(){$/;"	f	class:power_stat_t
get_sp_committed_inst	power_stat.h	/^    unsigned get_sp_committed_inst(){$/;"	f	class:power_stat_t
get_sp_op	shader.h	/^      unsigned get_sp_op() const { return m_warp->sp_op; }$/;"	f	class:opndcoll_rfu_t::collector_unit_t
get_sp_op	shader.h	/^      unsigned get_sp_op() const$/;"	f	class:opndcoll_rfu_t::op_t
get_stall_addr	mem_fetch.h	/^   addr_t get_stall_addr() { return m_stall_at_addr; }$/;"	f	class:mem_fetch
get_stalled_uid	mem_fetch.h	/^   int get_stalled_uid() { return m_stalled_uid; }$/;"	f	class:mem_fetch
get_state	commit_unit.h	/^    enum commit_state get_state() const { return m_state; }$/;"	f	class:commit_entry
get_stats	gpu-cache.cc	/^unsigned cache_stats::get_stats(enum mem_access_type *access_type, unsigned num_access_type, enum cache_request_status *access_status, unsigned num_access_status) const{$/;"	f	class:cache_stats
get_stats	gpu-cache.cc	/^void tag_array::get_stats(unsigned &total_access, unsigned &total_misses, unsigned &total_hit_res, unsigned &total_res_fail) const{$/;"	f	class:tag_array
get_stats	gpu-cache.h	/^    const cache_stats &get_stats() const {$/;"	f	class:baseline_cache
get_stats	gpu-cache.h	/^    const cache_stats &get_stats() const {$/;"	f	class:tex_cache
get_stats	gpu-cache.h	/^    unsigned get_stats(enum mem_access_type *access_type, unsigned num_access_type, enum cache_request_status *access_status, unsigned num_access_status)  const{$/;"	f	class:baseline_cache
get_stats	gpu-cache.h	/^    unsigned get_stats(enum mem_access_type *access_type, unsigned num_access_type, enum cache_request_status *access_status, unsigned num_access_status) const{$/;"	f	class:tex_cache
get_stats_accesses	coherence_manager.h	/^    unsigned get_stats_accesses() { return m_stats_accesses; }$/;"	f	class:coherence_tag_array
get_stats_evictions	coherence_manager.h	/^    unsigned get_stats_evictions() { return m_stats_evictions; }$/;"	f	class:coherence_tag_array
get_stats_evictions_modified	coherence_manager.h	/^    unsigned get_stats_evictions_modified() { return m_stats_evictions_modified; }$/;"	f	class:coherence_tag_array
get_stats_evictions_shared	coherence_manager.h	/^    unsigned get_stats_evictions_shared() { return m_stats_evictions_shared; }$/;"	f	class:coherence_tag_array
get_stats_hits	coherence_manager.h	/^    unsigned get_stats_hits() { return m_stats_hits; }$/;"	f	class:coherence_tag_array
get_stats_invalidations	coherence_manager.h	/^    unsigned get_stats_invalidations() { return m_stats_invalidations; }$/;"	f	class:coherence_tag_array
get_stats_misses	coherence_manager.h	/^    unsigned get_stats_misses() { return m_stats_misses; }$/;"	f	class:coherence_tag_array
get_status	mem_fetch.h	/^   enum mem_fetch_status get_status() const { return m_status; }$/;"	f	class:mem_fetch
get_sub_partition	l2cache.h	/^   class memory_sub_partition * get_sub_partition(int sub_partition_id) $/;"	f	class:memory_partition_unit
get_sub_partition_id	mem_fetch.h	/^   unsigned get_sub_partition_id() const { return m_raw_addr.sub_partition; }$/;"	f	class:mem_fetch
get_sub_stats	gpu-cache.cc	/^void cache_stats::get_sub_stats(struct cache_sub_stats &css) const{$/;"	f	class:cache_stats
get_sub_stats	gpu-cache.h	/^    void get_sub_stats(struct cache_sub_stats &css) const {$/;"	f	class:baseline_cache
get_sub_stats	gpu-cache.h	/^    void get_sub_stats(struct cache_sub_stats &css) const{$/;"	f	class:tex_cache
get_tex_inst	power_stat.h	/^    unsigned get_tex_inst(){$/;"	f	class:power_stat_t
get_texture_c_accesses	power_stat.h	/^    unsigned get_texture_c_accesses(){$/;"	f	class:power_stat_t
get_texture_c_hits	power_stat.h	/^    unsigned get_texture_c_hits(){$/;"	f	class:power_stat_t
get_texture_c_misses	power_stat.h	/^    unsigned get_texture_c_misses(){$/;"	f	class:power_stat_t
get_thread_ctx	shader.cc	/^thread_ctx_t* shader_core_ctx::get_thread_ctx(unsigned tid) const $/;"	f	class:shader_core_ctx
get_timestamp	mem_fetch.h	/^   unsigned get_timestamp() const { return m_timestamp; }$/;"	f	class:mem_fetch
get_tlx_addr	mem_fetch.h	/^   const addrdec_t &get_tlx_addr() const { return m_raw_addr; }$/;"	f	class:mem_fetch
get_tm_manager	commit_unit.h	/^    class tm_manager_inf* get_tm_manager() { return m_tm_manager; }$/;"	f	class:commit_entry
get_tm_manager_ptr	mem_fetch.h	/^   class tm_manager_inf* get_tm_manager_ptr() { return m_tm_manager; }$/;"	f	class:mem_fetch
get_tm_uarch_model	shader.h	/^   unsigned get_tm_uarch_model() const { return m_config->tm_uarch_model; }$/;"	f	class:shader_core_ctx
get_tm_warp_info	shader.h	/^    const tm_warp_info& get_tm_warp_info() const { return m_tm_warp_info; }$/;"	f	class:shd_warp_t
get_tm_warp_info	shader.h	/^    tm_warp_info& get_tm_warp_info() { return m_tm_warp_info; }$/;"	f	class:shd_warp_t
get_tot_fpu_accessess	power_stat.h	/^    unsigned get_tot_fpu_accessess(){$/;"	f	class:power_stat_t
get_tot_sfu_accessess	power_stat.h	/^    unsigned get_tot_sfu_accessess(){$/;"	f	class:power_stat_t
get_total_fp_inst	power_stat.h	/^    unsigned get_total_fp_inst(){$/;"	f	class:power_stat_t
get_total_inst	power_stat.h	/^    unsigned get_total_inst(){$/;"	f	class:power_stat_t
get_total_int_inst	power_stat.h	/^    unsigned get_total_int_inst(){$/;"	f	class:power_stat_t
get_total_load_inst	power_stat.h	/^    unsigned get_total_load_inst(){$/;"	f	class:power_stat_t
get_total_store_inst	power_stat.h	/^    unsigned get_total_store_inst(){$/;"	f	class:power_stat_t
get_tpc	commit_unit.h	/^    int get_tpc() const { return m_tpc; }$/;"	f	class:commit_entry
get_tpc	mem_fetch.h	/^   unsigned get_tpc() const { return m_tpc; }$/;"	f	class:mem_fetch
get_trans_accessess	power_stat.h	/^    unsigned get_trans_accessess(){$/;"	f	class:power_stat_t
get_transaction_id	mem_fetch.h	/^   unsigned get_transaction_id() const { return m_transaction_id; }$/;"	f	class:mem_fetch
get_type	mem_fetch.h	/^   enum mf_type get_type() const { return m_type; }$/;"	f	class:mem_fetch
get_version	commit_unit.cc	/^int cu_access_set::get_version(new_addr_type addr) const$/;"	f	class:cu_access_set
get_warp_commit_entry	commit_unit.cc	/^warp_commit_entry & commit_unit::get_warp_commit_entry( int core_id, int warp_id )$/;"	f	class:commit_unit
get_warp_commit_entry_for_msg	commit_unit.cc	/^warp_commit_entry & commit_unit::get_warp_commit_entry_for_msg( mem_fetch *input_msg, unsigned time )$/;"	f	class:commit_unit
get_warp_ctp	shader.cc	/^tx_log_walker::warp_commit_tx_t* tx_log_walker::get_warp_ctp(int wid)$/;"	f	class:tx_log_walker
get_warp_id	shader.h	/^      unsigned get_warp_id() const { return m_warp_id; }$/;"	f	class:opndcoll_rfu_t::collector_unit_t
get_warp_id	shader.h	/^    unsigned get_warp_id() const { return m_warp_id; }$/;"	f	class:shd_warp_t
get_warp_slot_issue	shader.h	/^    const std::vector< std::vector<unsigned> >& get_warp_slot_issue() const$/;"	f	class:shader_core_stats
get_warps	shader.h	/^    std::vector<shd_warp_t>& get_warps() { return m_warp; }$/;"	f	class:shader_core_ctx
get_wid	commit_unit.h	/^    int get_wid() const { return m_wid; }$/;"	f	class:commit_entry
get_wid	commit_unit.h	/^   int get_wid() const { return m_wid; }$/;"	f	class:warp_commit_entry
get_wid	mem_fetch.h	/^   unsigned get_wid() const { return m_wid; }$/;"	f	class:mem_fetch
get_wid	shader.h	/^      unsigned get_wid() const$/;"	f	class:opndcoll_rfu_t::op_t
get_youngest_conflicting_commit_id	commit_unit.h	/^    int get_youngest_conflicting_commit_id() const { return m_youngest_conflicting_commit_id; }$/;"	f	class:commit_entry
global_scoreboard	scoreboard.cc	/^class global_scoreboard$/;"	c	file:
global_sub_partition_id_to_local_id	l2cache.cc	/^int memory_partition_unit::global_sub_partition_id_to_local_id(int global_sub_partition_id) const$/;"	f	class:memory_partition_unit
global_tm_token	scoreboard.cc	/^   typedef std::set<std::pair<unsigned, unsigned> > global_tm_token;$/;"	t	class:global_scoreboard	file:
gmem_skip_L1D	shader.h	/^    bool gmem_skip_L1D; \/\/ on = global memory access always skip the L1 cache $/;"	m	struct:shader_core_config
gpgpu_L2_queue_config	gpu-sim.h	/^   char *gpgpu_L2_queue_config;$/;"	m	struct:memory_config
gpgpu_cflog_interval	gpu-sim.h	/^    int   gpgpu_cflog_interval;$/;"	m	class:gpgpu_sim_config
gpgpu_clock_domains	gpu-sim.h	/^    char * gpgpu_clock_domains;$/;"	m	class:gpgpu_sim_config
gpgpu_clock_gated_lanes	shader.h	/^    bool gpgpu_clock_gated_lanes;$/;"	m	struct:shader_core_config
gpgpu_clock_gated_reg_file	shader.h	/^    bool gpgpu_clock_gated_reg_file;$/;"	m	struct:shader_core_config
gpgpu_dram_return_queue_size	gpu-sim.h	/^   unsigned gpgpu_dram_return_queue_size;$/;"	m	struct:memory_config
gpgpu_dram_timing_opt	gpu-sim.h	/^   char *gpgpu_dram_timing_opt;$/;"	m	struct:memory_config
gpgpu_dwf_reg_bankconflict	shader.h	/^    bool gpgpu_dwf_reg_bankconflict;$/;"	m	struct:shader_core_config
gpgpu_flush_l1_cache	gpu-sim.h	/^    bool  gpgpu_flush_l1_cache;$/;"	m	class:gpgpu_sim_config
gpgpu_flush_l2_cache	gpu-sim.h	/^    bool  gpgpu_flush_l2_cache;$/;"	m	class:gpgpu_sim_config
gpgpu_frfcfs_dram_sched_queue_size	gpu-sim.h	/^    int   gpgpu_frfcfs_dram_sched_queue_size; $/;"	m	class:gpgpu_sim_config
gpgpu_frfcfs_dram_sched_queue_size	gpu-sim.h	/^   unsigned gpgpu_frfcfs_dram_sched_queue_size;$/;"	m	struct:memory_config
gpgpu_global_hw_thread_idle_cycles	shader.h	/^    unsigned long long gpgpu_global_hw_thread_idle_cycles;$/;"	m	struct:shader_core_stats_pod
gpgpu_global_thread_state_atomic	shader.h	/^    thread_state_stat* gpgpu_global_thread_state_atomic;$/;"	m	struct:shader_core_stats_pod
gpgpu_global_thread_state_nonatomic	shader.h	/^    thread_state_stat* gpgpu_global_thread_state_nonatomic;$/;"	m	struct:shader_core_stats_pod
gpgpu_global_thread_state_tx_aborted	shader.h	/^    thread_state_stat* gpgpu_global_thread_state_tx_aborted;$/;"	m	struct:shader_core_stats_pod
gpgpu_global_thread_state_tx_useful	shader.h	/^    thread_state_stat* gpgpu_global_thread_state_tx_useful;$/;"	m	struct:shader_core_stats_pod
gpgpu_global_threads	shader.h	/^    unsigned gpgpu_global_threads;$/;"	m	struct:shader_core_stats_pod
gpgpu_local_mem_map	shader.h	/^    bool gpgpu_local_mem_map;$/;"	m	struct:shader_core_config
gpgpu_max_insn_issue_per_warp	shader.h	/^    int gpgpu_max_insn_issue_per_warp;$/;"	m	struct:shader_core_config
gpgpu_mem_address_mask	addrdec.h	/^   int gpgpu_mem_address_mask;$/;"	m	class:linear_to_raw_address_translation
gpgpu_memlatency_stat	gpu-sim.h	/^   bool gpgpu_memlatency_stat;$/;"	m	struct:memory_config
gpgpu_n_cache_bkconflict	shader.h	/^    unsigned gpgpu_n_cache_bkconflict;$/;"	m	struct:shader_core_stats_pod
gpgpu_n_cmem_portconflict	shader.h	/^    unsigned gpgpu_n_cmem_portconflict;$/;"	m	struct:shader_core_stats_pod
gpgpu_n_const_insn	shader.h	/^    unsigned gpgpu_n_const_insn;$/;"	m	struct:shader_core_stats_pod
gpgpu_n_cycle_shd_inactive	shader.h	/^    unsigned gpgpu_n_cycle_shd_inactive;$/;"	m	struct:shader_core_stats_pod
gpgpu_n_intrawarp_mshr_merge	shader.h	/^    int      gpgpu_n_intrawarp_mshr_merge;$/;"	m	struct:shader_core_stats_pod
gpgpu_n_load_insn	shader.h	/^    unsigned gpgpu_n_load_insn;$/;"	m	struct:shader_core_stats_pod
gpgpu_n_mem_const	shader.h	/^    int gpgpu_n_mem_const;$/;"	m	struct:shader_core_stats_pod
gpgpu_n_mem_l2_write_allocate	shader.h	/^    int gpgpu_n_mem_l2_write_allocate;$/;"	m	struct:shader_core_stats_pod
gpgpu_n_mem_l2_writeback	shader.h	/^    int gpgpu_n_mem_l2_writeback;$/;"	m	struct:shader_core_stats_pod
gpgpu_n_mem_read_global	shader.h	/^    int gpgpu_n_mem_read_global;$/;"	m	struct:shader_core_stats_pod
gpgpu_n_mem_read_inst	shader.h	/^    int gpgpu_n_mem_read_inst;$/;"	m	struct:shader_core_stats_pod
gpgpu_n_mem_read_local	shader.h	/^    int gpgpu_n_mem_read_local;$/;"	m	struct:shader_core_stats_pod
gpgpu_n_mem_texture	shader.h	/^    int gpgpu_n_mem_texture;$/;"	m	struct:shader_core_stats_pod
gpgpu_n_mem_write_global	shader.h	/^    int gpgpu_n_mem_write_global;$/;"	m	struct:shader_core_stats_pod
gpgpu_n_mem_write_local	shader.h	/^    int gpgpu_n_mem_write_local;$/;"	m	struct:shader_core_stats_pod
gpgpu_n_param_insn	shader.h	/^    unsigned gpgpu_n_param_insn;$/;"	m	struct:shader_core_stats_pod
gpgpu_n_shmem_bank_access	shader.h	/^    unsigned *gpgpu_n_shmem_bank_access;$/;"	m	struct:shader_core_stats_pod
gpgpu_n_shmem_bkconflict	shader.h	/^    unsigned gpgpu_n_shmem_bkconflict;$/;"	m	struct:shader_core_stats_pod
gpgpu_n_shmem_insn	shader.h	/^    unsigned gpgpu_n_shmem_insn;$/;"	m	struct:shader_core_stats_pod
gpgpu_n_stall_shd_mem	shader.h	/^    unsigned gpgpu_n_stall_shd_mem;$/;"	m	struct:shader_core_stats_pod
gpgpu_n_store_insn	shader.h	/^    unsigned gpgpu_n_store_insn;$/;"	m	struct:shader_core_stats_pod
gpgpu_n_tex_insn	shader.h	/^    unsigned gpgpu_n_tex_insn;$/;"	m	struct:shader_core_stats_pod
gpgpu_n_tx_msg	shader.h	/^    int gpgpu_n_tx_msg; $/;"	m	struct:shader_core_stats_pod
gpgpu_num_mem_units	shader.h	/^    int gpgpu_num_mem_units;$/;"	m	struct:shader_core_config
gpgpu_num_reg_banks	shader.h	/^    unsigned gpgpu_num_reg_banks;$/;"	m	struct:shader_core_config
gpgpu_num_sched_per_core	shader.h	/^    int gpgpu_num_sched_per_core;$/;"	m	struct:shader_core_config
gpgpu_num_sfu_units	shader.h	/^    int gpgpu_num_sfu_units;$/;"	m	struct:shader_core_config
gpgpu_num_sp_units	shader.h	/^    int gpgpu_num_sp_units;$/;"	m	struct:shader_core_config
gpgpu_operand_collector_num_in_ports_gen	shader.h	/^    unsigned int gpgpu_operand_collector_num_in_ports_gen;$/;"	m	struct:shader_core_config
gpgpu_operand_collector_num_in_ports_mem	shader.h	/^    unsigned int gpgpu_operand_collector_num_in_ports_mem;$/;"	m	struct:shader_core_config
gpgpu_operand_collector_num_in_ports_sfu	shader.h	/^    unsigned int gpgpu_operand_collector_num_in_ports_sfu;$/;"	m	struct:shader_core_config
gpgpu_operand_collector_num_in_ports_sp	shader.h	/^    unsigned int gpgpu_operand_collector_num_in_ports_sp;$/;"	m	struct:shader_core_config
gpgpu_operand_collector_num_out_ports_gen	shader.h	/^    unsigned int gpgpu_operand_collector_num_out_ports_gen;$/;"	m	struct:shader_core_config
gpgpu_operand_collector_num_out_ports_mem	shader.h	/^    unsigned int gpgpu_operand_collector_num_out_ports_mem;$/;"	m	struct:shader_core_config
gpgpu_operand_collector_num_out_ports_sfu	shader.h	/^    unsigned int gpgpu_operand_collector_num_out_ports_sfu;$/;"	m	struct:shader_core_config
gpgpu_operand_collector_num_out_ports_sp	shader.h	/^    unsigned int gpgpu_operand_collector_num_out_ports_sp;$/;"	m	struct:shader_core_config
gpgpu_operand_collector_num_units_gen	shader.h	/^    int gpgpu_operand_collector_num_units_gen;$/;"	m	struct:shader_core_config
gpgpu_operand_collector_num_units_mem	shader.h	/^    int gpgpu_operand_collector_num_units_mem;$/;"	m	struct:shader_core_config
gpgpu_operand_collector_num_units_sfu	shader.h	/^    int gpgpu_operand_collector_num_units_sfu;$/;"	m	struct:shader_core_config
gpgpu_operand_collector_num_units_sp	shader.h	/^    int gpgpu_operand_collector_num_units_sp;$/;"	m	struct:shader_core_config
gpgpu_perfect_mem	shader.h	/^    bool gpgpu_perfect_mem;$/;"	m	struct:shader_core_config
gpgpu_reg_bank_use_warp_id	shader.h	/^    bool gpgpu_reg_bank_use_warp_id;$/;"	m	struct:shader_core_config
gpgpu_runtime_stat	gpu-sim.h	/^    char *gpgpu_runtime_stat;$/;"	m	class:gpgpu_sim_config
gpgpu_scheduler_string	shader.h	/^    char * gpgpu_scheduler_string;$/;"	m	struct:shader_core_config
gpgpu_shader_core_pipeline_opt	shader.h	/^    char *gpgpu_shader_core_pipeline_opt;$/;"	m	struct:shader_core_config
gpgpu_shader_registers	shader.h	/^    unsigned gpgpu_shader_registers;$/;"	m	struct:shader_core_config
gpgpu_sim	gpu-sim.cc	/^gpgpu_sim::gpgpu_sim( const gpgpu_sim_config &config ) $/;"	f	class:gpgpu_sim
gpgpu_sim	gpu-sim.h	/^class gpgpu_sim : public gpgpu_t {$/;"	c
gpgpu_sim_config	gpu-sim.h	/^    gpgpu_sim_config() { m_valid = false; }$/;"	f	class:gpgpu_sim_config
gpgpu_sim_config	gpu-sim.h	/^class gpgpu_sim_config : public power_config, public gpgpu_functional_sim_config {$/;"	c
gpgpu_sim_wrapper	gpu-sim.cc	/^class  gpgpu_sim_wrapper {};$/;"	c	file:
gpgpu_warp_issue_shader	shader.h	/^    int gpgpu_warp_issue_shader;$/;"	m	struct:shader_core_config
gpgpu_warpdistro_shader	shader.h	/^    int gpgpu_warpdistro_shader;$/;"	m	struct:shader_core_config
gpu_deadlock	gpu-sim.h	/^   bool gpu_deadlock;$/;"	m	class:gpgpu_sim
gpu_deadlock_detect	gpu-sim.h	/^    bool  gpu_deadlock_detect;$/;"	m	class:gpgpu_sim_config
gpu_idle_core_power	gpu-sim.h	/^    double gpu_idle_core_power;$/;"	m	struct:power_config
gpu_max_cta_opt	gpu-sim.h	/^    unsigned gpu_max_cta_opt;$/;"	m	class:gpgpu_sim_config
gpu_max_cycle_opt	gpu-sim.h	/^    unsigned gpu_max_cycle_opt;$/;"	m	class:gpgpu_sim_config
gpu_max_insn_opt	gpu-sim.h	/^    unsigned gpu_max_insn_opt;$/;"	m	class:gpgpu_sim_config
gpu_min_inc_per_active_sm	gpu-sim.h	/^    double gpu_min_inc_per_active_sm;$/;"	m	struct:power_config
gpu_n_mem_per_ctrlr	gpu-sim.h	/^   unsigned gpu_n_mem_per_ctrlr;$/;"	m	struct:memory_config
gpu_nonlinear_model_config	gpu-sim.h	/^    char * gpu_nonlinear_model_config;$/;"	m	struct:power_config
gpu_print_stat	gpu-sim.cc	/^void gpgpu_sim::gpu_print_stat() $/;"	f	class:gpgpu_sim
gpu_reg_bank_conflict_stalls	shader.h	/^    unsigned gpu_reg_bank_conflict_stalls;$/;"	m	struct:shader_core_stats_pod
gpu_runtime_stat_flag	gpu-sim.h	/^    int gpu_runtime_stat_flag;$/;"	m	class:gpgpu_sim_config
gpu_sim_cycle	gpu-sim.cc	/^unsigned long long  gpu_sim_cycle = 0;$/;"	v
gpu_sim_insn	gpu-sim.h	/^   unsigned long long  gpu_sim_insn;$/;"	m	class:gpgpu_sim
gpu_sim_insn_last_update	gpu-sim.h	/^   unsigned long long  gpu_sim_insn_last_update;$/;"	m	class:gpgpu_sim
gpu_sim_insn_last_update_sid	gpu-sim.h	/^   unsigned gpu_sim_insn_last_update_sid;$/;"	m	class:gpgpu_sim
gpu_stall_dramfull	gpu-sim.cc	/^unsigned int gpu_stall_dramfull = 0; $/;"	v
gpu_stall_icnt2sh	gpu-sim.cc	/^unsigned int gpu_stall_icnt2sh = 0;$/;"	v
gpu_stall_shd_mem_breakdown	shader.h	/^    unsigned gpu_stall_shd_mem_breakdown[N_MEM_STAGE_ACCESS_TYPE][N_MEM_STAGE_STALL_TYPE];$/;"	m	struct:shader_core_stats_pod
gpu_stat_sample_freq	gpu-sim.h	/^    int gpu_stat_sample_freq;$/;"	m	class:gpgpu_sim_config
gpu_steady_min_period	gpu-sim.h	/^    double gpu_steady_min_period;$/;"	m	struct:power_config
gpu_steady_power_deviation	gpu-sim.h	/^    double gpu_steady_power_deviation;$/;"	m	struct:power_config
gpu_steady_state_definition	gpu-sim.h	/^    char * gpu_steady_state_definition;$/;"	m	struct:power_config
gpu_tot_issued_cta	gpu-sim.h	/^   unsigned long long  gpu_tot_issued_cta;$/;"	m	class:gpgpu_sim
gpu_tot_sim_cycle	gpu-sim.cc	/^unsigned long long  gpu_tot_sim_cycle = 0;$/;"	v
gpu_tot_sim_insn	gpu-sim.h	/^   unsigned long long  gpu_tot_sim_insn;$/;"	m	class:gpgpu_sim
gs_min2	gpu-misc.h	38;"	d
gto_scheduler	shader.h	/^	gto_scheduler ( shader_core_stats* stats, shader_core_ctx* shader,$/;"	f	class:gto_scheduler
gto_scheduler	shader.h	/^class gto_scheduler : public scheduler_unit {$/;"	c
hardware_done	shader.cc	/^bool shd_warp_t::hardware_done() const$/;"	f	class:shd_warp_t
has	shader.cc	/^bool tx_log_walker::warp_commit_tx_t::has(const warp_inst_t &inst) $/;"	f	class:tx_log_walker::warp_commit_tx_t
has_coalesced_ops	commit_unit.h	/^       bool has_coalesced_ops() const { return (not m_coalesced_ops.empty()); }$/;"	f	class:commit_unit::cu_mem_acc
has_coalesced_packet	mem_fetch.cc	/^bool mem_fetch::has_coalesced_packet() const$/;"	f	class:mem_fetch
has_credits	l2cache.cc	/^bool memory_partition_unit::arbitration_metadata::has_credits(int inner_sub_partition_id) const $/;"	f	class:memory_partition_unit::arbitration_metadata
has_free_token	scoreboard.cc	/^bool global_scoreboard::has_free_token() const $/;"	f	class:global_scoreboard
has_io_pending	shader.cc	/^bool simt_core_cluster::has_io_pending() const $/;"	f	class:simt_core_cluster
has_message_pending	shader.cc	/^bool ldst_unit::has_message_pending() const $/;"	f	class:ldst_unit
has_message_pending	shader.h	/^    bool has_message_pending() const { return m_ldst_unit->has_message_pending(); }$/;"	f	class:shader_core_ctx
has_out_message	shader.cc	/^bool tx_log_walker::has_out_message() const  $/;"	f	class:tx_log_walker
has_special_cache_config	gpu-sim.cc	/^bool gpgpu_sim::has_special_cache_config(std::string kernel_name)$/;"	f	class:gpgpu_sim
has_token	scoreboard.cc	/^bool global_scoreboard::has_token(unsigned sid, unsigned wid) const $/;"	f	class:global_scoreboard
hash_addrdec_t	addrdec.cc	/^class hash_addrdec_t$/;"	c	file:
hash_address	shader.cc	/^   addr_t hash_address(addr_t address_tag, addr_t odd_hash_multiple) const $/;"	f	class:ownership_table
hash_address_prime	shader.cc	/^   addr_t hash_address_prime(addr_t address_tag) const $/;"	f	class:ownership_table
hash_address_second	shader.cc	/^   addr_t hash_address_second(addr_t address_tag) const $/;"	f	class:ownership_table
hazard_detection_reads_done	commit_unit.cc	/^bool warp_commit_entry::hazard_detection_reads_done() const$/;"	f	class:warp_commit_entry
hazard_detection_writes_done	commit_unit.cc	/^bool warp_commit_entry::hazard_detection_writes_done() const $/;"	f	class:warp_commit_entry
history_file_commit_clear	shader.cc	/^void opndcoll_rfu_t::history_file_commit_clear()$/;"	f	class:opndcoll_rfu_t
history_file_enabled	shader.cc	/^bool opndcoll_rfu_t::history_file_enabled() const $/;"	f	class:opndcoll_rfu_t
history_file_rollback	shader.cc	/^bool opndcoll_rfu_t::history_file_rollback( )$/;"	f	class:opndcoll_rfu_t
history_file_start_rollback	shader.cc	/^void opndcoll_rfu_t::history_file_start_rollback()$/;"	f	class:opndcoll_rfu_t
history_file_t	shader.h	/^   history_file_t() $/;"	f	class:history_file_t
history_file_t	shader.h	/^class history_file_t {$/;"	c
hw_tid_from_wid	shader.h	/^inline unsigned hw_tid_from_wid(unsigned wid, unsigned warp_size, unsigned i){return wid * warp_size + i;};$/;"	f
ibuffer_empty	shader.h	/^    bool ibuffer_empty() const$/;"	f	class:shd_warp_t
ibuffer_entry	shader.h	/^       ibuffer_entry() { m_valid = false; m_inst = NULL; }$/;"	f	struct:shd_warp_t::ibuffer_entry
ibuffer_entry	shader.h	/^    struct ibuffer_entry {$/;"	s	class:shd_warp_t
ibuffer_fill	shader.h	/^    void ibuffer_fill( unsigned slot, const warp_inst_t *pI )$/;"	f	class:shd_warp_t
ibuffer_flush	shader.h	/^    void ibuffer_flush()$/;"	f	class:shd_warp_t
ibuffer_free	shader.h	/^    void ibuffer_free()$/;"	f	class:shd_warp_t
ibuffer_is_txbegin	shader.h	/^    bool ibuffer_is_txbegin() const$/;"	f	class:shd_warp_t
ibuffer_next_inst	shader.h	/^    const warp_inst_t *ibuffer_next_inst() { return m_ibuffer[m_next].m_inst; }$/;"	f	class:shd_warp_t
ibuffer_next_valid	shader.h	/^    bool ibuffer_next_valid() { return m_ibuffer[m_next].m_valid; }$/;"	f	class:shd_warp_t
ibuffer_step	shader.h	/^    void ibuffer_step() { m_next = (m_next+1)%IBUFFER_SIZE; }$/;"	f	class:shd_warp_t
icnt2mem_lat_table	mem_latency_stat.h	/^   unsigned icnt2mem_lat_table[24];$/;"	m	class:memory_stats_t
icnt2sh_lat_table	mem_latency_stat.h	/^   unsigned icnt2sh_lat_table[24];$/;"	m	class:memory_stats_t
icnt_busy	icnt_wrapper.cc	/^icnt_busy_p       icnt_busy;$/;"	v
icnt_busy_p	icnt_wrapper.h	/^typedef unsigned (*icnt_busy_p)( );$/;"	t
icnt_cycle	shader.cc	/^void simt_core_cluster::icnt_cycle()$/;"	f	class:simt_core_cluster
icnt_drain_p	icnt_wrapper.h	/^typedef void (*icnt_drain_p)( );$/;"	t
icnt_flit_size	gpu-sim.h	/^   unsigned icnt_flit_size;$/;"	m	struct:memory_config
icnt_flit_size	mem_fetch.h	/^   unsigned icnt_flit_size;$/;"	m	class:mem_fetch
icnt_freq	gpu-sim.h	/^    double icnt_freq;$/;"	m	class:gpgpu_sim_config
icnt_get_flit_size	icnt_wrapper.cc	/^icnt_get_flit_size_p icnt_get_flit_size;$/;"	v
icnt_get_flit_size_p	icnt_wrapper.h	/^typedef unsigned (*icnt_get_flit_size_p)();$/;"	t
icnt_has_buffer	icnt_wrapper.cc	/^icnt_has_buffer_p icnt_has_buffer;$/;"	v
icnt_has_buffer_p	icnt_wrapper.h	/^typedef bool (*icnt_has_buffer_p)(unsigned input, unsigned int size);$/;"	t
icnt_init	icnt_wrapper.cc	/^void icnt_init( unsigned int n_shader, unsigned int n_mem )$/;"	f
icnt_inject_request_packet	shader.cc	/^void simt_core_cluster::icnt_inject_request_packet(class mem_fetch *mf)$/;"	f	class:simt_core_cluster
icnt_injection_buffer_full	shader.cc	/^bool simt_core_cluster::icnt_injection_buffer_full(unsigned size, bool write)$/;"	f	class:simt_core_cluster
icnt_period	gpu-sim.h	/^    double icnt_period;$/;"	m	class:gpgpu_sim_config
icnt_pop	icnt_wrapper.cc	/^icnt_pop_p        icnt_pop;$/;"	v
icnt_pop_p	icnt_wrapper.h	/^typedef void* (*icnt_pop_p)(unsigned output);$/;"	t
icnt_push	icnt_wrapper.cc	/^icnt_push_p       icnt_push;$/;"	v
icnt_push_p	icnt_wrapper.h	/^typedef void (*icnt_push_p)(unsigned input, unsigned output, void* data, unsigned int size);$/;"	t
icnt_reg_options	icnt_wrapper.cc	/^void icnt_reg_options( class OptionParser * opp )$/;"	f
icnt_time	gpu-sim.h	/^   double icnt_time;$/;"	m	class:gpgpu_sim
icnt_transfer	icnt_wrapper.cc	/^icnt_transfer_p   icnt_transfer;$/;"	v
icnt_transfer_p	icnt_wrapper.h	/^typedef void (*icnt_transfer_p)( );$/;"	t
id	dram.h	/^   unsigned int id;$/;"	m	class:dram_t
ideal_L2_cache	commit_unit.cc	/^bool commit_unit::ideal_L2_cache(enum cu_mem_op mem_op)$/;"	f	class:commit_unit
ifetch_buffer_t	shader.h	/^    ifetch_buffer_t( address_type pc, unsigned nbytes, unsigned warp_id ) $/;"	f	struct:ifetch_buffer_t
ifetch_buffer_t	shader.h	/^    ifetch_buffer_t() { m_valid=false; }$/;"	f	struct:ifetch_buffer_t
ifetch_buffer_t	shader.h	/^struct ifetch_buffer_t {$/;"	s
imiss_pending	shader.h	/^    bool imiss_pending() const { return m_imiss_pending; }$/;"	f	class:shd_warp_t
inTxCommit	scoreboard.cc	/^bool Scoreboard::inTxCommit(unsigned warp_id) const$/;"	f	class:Scoreboard
inTxRestart	scoreboard.cc	/^bool Scoreboard::inTxRestart(unsigned warp_id) const$/;"	f	class:Scoreboard
in_rollback	shader.cc	/^bool opndcoll_rfu_t::in_rollback() const $/;"	f	class:opndcoll_rfu_t
in_rollback	shader.h	/^   bool in_rollback() const { return m_in_rollback; }$/;"	f	class:history_file_t
in_sending_state	shader.h	/^      bool in_sending_state() {$/;"	f	struct:tx_log_walker::commit_tx_t
inactive_lanes_accesses_nonsfu	shader.h	/^	 unsigned inactive_lanes_accesses_nonsfu(unsigned active_count,double latency){$/;"	f	class:shader_core_ctx
inactive_lanes_accesses_sfu	shader.h	/^	 unsigned inactive_lanes_accesses_sfu(unsigned active_count,double latency){$/;"	f	class:shader_core_ctx
inc_head	gpu-cache.h	/^        void inc_head() { m_head = (m_head+1)%m_size; m_num++;}$/;"	f	class:tex_cache::fifo
inc_inst_in_pipeline	shader.h	/^    void inc_inst_in_pipeline() { m_inst_in_pipeline++; }$/;"	f	class:shd_warp_t
inc_local_write_misses	gpu-cache.cc	/^void cache_stats::inc_local_write_misses(bool full_cacheline)$/;"	f	class:cache_stats
inc_n_atomic	shader.h	/^    void inc_n_atomic() { m_n_atomic++; }$/;"	f	class:shd_warp_t
inc_n_logical_tm_req	shader.h	/^    void inc_n_logical_tm_req() { m_n_logical_tm_req++; }$/;"	f	class:shd_warp_t
inc_n_logical_tm_req_per_thread	shader.h	/^    void inc_n_logical_tm_req_per_thread(unsigned tid) { m_n_logical_tm_req_per_thread[tid]++; }$/;"	f	class:shd_warp_t
inc_set_utility	gpu-cache.cc	/^void cache_stats::inc_set_utility(unsigned set_idx, enum cache_request_status access_status)$/;"	f	class:cache_stats
inc_simt_to_mem	shader.h	/^	 void inc_simt_to_mem(unsigned n_flits){ m_stats->n_simt_to_mem[m_sid] += n_flits; }$/;"	f	class:shader_core_ctx
inc_stats	gpu-cache.cc	/^void cache_stats::inc_stats(int access_type, int access_outcome){$/;"	f	class:cache_stats
inc_store_req	shader.h	/^    void inc_store_req( unsigned warp_id) { m_warp[warp_id].inc_store_req(); }$/;"	f	class:shader_core_ctx
inc_store_req	shader.h	/^    void inc_store_req() { m_stores_outstanding++; }$/;"	f	class:shd_warp_t
inc_tail	gpu-cache.h	/^        void inc_tail() { assert(m_num>0); m_tail = (m_tail+1)%m_size; m_num--;}$/;"	f	class:tex_cache::fifo
incexecstat	shader.cc	/^void shader_core_ctx::incexecstat(warp_inst_t *&inst)$/;"	f	class:shader_core_ctx
incfpalu_stat	shader.h	/^	 void incfpalu_stat(unsigned active_count,double latency) {$/;"	f	class:shader_core_ctx
incfpdiv_stat	shader.h	/^	 void incfpdiv_stat(unsigned active_count,double latency) {$/;"	f	class:shader_core_ctx
incfpmul_stat	shader.h	/^	 void incfpmul_stat(unsigned active_count,double latency) {$/;"	f	class:shader_core_ctx
incfuactivelanes_stat	shader.h	/^	 void incfuactivelanes_stat(unsigned active_count) {m_stats->m_active_fu_lanes[m_sid]=m_stats->m_active_fu_lanes[m_sid]+active_count;}$/;"	f	class:shader_core_ctx
incfumemactivelanes_stat	shader.h	/^	 void incfumemactivelanes_stat(unsigned active_count) {m_stats->m_active_fu_mem_lanes[m_sid]=m_stats->m_active_fu_mem_lanes[m_sid]+active_count;}$/;"	f	class:shader_core_ctx
incialu_stat	shader.h	/^    void incialu_stat(unsigned active_count,double latency) {$/;"	f	class:shader_core_ctx
incidiv_stat	shader.h	/^	 void incidiv_stat(unsigned active_count,double latency) {$/;"	f	class:shader_core_ctx
incimul24_stat	shader.h	/^    void incimul24_stat(unsigned active_count,double latency) {$/;"	f	class:shader_core_ctx
incimul32_stat	shader.h	/^	 void incimul32_stat(unsigned active_count,double latency) {$/;"	f	class:shader_core_ctx
incimul_stat	shader.h	/^    void incimul_stat(unsigned active_count,double latency) {$/;"	f	class:shader_core_ctx
incload_stat	shader.h	/^    void incload_stat() {m_stats->m_num_loadqueued_insn[m_sid]++;}$/;"	f	class:shader_core_ctx
incmem_stat	shader.h	/^	 void incmem_stat(unsigned active_count,double latency) {$/;"	f	class:shader_core_ctx
incnon_rf_operands	shader.h	/^	 void incnon_rf_operands(unsigned active_count){m_stats->m_non_rf_operands[m_sid]=m_stats->m_non_rf_operands[m_sid]+active_count;}$/;"	f	class:shader_core_ctx
incregfile_reads	shader.h	/^	 void incregfile_reads(unsigned active_count) {m_stats->m_read_regfile_acesses[m_sid]=m_stats->m_read_regfile_acesses[m_sid]+active_count;}$/;"	f	class:shader_core_ctx
incregfile_writes	shader.h	/^	 void incregfile_writes(unsigned active_count){m_stats->m_write_regfile_acesses[m_sid]=m_stats->m_write_regfile_acesses[m_sid]+active_count;}$/;"	f	class:shader_core_ctx
increment_x_then_y_then_z	gpu-sim.cc	/^void increment_x_then_y_then_z( dim3 &i, const dim3 &bound)$/;"	f
incsfu_stat	shader.h	/^	 void incsfu_stat(unsigned active_count,double latency) {m_stats->m_num_sfu_acesses[m_sid]=m_stats->m_num_sfu_acesses[m_sid]+active_count*latency;}$/;"	f	class:shader_core_ctx
incsfuactivelanes_stat	shader.h	/^	 void incsfuactivelanes_stat(unsigned active_count) {m_stats->m_active_sfu_lanes[m_sid]=m_stats->m_active_sfu_lanes[m_sid]+active_count;}$/;"	f	class:shader_core_ctx
incsp_stat	shader.h	/^	 void incsp_stat(unsigned active_count,double latency) {m_stats->m_num_sp_acesses[m_sid]=m_stats->m_num_sp_acesses[m_sid]+active_count*latency;}$/;"	f	class:shader_core_ctx
incspactivelanes_stat	shader.h	/^	 void incspactivelanes_stat(unsigned active_count) {m_stats->m_active_sp_lanes[m_sid]=m_stats->m_active_sp_lanes[m_sid]+active_count;}$/;"	f	class:shader_core_ctx
incstore_stat	shader.h	/^    void incstore_stat() {m_stats->m_num_storequeued_insn[m_sid]++;}$/;"	f	class:shader_core_ctx
inctex_stat	shader.h	/^    void inctex_stat(unsigned active_count,double latency){$/;"	f	class:shader_core_ctx
inctrans_stat	shader.h	/^	 void inctrans_stat(unsigned active_count,double latency) {$/;"	f	class:shader_core_ctx
infinite	shader.cc	/^   bool infinite() const { return (m_table.size() == 0); }$/;"	f	class:ownership_table
init	addrdec.cc	/^void linear_to_raw_address_translation::init(unsigned int n_channel, unsigned int n_sub_partition_in_channel) $/;"	f	class:linear_to_raw_address_translation
init	gpu-cache.cc	/^void cache_config::init(char * config, FuncCache status)$/;"	f	class:cache_config
init	gpu-cache.cc	/^void l2_cache_config::init(linear_to_raw_address_translation *address_mapping){$/;"	f	class:l2_cache_config
init	gpu-cache.cc	/^void tag_array::init( int core_id, int type_id )$/;"	f	class:tag_array
init	gpu-cache.h	/^    virtual void init( mem_fetch_allocator *mfcreator )$/;"	f	class:data_cache
init	gpu-cache.h	/^    void init( const char *name,$/;"	f	class:baseline_cache
init	gpu-sim.cc	/^void gpgpu_sim::init()$/;"	f	class:gpgpu_sim
init	gpu-sim.h	/^	void init()$/;"	f	struct:power_config
init	gpu-sim.h	/^    void init() $/;"	f	class:gpgpu_sim_config
init	gpu-sim.h	/^   void init()$/;"	f	struct:memory_config
init	power_stat.cc	/^void power_core_stat_t::init()$/;"	f	class:power_core_stat_t
init	power_stat.cc	/^void power_mem_stat_t::init(){$/;"	f	class:power_mem_stat_t
init	shader.cc	/^void history_file_t::init( unsigned num_banks ) $/;"	f	class:history_file_t
init	shader.cc	/^void ldst_unit::init( mem_fetch_interface *&icnt,$/;"	f	class:ldst_unit
init	shader.cc	/^void opndcoll_rfu_t::collector_unit_t::init( unsigned n, $/;"	f	class:opndcoll_rfu_t::collector_unit_t
init	shader.cc	/^void opndcoll_rfu_t::init( unsigned num_banks, shader_core_ctx *shader )$/;"	f	class:opndcoll_rfu_t
init	shader.cc	/^void tx_log_walker::warp_commit_tx_t::init(const warp_inst_t &inst) $/;"	f	class:tx_log_walker::warp_commit_tx_t
init	shader.h	/^      void init( unsigned num_cu, unsigned num_banks ) $/;"	f	class:opndcoll_rfu_t::arbiter_t
init	shader.h	/^    void init( address_type start_pc,$/;"	f	class:shd_warp_t
init	shader.h	/^    void init()$/;"	f	struct:shader_core_config
init_aborted_tx_pts	shader.cc	/^void shader_core_ctx::init_aborted_tx_pts(unsigned wid) {$/;"	f	class:shader_core_ctx
init_clock_domains	gpu-sim.cc	/^void gpgpu_sim_config::init_clock_domains(void ) $/;"	f	class:gpgpu_sim_config
init_mcpat	power_interface.cc	/^void init_mcpat(const gpgpu_sim_config &config, class gpgpu_sim_wrapper *wrapper, unsigned stat_sample_freq, unsigned tot_inst, unsigned inst){$/;"	f
init_warps	shader.cc	/^void shader_core_ctx::init_warps( unsigned cta_id, unsigned start_thread, unsigned end_thread )$/;"	f	class:shader_core_ctx
initiate_timing_model_transaction_commit	shader.cc	/^void shader_core_ctx::initiate_timing_model_transaction_commit( unsigned warp_id )$/;"	f	class:shader_core_ctx
input_port_t	shader.h	/^       input_port_t(port_vector_t & input, port_vector_t & output, uint_vector_t cu_sets)$/;"	f	class:opndcoll_rfu_t::input_port_t
input_port_t	shader.h	/^   class input_port_t {$/;"	c	class:opndcoll_rfu_t
insertion_time	dram.h	/^   unsigned int insertion_time;$/;"	m	class:dram_req_t
insn_latency_info	shader.h	/^struct insn_latency_info {$/;"	s
insn_warp_occ_create	stat-tool.cc	/^void insn_warp_occ_create( int n_loggers, int simd_width )$/;"	f
insn_warp_occ_log	stat-tool.cc	/^void insn_warp_occ_log( int logger_id, address_type pc, int warp_occ)$/;"	f
insn_warp_occ_logger	stat-tool.h	/^   insn_warp_occ_logger(const insn_warp_occ_logger& other)$/;"	f	class:insn_warp_occ_logger
insn_warp_occ_logger	stat-tool.h	/^   insn_warp_occ_logger(int simd_width)$/;"	f	class:insn_warp_occ_logger
insn_warp_occ_logger	stat-tool.h	/^class insn_warp_occ_logger {$/;"	c
insn_warp_occ_print	stat-tool.cc	/^void insn_warp_occ_print( FILE *fout )$/;"	f
inst_in_pipeline	shader.h	/^    bool inst_in_pipeline() const { return m_inst_in_pipeline > 0; }$/;"	f	class:shd_warp_t
intra_warp_cd_cycle	shader.cc	/^bool tx_log_walker_warpc::intra_warp_cd_cycle(int wid, warp_commit_tx_t &cmt_warp)$/;"	f	class:tx_log_walker_warpc
intra_warp_cd_detail_cycle	shader.cc	/^bool tx_log_walker_warpc::intra_warp_cd_detail_cycle(int wid, warp_commit_tx_t &cmt_warp)$/;"	f	class:tx_log_walker_warpc
intra_warp_conflict_detection	shader.cc	/^void tx_log_walker::intra_warp_conflict_detection(warp_inst_t &inst, iwcd_uarch_info &uarch_activity) $/;"	f	class:tx_log_walker
invalidate	coherence_manager.cc	/^void coherence_tag_array::invalidate(new_addr_type block_addr) {$/;"	f	class:coherence_tag_array
invalidate	coherence_manager.h	/^    void invalidate()$/;"	f	struct:coherence_cache_block_t
invalidate	gpu-cache.h	/^    void invalidate()$/;"	f	struct:cache_block_t
is_aborted	mem_fetch.h	/^   bool is_aborted() const { return m_is_aborted; }$/;"	f	class:mem_fetch
is_allocated	coherence_manager.h	/^    bool is_allocated() { return m_allocated; }$/;"	f	class:coherence_tag_array
is_free	shader.h	/^      bool is_free() const {return m_allocation==NO_ALLOC; }$/;"	f	class:opndcoll_rfu_t::allocation_t
is_free	shader.h	/^      bool is_free(){return m_free;}$/;"	f	class:opndcoll_rfu_t::collector_unit_t
is_logical_tm_req	mem_fetch.cc	/^bool mem_fetch::is_logical_tm_req() const$/;"	f	class:mem_fetch
is_nested_tx_commit	shader.cc	/^bool tx_log_walker::is_nested_tx_commit(const warp_inst_t &inst)$/;"	f	class:tx_log_walker
is_nested_tx_commit	shader.cc	/^bool tx_log_walker::is_nested_tx_commit(const warp_inst_t &inst, int lane_id)$/;"	f	class:tx_log_walker
is_read	shader.h	/^      bool is_read() const { return m_allocation==READ_ALLOC; }$/;"	f	class:opndcoll_rfu_t::allocation_t
is_stalled	mem_fetch.h	/^   bool is_stalled() const { return m_is_stalled; }$/;"	f	class:mem_fetch
is_tcommit	shader.cc	/^bool is_tcommit( warp_inst_t* warp_inst ) { return warp_inst->is_tcommit; }$/;"	f
is_transaction_dst	shader.h	/^      bool is_transaction_dst() const { return m_is_transaction_dst; }$/;"	f	class:opndcoll_rfu_t::op_t
is_transactional	mem_fetch.h	/^   bool is_transactional() const { return m_transactional; }$/;"	f	class:mem_fetch
is_tx_load	mem_fetch.h	/^   bool is_tx_load() const { return m_access.is_tx_load(); }$/;"	f	class:mem_fetch
is_write	mem_fetch.h	/^   bool is_write() {return m_access.is_write();}$/;"	f	class:mem_fetch
is_write	shader.h	/^      bool is_write() const {return m_allocation==WRITE_ALLOC; }$/;"	f	class:opndcoll_rfu_t::allocation_t
isactive	shader.h	/^    unsigned isactive() const {if(m_n_active_cta>0) return 1; else return 0;}$/;"	f	class:shader_core_ctx
isatomic	mem_fetch.cc	/^bool mem_fetch::isatomic() const$/;"	f	class:mem_fetch
isconst	mem_fetch.cc	/^bool mem_fetch::isconst() const$/;"	f	class:mem_fetch
islongop	scoreboard.cc	/^const bool Scoreboard::islongop (unsigned warp_id,unsigned regnum) {$/;"	f	class:Scoreboard
issue	shader.cc	/^void ldst_unit::issue( register_set &reg_set )$/;"	f	class:ldst_unit
issue	shader.cc	/^void pipelined_simd_unit::issue( register_set& source_reg )$/;"	f	class:pipelined_simd_unit
issue	shader.cc	/^void sfu::issue( register_set& source_reg )$/;"	f	class:sfu
issue	shader.cc	/^void shader_core_ctx::issue(){$/;"	f	class:shader_core_ctx
issue	shader.cc	/^void sp_unit :: issue(register_set& source_reg)$/;"	f	class:sp_unit
issue	shader.h	/^    virtual void issue( register_set& source_reg ) { source_reg.move_out_to(m_dispatch_reg); occupied.set(m_dispatch_reg->latency);}$/;"	f	class:simd_function_unit
issue_block2core	gpu-sim.cc	/^void gpgpu_sim::issue_block2core()$/;"	f	class:gpgpu_sim
issue_block2core	gpu-sim.cc	/^void shader_core_ctx::issue_block2core( kernel_info_t &kernel ) $/;"	f	class:shader_core_ctx
issue_block2core	shader.cc	/^unsigned simt_core_cluster::issue_block2core()$/;"	f	class:simt_core_cluster
issue_cycle	commit_unit.h	/^       unsigned issue_cycle; $/;"	m	class:commit_unit::cu_mem_acc
issue_warp	shader.cc	/^void shader_core_ctx::issue_warp( register_set& pipe_reg_set, const warp_inst_t* next_inst, const active_mask_t &active_mask, unsigned warp_id )$/;"	f	class:shader_core_ctx
issue_warp_dummy_commit	shader.cc	/^void shader_core_ctx::issue_warp_dummy_commit( register_set& pipe_reg_set, const warp_inst_t* next_inst, const active_mask_t &active_mask, unsigned warp_id )$/;"	f	class:shader_core_ctx
istexture	mem_fetch.cc	/^bool mem_fetch::istexture() const$/;"	f	class:mem_fetch
iwcd_uarch_info	shader.h	/^      iwcd_uarch_info() $/;"	f	class:tx_log_walker::iwcd_uarch_info
iwcd_uarch_info	shader.h	/^   class iwcd_uarch_info$/;"	c	class:tx_log_walker
iwo_logger	stat-tool.cc	/^static std::vector<insn_warp_occ_logger> iwo_logger;$/;"	v	file:
kernel_max_cta_per_shader	shader.h	/^    unsigned kernel_max_cta_per_shader;$/;"	m	class:shader_core_ctx
kernel_padded_threads_per_cta	shader.h	/^    unsigned kernel_padded_threads_per_cta;$/;"	m	class:shader_core_ctx
l1_cache	gpu-cache.h	/^    l1_cache( const char *name,$/;"	f	class:l1_cache
l1_cache	gpu-cache.h	/^    l1_cache(const char *name, cache_config &config,$/;"	f	class:l1_cache
l1_cache	gpu-cache.h	/^class l1_cache : public data_cache {$/;"	c
l2_cache	gpu-cache.h	/^    l2_cache(const char *name,  cache_config &config,$/;"	f	class:l2_cache
l2_cache	gpu-cache.h	/^class l2_cache : public data_cache {$/;"	c
l2_cache_config	gpu-cache.h	/^	l2_cache_config() : cache_config(){}$/;"	f	class:l2_cache_config
l2_cache_config	gpu-cache.h	/^class l2_cache_config : public cache_config {$/;"	c
l2_cache_stats	power_stat.h	/^    class cache_stats l2_cache_stats[NUM_STAT_IDX]; \/\/ Total L2 partition stats$/;"	m	struct:mem_power_stats_pod	typeref:class:mem_power_stats_pod::cache_stats
l2_freq	gpu-sim.h	/^    double l2_freq;$/;"	m	class:gpgpu_sim_config
l2_ideal	gpu-sim.h	/^   bool l2_ideal;$/;"	m	struct:memory_config
l2_period	gpu-sim.h	/^    double l2_period;$/;"	m	class:gpgpu_sim_config
l2_time	gpu-sim.h	/^   double l2_time;$/;"	m	class:gpgpu_sim
last_borrower	l2cache.h	/^      int last_borrower() const { return m_last_borrower; } $/;"	f	class:memory_partition_unit::arbitration_metadata
last_bwutil	dram.h	/^   unsigned int last_n_cmd, last_n_activity, last_bwutil;$/;"	m	class:dram_t
last_gpu_sim_insn	gpu-sim.h	/^   unsigned long long  last_gpu_sim_insn;$/;"	m	class:gpgpu_sim
last_liveness_message_time	gpu-sim.h	/^   unsigned long long  last_liveness_message_time; $/;"	m	class:gpgpu_sim
last_n_activity	dram.h	/^   unsigned int last_n_cmd, last_n_activity, last_bwutil;$/;"	m	class:dram_t
last_n_cmd	dram.h	/^   unsigned int last_n_cmd, last_n_activity, last_bwutil;$/;"	m	class:dram_t
last_shader_cycle_distro	shader.h	/^    unsigned *last_shader_cycle_distro;$/;"	m	struct:shader_core_stats_pod
latency	shader.h	/^   unsigned long latency;$/;"	m	struct:insn_latency_info
launch	gpu-sim.cc	/^void gpgpu_sim::launch( kernel_info_t *kinfo )$/;"	f	class:gpgpu_sim
ld_time_dist	visualizer.cc	/^   std::vector<double>  ld_time_dist;$/;"	m	class:my_time_vector	file:
ld_time_map	visualizer.cc	/^   std::map< unsigned int, std::vector<long int> > ld_time_map;$/;"	m	class:my_time_vector	file:
ld_vector_size	visualizer.cc	/^   unsigned ld_vector_size;$/;"	m	class:my_time_vector	file:
ldst_unit	shader.cc	/^ldst_unit::ldst_unit( mem_fetch_interface *&icnt,$/;"	f	class:ldst_unit
ldst_unit	shader.h	/^class ldst_unit: public pipelined_simd_unit {$/;"	c
ldst_unit_response_buffer_full	shader.cc	/^bool shader_core_ctx::ldst_unit_response_buffer_full() const$/;"	f	class:shader_core_ctx
ldst_unit_response_queue_size	shader.h	/^    unsigned ldst_unit_response_queue_size;$/;"	m	struct:shader_core_config
linear_buffer_t	commit_unit.h	/^    typedef std::list<new_addr_type> linear_buffer_t; $/;"	t	class:cu_access_set
linear_buffer_usage	commit_unit.h	/^    size_t linear_buffer_usage() const { return m_linear_buffer.size(); }$/;"	f	class:cu_access_set
linear_histogram	histogram.cc	/^linear_histogram::linear_histogram (int stride, const char *name, int nbins, int* bins) $/;"	f	class:linear_histogram
linear_histogram	histogram.h	/^class linear_histogram : public binned_histogram {$/;"	c
linear_histogram_logger	stat-tool.cc	/^linear_histogram_logger::linear_histogram_logger(const linear_histogram_logger& other) $/;"	f	class:linear_histogram_logger
linear_histogram_logger	stat-tool.cc	/^linear_histogram_logger::linear_histogram_logger(int n_bins, $/;"	f	class:linear_histogram_logger
linear_histogram_logger	stat-tool.h	/^class linear_histogram_logger : public snap_shot_trigger, public spill_log_interface {$/;"	c
linear_histogram_snapshot	stat-tool.h	/^   linear_histogram_snapshot(const linear_histogram_snapshot& other) $/;"	f	class:linear_histogram_snapshot
linear_histogram_snapshot	stat-tool.h	/^   linear_histogram_snapshot(int n_bins, unsigned long long  cycle) $/;"	f	class:linear_histogram_snapshot
linear_histogram_snapshot	stat-tool.h	/^class linear_histogram_snapshot {$/;"	c
linear_to_raw_address_translation	addrdec.cc	/^linear_to_raw_address_translation::linear_to_raw_address_translation()$/;"	f	class:linear_to_raw_address_translation
linear_to_raw_address_translation	addrdec.h	/^class linear_to_raw_address_translation {$/;"	c
link_to_commit_id	commit_unit.cc	/^void warp_commit_entry::link_to_commit_id(const commit_entry& cmt_entry)$/;"	f	class:warp_commit_entry
list_spill_log	stat-tool.cc	/^static std::list<spill_log_interface*> list_spill_log;$/;"	v	file:
list_ss_trigger	stat-tool.cc	/^static std::list<snap_shot_trigger*> list_ss_trigger;$/;"	v	file:
liveness_message_freq	gpu-sim.h	/^    unsigned long long liveness_message_freq; $/;"	m	class:gpgpu_sim_config
local_write_misses	gpu-cache.h	/^    unsigned local_write_misses; $/;"	m	struct:cache_sub_stats
local_write_misses_full_cacheline	gpu-cache.h	/^    unsigned local_write_misses_full_cacheline; $/;"	m	struct:cache_sub_stats
log	stat-tool.h	/^   void log(address_type pc, int warp_occ) {$/;"	f	class:insn_warp_occ_logger
log	stat-tool.h	/^   void log(int pos) { m_curr_lin_hist.addsample(pos); }$/;"	f	class:linear_histogram_logger
log_acc_type_t	shader.h	/^   enum log_acc_type_t {$/;"	g	class:tx_log_walker
log_send_status_t	shader.h	/^      log_send_status_t(int eid = -1, enum log_acc_type_t ltype = INVALID) $/;"	f	struct:tx_log_walker::log_send_status_t
log_send_status_t	shader.h	/^   struct log_send_status_t {$/;"	s	class:tx_log_walker
log_type	shader.h	/^      enum log_acc_type_t log_type;$/;"	m	struct:tx_log_walker::log_send_status_t	typeref:enum:tx_log_walker::log_send_status_t::log_acc_type_t
logical_mem_fetch	l2cache.h	/^typedef std::pair<unsigned long long, mem_fetch*> logical_mem_fetch;$/;"	t
logical_mem_fetch_compare	l2cache.h	/^struct logical_mem_fetch_compare {$/;"	s
logical_mem_fetch_container	l2cache.h	/^typedef std::vector<logical_mem_fetch> logical_mem_fetch_container;$/;"	t
longopregs	scoreboard.h	/^    std::vector< std::set<unsigned> > longopregs;$/;"	m	class:Scoreboard
lrr_scheduler	shader.h	/^	lrr_scheduler ( shader_core_stats* stats, shader_core_ctx* shader,$/;"	f	class:lrr_scheduler
lrr_scheduler	shader.h	/^class lrr_scheduler : public scheduler_unit {$/;"	c
m_L1C	shader.h	/^   read_only_cache *m_L1C; \/\/ constant cache$/;"	m	class:ldst_unit
m_L1C_config	shader.h	/^    mutable cache_config m_L1C_config;$/;"	m	struct:shader_core_config
m_L1D	shader.h	/^   data_cache *m_L1D; \/\/ for log access$/;"	m	class:tx_log_walker
m_L1D	shader.h	/^   l1_cache *m_L1D; \/\/ data cache$/;"	m	class:ldst_unit
m_L1D_config	shader.h	/^    mutable cache_config m_L1D_config;$/;"	m	struct:shader_core_config
m_L1I	shader.h	/^    read_only_cache *m_L1I; \/\/ instruction cache$/;"	m	class:shader_core_ctx
m_L1I_config	shader.h	/^    mutable cache_config m_L1I_config;$/;"	m	struct:shader_core_config
m_L1PC_config	shader.h	/^    mutable cache_config m_L1PC_config;$/;"	m	struct:shader_core_config
m_L1T	shader.h	/^   tex_cache *m_L1T; \/\/ texture cache$/;"	m	class:ldst_unit
m_L1T_config	shader.h	/^    mutable cache_config m_L1T_config;$/;"	m	struct:shader_core_config
m_L1X_config	shader.h	/^    mutable cache_config m_L1X_config;$/;"	m	struct:shader_core_config
m_L1_load	shader.h	/^      unsigned m_L1_load; $/;"	m	class:tx_log_walker::iwcd_uarch_info
m_L2_config	gpu-sim.h	/^   mutable l2_cache_config m_L2_config;$/;"	m	struct:memory_config
m_L2_dram_queue	l2cache.h	/^   fifo_pipeline<mem_fetch> *m_L2_dram_queue;$/;"	m	class:memory_sub_partition
m_L2_icnt_queue	l2cache.h	/^   fifo_pipeline<mem_fetch> *m_L2_icnt_queue; \/\/ L2 cache hit response queue$/;"	m	class:memory_sub_partition
m_L2_texure_only	gpu-sim.h	/^   bool m_L2_texure_only;$/;"	m	struct:memory_config
m_L2_tm_stall_queue	l2cache.h	/^   tm_req_stall_queue *m_L2_tm_stall_queue;$/;"	m	class:memory_sub_partition
m_L2cache	l2cache.h	/^   class l2_cache *m_L2cache;$/;"	m	class:memory_sub_partition	typeref:class:memory_sub_partition::l2_cache
m_L2interface	l2cache.h	/^   class L2interface *m_L2interface;$/;"	m	class:memory_sub_partition	typeref:class:memory_sub_partition::L2interface
m_SMem_acc	shader.h	/^      unsigned m_SMem_acc; $/;"	m	class:tx_log_walker::iwcd_uarch_info
m_TLW	shader.h	/^   tx_log_walker *m_TLW; \/\/ the unit that send read-set and write-set to MP-side commit unit at commit $/;"	m	class:ldst_unit
m_TLW_stats	shader.h	/^    tx_log_walker_stats *m_TLW_stats; $/;"	m	class:shader_core_stats
m_acc_type	shader.h	/^       enum log_acc_type_t m_acc_type; $/;"	m	struct:tx_log_walker::extra_mf_fields	typeref:enum:tx_log_walker::extra_mf_fields::log_acc_type_t
m_access	gpu-cache.h	/^    unsigned m_access;$/;"	m	class:tag_array
m_access	mem_fetch.h	/^   mem_access_t m_access;$/;"	m	class:mem_fetch
m_ack_wait_time	commit_unit.cc	/^   pow2_histogram m_ack_wait_time; $/;"	m	class:commit_unit_stats	file:
m_ack_wait_time	commit_unit.h	/^    unsigned m_ack_wait_time; $/;"	m	class:commit_entry
m_active	shader.h	/^      bool m_active;$/;"	m	struct:tx_log_walker::warp_commit_tx_t
m_active	shader.h	/^   bool m_active;$/;"	m	class:thread_ctx_t
m_active_cycle	shader.h	/^   unsigned long long m_active_cycle;$/;"	m	class:thread_ctx_t
m_active_entries	commit_unit.cc	/^   pow2_histogram m_active_entries;$/;"	m	class:commit_unit_stats	file:
m_active_entries	commit_unit.h	/^   int m_active_entries;$/;"	m	class:conflict_table_perfect
m_active_entries_have_rs	commit_unit.cc	/^   pow2_histogram m_active_entries_have_rs;$/;"	m	class:commit_unit_stats	file:
m_active_entries_have_ws	commit_unit.cc	/^   pow2_histogram m_active_entries_have_ws;$/;"	m	class:commit_unit_stats	file:
m_active_entries_need_rs	commit_unit.cc	/^   pow2_histogram m_active_entries_need_rs;$/;"	m	class:commit_unit_stats	file:
m_active_entries_need_ws	commit_unit.cc	/^   pow2_histogram m_active_entries_need_ws;$/;"	m	class:commit_unit_stats	file:
m_active_fu_lanes	shader.h	/^    unsigned *m_active_fu_lanes;$/;"	m	struct:shader_core_stats_pod
m_active_fu_mem_lanes	shader.h	/^    unsigned *m_active_fu_mem_lanes;$/;"	m	struct:shader_core_stats_pod
m_active_in_cleaning	shader.h	/^   bool m_active_in_cleaning;  \/\/ state to track whether this thread was aborted and is cleaning$/;"	m	class:thread_ctx_t
m_active_in_commit	shader.h	/^   bool m_active_in_commit;  \/\/ state to track whether this thread was part of the commit process$/;"	m	class:thread_ctx_t
m_active_mask	commit_unit.h	/^   active_mask_t m_active_mask; $/;"	m	class:warp_commit_entry
m_active_set	shader.h	/^   bool m_active_set;$/;"	m	class:thread_ctx_t
m_active_sfu_lanes	power_stat.h	/^    unsigned *m_active_sfu_lanes[NUM_STAT_IDX];$/;"	m	struct:shader_core_power_stats_pod
m_active_sfu_lanes	shader.h	/^    unsigned *m_active_sfu_lanes;$/;"	m	struct:shader_core_stats_pod
m_active_sms	power_stat.h	/^   float * m_active_sms;$/;"	m	class:power_stat_t
m_active_sp_lanes	power_stat.h	/^    unsigned *m_active_sp_lanes[NUM_STAT_IDX];$/;"	m	struct:shader_core_power_stats_pod
m_active_sp_lanes	shader.h	/^    unsigned *m_active_sp_lanes;$/;"	m	struct:shader_core_stats_pod
m_active_threads	shader.h	/^    std::bitset<MAX_THREAD_PER_SM> m_active_threads;$/;"	m	class:shader_core_ctx
m_active_threads	shader.h	/^    std::bitset<MAX_WARP_SIZE> m_active_threads;$/;"	m	class:shd_warp_t
m_addr_hashtable	commit_unit.h	/^    addr_hashset_t m_addr_hashtable; $/;"	m	class:cu_access_set
m_addr_quantize_mask	commit_unit.h	/^   new_addr_type m_addr_quantize_mask; $/;"	m	class:conflict_detector
m_addr_quantize_mask	commit_unit.h	/^   new_addr_type m_addr_quantize_mask; $/;"	m	class:conflict_table_perfect
m_address_mapping	gpu-cache.h	/^	linear_to_raw_address_translation *m_address_mapping;$/;"	m	class:l2_cache_config
m_address_mapping	gpu-sim.h	/^   linear_to_raw_address_translation m_address_mapping;$/;"	m	struct:memory_config
m_advance_skip_msg	shader.h	/^   const bool m_advance_skip_msg; $/;"	m	class:tx_log_walker
m_advance_skip_sent	shader.h	/^      bool m_advance_skip_sent; $/;"	m	struct:tx_log_walker::commit_tx_t
m_alloc_policy	gpu-cache.h	/^    enum allocation_policy_t m_alloc_policy;        \/\/ 'm' = allocate on miss, 'f' = allocate on fill$/;"	m	class:cache_config	typeref:enum:cache_config::allocation_policy_t
m_alloc_retries	shader.h	/^      unsigned m_alloc_retries; \/\/ stats - number of times retried for alloc$/;"	m	struct:tx_log_walker::commit_tx_t
m_alloc_retry_increment	shader.h	/^      unsigned m_alloc_retry_increment;$/;"	m	struct:tx_log_walker::commit_tx_t
m_alloc_retry_timeout	shader.h	/^      unsigned long long  m_alloc_retry_timeout;$/;"	m	struct:tx_log_walker::commit_tx_t
m_alloc_time	coherence_manager.h	/^    unsigned         m_alloc_time;$/;"	m	struct:coherence_cache_block_t
m_alloc_time	coherence_manager.h	/^    unsigned        m_alloc_time;$/;"	m	struct:coherence_directory_block_t
m_alloc_time	commit_unit.h	/^    unsigned m_alloc_time; $/;"	m	class:commit_entry
m_alloc_time	gpu-cache.h	/^    unsigned         m_alloc_time;$/;"	m	struct:cache_block_t
m_alloc_time	shader.h	/^      unsigned long long m_alloc_time;$/;"	m	struct:tx_log_walker::commit_tx_t
m_allocated	coherence_manager.h	/^    bool m_allocated;$/;"	m	class:coherence_tag_array
m_allocated_bank	shader.h	/^      allocation_t *m_allocated_bank; \/\/ bank # -> register that wins$/;"	m	class:opndcoll_rfu_t::arbiter_t
m_allocation	shader.h	/^      enum alloc_t m_allocation;$/;"	m	class:opndcoll_rfu_t::allocation_t	typeref:enum:opndcoll_rfu_t::allocation_t::alloc_t
m_allocator_rr_head	shader.h	/^      unsigned *m_allocator_rr_head; \/\/ cu # -> next bank to check for request (rr-arb)$/;"	m	class:opndcoll_rfu_t::arbiter_t
m_arbiter	shader.h	/^   arbiter_t m_arbiter;$/;"	m	class:opndcoll_rfu_t
m_arbitration_metadata	l2cache.h	/^   arbitration_metadata m_arbitration_metadata; $/;"	m	class:memory_partition_unit
m_assoc	gpu-cache.h	/^    unsigned m_assoc;$/;"	m	class:cache_config
m_atomic_mode	shader.h	/^   bool m_atomic_mode;$/;"	m	class:thread_ctx_t
m_average_pipeline_duty_cycle	power_stat.h	/^   float * m_average_pipeline_duty_cycle;$/;"	m	class:power_stat_t
m_bandwidth_management	gpu-cache.h	/^    bandwidth_management m_bandwidth_management; $/;"	m	class:baseline_cache
m_bank	shader.h	/^      unsigned  m_bank;$/;"	m	class:opndcoll_rfu_t::op_t
m_bank_warp_shift	shader.h	/^      unsigned m_bank_warp_shift;$/;"	m	class:opndcoll_rfu_t::collector_unit_t
m_bank_warp_shift	shader.h	/^   unsigned m_bank_warp_shift;$/;"	m	class:opndcoll_rfu_t
m_barriers	shader.h	/^    barrier_set_t             m_barriers;$/;"	m	class:shader_core_ctx
m_bg_commit_warps	shader.h	/^   std::list<int> m_bg_commit_warps; \/\/ warp current in commit $/;"	m	class:tx_log_walker
m_bin_cnts	histogram.h	/^   int *m_bin_cnts;    \/\/ counters$/;"	m	class:binned_histogram
m_bins	dram_sched.h	/^   std::map<unsigned,std::list<std::list<dram_req_t*>::iterator> >    *m_bins;$/;"	m	class:frfcfs_scheduler
m_bins	histogram.h	/^   int *m_bins;        \/\/ bin boundaries$/;"	m	class:binned_histogram
m_block_addr	coherence_manager.h	/^    new_addr_type    m_block_addr;$/;"	m	struct:coherence_cache_block_t
m_block_addr	coherence_manager.h	/^    new_addr_type    m_block_addr;$/;"	m	struct:coherence_directory_block_t
m_block_addr	gpu-cache.h	/^        new_addr_type m_block_addr;$/;"	m	struct:baseline_cache::extra_mf_fields
m_block_addr	gpu-cache.h	/^        new_addr_type m_block_addr;$/;"	m	struct:tex_cache::data_block
m_block_addr	gpu-cache.h	/^        new_addr_type m_block_addr;$/;"	m	struct:tex_cache::rob_entry
m_block_addr	gpu-cache.h	/^    new_addr_type    m_block_addr;$/;"	m	struct:cache_block_t
m_bloom_filter	shader.cc	/^   bool m_bloom_filter; $/;"	m	class:ownership_table	file:
m_bloomfilter	commit_unit.h	/^    bloomfilter *m_bloomfilter; $/;"	m	class:cu_access_set
m_bloomfilter_detections	commit_unit.cc	/^   unsigned long long m_bloomfilter_detections; $/;"	m	class:commit_unit_stats	file:
m_bloomfilter_false_positive	commit_unit.cc	/^   unsigned long long m_bloomfilter_false_positive; $/;"	m	class:commit_unit_stats	file:
m_bloomfilter_func_id	commit_unit.cc	/^   std::vector<int> m_bloomfilter_func_id;$/;"	m	class:commit_unit_options	file:
m_bloomfilter_hit	commit_unit.cc	/^   unsigned long long m_bloomfilter_hit; $/;"	m	class:commit_unit_stats	file:
m_bloomfilter_n_func	commit_unit.cc	/^   unsigned int m_bloomfilter_n_func; $/;"	m	class:commit_unit_options	file:
m_bloomfilter_size	commit_unit.cc	/^   unsigned int m_bloomfilter_size; $/;"	m	class:commit_unit_options	file:
m_build_txns_warp_group	coherence_manager.h	/^    std::map<unsigned, std::set<unsigned> > m_build_txns_warp_group;        \/\/ use this to build txns warp groups$/;"	m	class:coherence_manager
m_cache	gpu-cache.h	/^    data_block             *m_cache;$/;"	m	class:tex_cache
m_cache_data_port_busy_cycles	gpu-cache.h	/^    unsigned long long m_cache_data_port_busy_cycles; $/;"	m	class:cache_stats
m_cache_fill_port_busy_cycles	gpu-cache.h	/^    unsigned long long m_cache_fill_port_busy_cycles; $/;"	m	class:cache_stats
m_cache_index	gpu-cache.h	/^        unsigned   m_cache_index; \/\/ where to look for data$/;"	m	struct:tex_cache::fragment_entry
m_cache_index	gpu-cache.h	/^        unsigned m_cache_index;$/;"	m	struct:baseline_cache::extra_mf_fields
m_cache_port_available_cycles	gpu-cache.h	/^    unsigned long long m_cache_port_available_cycles; $/;"	m	class:cache_stats
m_check_read_set_version	commit_unit.cc	/^   bool m_check_read_set_version; $/;"	m	class:commit_unit_options	file:
m_cid2tid	shader.h	/^   commit_id_thread_lookup m_cid2tid; $/;"	m	class:tx_log_walker
m_cid_at_head	commit_unit.h	/^    int m_cid_at_head; \/\/ the youngest commit id in the unit $/;"	m	class:commit_unit
m_cid_commit	commit_unit.h	/^    int m_cid_commit; \/\/ the oldest commit id that has yet to send writeset for committing$/;"	m	class:commit_unit
m_cid_commit_stall_cycles	commit_unit.h	/^    int m_cid_commit_stall_cycles; $/;"	m	class:commit_unit
m_cid_commit_stats	commit_unit.cc	/^   cid_pointer_stats m_cid_commit_stats; $/;"	m	class:commit_unit_stats	file:
m_cid_fcd	commit_unit.h	/^    int m_cid_fcd; \/\/ the oldest commit id that has yet to pass fast conflict detection$/;"	m	class:commit_unit
m_cid_fcd_stall_cycles	commit_unit.h	/^    int m_cid_fcd_stall_cycles;$/;"	m	class:commit_unit
m_cid_fcd_stats	commit_unit.cc	/^   cid_pointer_stats m_cid_fcd_stats;$/;"	m	class:commit_unit_stats	file:
m_cid_pass	commit_unit.h	/^    int m_cid_pass; \/\/ the oldest commit id that has yet to validate or pass$/;"	m	class:commit_unit
m_cid_pass_stall_cycles	commit_unit.h	/^    int m_cid_pass_stall_cycles; $/;"	m	class:commit_unit
m_cid_pass_stats	commit_unit.cc	/^   cid_pointer_stats m_cid_pass_stats; $/;"	m	class:commit_unit_stats	file:
m_cid_retire	commit_unit.h	/^    int m_cid_retire; \/\/ the oldest commit id that has retired$/;"	m	class:commit_unit
m_cid_retire_stall_cycles	commit_unit.h	/^    int m_cid_retire_stall_cycles; $/;"	m	class:commit_unit
m_cid_retire_stats	commit_unit.cc	/^   cid_pointer_stats m_cid_retire_stats; $/;"	m	class:commit_unit_stats	file:
m_cluster	gpu-sim.h	/^   class simt_core_cluster **m_cluster;$/;"	m	class:gpgpu_sim	typeref:class:gpgpu_sim::simt_core_cluster
m_cluster	shader.h	/^    class simt_core_cluster *m_cluster;$/;"	m	class:shader_core_ctx	typeref:class:shader_core_ctx::simt_core_cluster
m_cluster	shader.h	/^    simt_core_cluster *m_cluster;$/;"	m	class:perfect_memory_interface
m_cluster	shader.h	/^    simt_core_cluster *m_cluster;$/;"	m	class:shader_memory_interface
m_cluster_id	shader.h	/^    unsigned m_cluster_id;$/;"	m	class:shader_core_mem_fetch_allocator
m_cluster_id	shader.h	/^    unsigned m_cluster_id;$/;"	m	class:simt_core_cluster
m_cluster_id	shader.h	/^   unsigned m_cluster_id; $/;"	m	class:tx_log_walker
m_coalesce_block_size	commit_unit.cc	/^   unsigned m_coalesce_block_size; $/;"	m	class:commit_unit_options	file:
m_coalesce_mem_op	commit_unit.cc	/^   bool m_coalesce_mem_op; $/;"	m	class:commit_unit_options	file:
m_coalesce_reply	commit_unit.cc	/^   bool m_coalesce_reply; $/;"	m	class:commit_unit_options	file:
m_coalesced_ops	commit_unit.h	/^       std::list<cu_mem_acc> m_coalesced_ops; $/;"	m	class:commit_unit::cu_mem_acc
m_coalesced_packet_size	shader.cc	/^   linear_histogram m_coalesced_packet_size;$/;"	m	class:tx_log_walker_stats	file:
m_coalesced_packets	mem_fetch.h	/^   std::list<mem_fetch*> m_coalesced_packets; $/;"	m	class:mem_fetch
m_coalesced_popped	mem_fetch.h	/^   bool m_coalesced_popped; $/;"	m	class:mem_fetch
m_coalescing_queue	shader.h	/^   std::vector< std::list<mem_fetch*> > m_coalescing_queue;$/;"	m	class:tx_log_walker
m_coherence_L0_caches	coherence_manager.h	/^	std::vector<coherence_tag_array*> m_coherence_L0_caches;$/;"	m	class:coherence_manager
m_coherence_manager	gpu-sim.h	/^   class coherence_manager *m_coherence_manager;$/;"	m	class:gpgpu_sim	typeref:class:gpgpu_sim::coherence_manager
m_collector_units	shader.h	/^      std::vector<collector_unit_t>* m_collector_units;$/;"	m	class:opndcoll_rfu_t::dispatch_unit_t
m_commit_L2_access	commit_unit.cc	/^   unsigned long long m_commit_L2_access;$/;"	m	class:commit_unit_stats	file:
m_commit_L2_hit	commit_unit.cc	/^   unsigned long long m_commit_L2_hit;$/;"	m	class:commit_unit_stats	file:
m_commit_ack_pending_mask	commit_unit.h	/^   active_mask_t m_commit_ack_pending_mask; $/;"	m	class:warp_commit_entry
m_commit_ack_sent	commit_unit.h	/^    bool m_commit_ack_sent; \/\/ to detect missing\/redundant commit ack$/;"	m	class:commit_entry
m_commit_coalescing_queue	commit_unit.h	/^    mem_op_queue_t m_commit_coalescing_queue; $/;"	m	class:commit_unit
m_commit_done_mask	commit_unit.h	/^   active_mask_t m_commit_done_mask; $/;"	m	class:warp_commit_entry
m_commit_entry_table	commit_unit.h	/^    commit_entry_table_t m_commit_entry_table; $/;"	m	class:commit_unit
m_commit_id	commit_unit.h	/^    int m_commit_id; $/;"	m	class:commit_entry
m_commit_id	mem_fetch.h	/^   int m_commit_id; $/;"	m	class:mem_fetch
m_commit_id	shader.h	/^      int m_commit_id; $/;"	m	struct:tx_log_walker::commit_tx_t
m_commit_ids	commit_unit.h	/^   std::vector<int> m_commit_ids; $/;"	m	class:warp_commit_entry
m_commit_latency	commit_unit.cc	/^   pow2_histogram m_commit_latency; $/;"	m	class:commit_unit_stats	file:
m_commit_pending_flag	commit_unit.h	/^    std::bitset<16>* m_commit_pending_flag;$/;"	m	class:commit_entry
m_commit_pending_flag	mem_fetch.h	/^   std::bitset<16>* m_commit_pending_flag; $/;"	m	class:mem_fetch
m_commit_queue	commit_unit.h	/^    mem_op_queue_t m_commit_queue; $/;"	m	class:commit_unit
m_commit_queue_size	commit_unit.cc	/^   pow2_histogram m_commit_queue_size; $/;"	m	class:commit_unit_stats	file:
m_commit_ready_time	commit_unit.h	/^    unsigned m_commit_ready_time;$/;"	m	class:commit_entry
m_commit_sent_time	commit_unit.h	/^    unsigned m_commit_sent_time;$/;"	m	class:commit_entry
m_commit_time	commit_unit.cc	/^   pow2_histogram m_commit_time; $/;"	m	class:commit_unit_stats	file:
m_commit_unit	l2cache.h	/^   commit_unit *m_commit_unit; $/;"	m	class:memory_sub_partition
m_commit_unit_generated	mem_fetch.h	/^   bool m_commit_unit_generated; $/;"	m	class:mem_fetch
m_committing_warp	shader.h	/^   std::vector<warp_commit_tx_t> m_committing_warp; \/\/ the state of the committing warps $/;"	m	class:tx_log_walker
m_config	coherence_manager.h	/^    const cache_config &m_config;$/;"	m	class:coherence_tag_array
m_config	dram.h	/^   const struct memory_config *m_config;$/;"	m	class:dram_t	typeref:struct:dram_t::memory_config
m_config	dram_sched.h	/^   const memory_config *m_config;$/;"	m	class:frfcfs_scheduler
m_config	gpu-cache.h	/^        const cache_config &m_config; $/;"	m	class:baseline_cache::bandwidth_management
m_config	gpu-cache.h	/^    cache_config &m_config;$/;"	m	class:baseline_cache
m_config	gpu-cache.h	/^    cache_config &m_config;$/;"	m	class:tag_array
m_config	gpu-cache.h	/^    const cache_config &m_config;$/;"	m	class:tex_cache
m_config	gpu-sim.h	/^   const gpgpu_sim_config &m_config;$/;"	m	class:gpgpu_sim
m_config	l2cache.h	/^   const struct memory_config *m_config;$/;"	m	class:memory_partition_unit	typeref:struct:memory_partition_unit::memory_config
m_config	l2cache.h	/^   const struct memory_config *m_config;$/;"	m	class:memory_sub_partition	typeref:struct:memory_sub_partition::memory_config
m_config	power_stat.h	/^   const memory_config *m_config;$/;"	m	class:power_mem_stat_t
m_config	power_stat.h	/^   const shader_core_config *m_config;$/;"	m	class:power_core_stat_t
m_config	power_stat.h	/^   const shader_core_config *m_config;$/;"	m	class:power_stat_t
m_config	shader.h	/^    const shader_core_config *m_config;$/;"	m	class:shader_core_ctx
m_config	shader.h	/^    const shader_core_config *m_config;$/;"	m	class:shader_core_stats
m_config	shader.h	/^    const shader_core_config *m_config;$/;"	m	class:simd_function_unit
m_config	shader.h	/^    const shader_core_config *m_config;$/;"	m	class:simt_core_cluster
m_config_string	gpu-cache.h	/^    char *m_config_string;$/;"	m	class:cache_config
m_config_stringPrefL1	gpu-cache.h	/^    char *m_config_stringPrefL1;$/;"	m	class:cache_config
m_config_stringPrefShared	gpu-cache.h	/^    char *m_config_stringPrefShared;$/;"	m	class:cache_config
m_conflict_detector	commit_unit.h	/^    conflict_detector m_conflict_detector;$/;"	m	class:commit_unit
m_conflict_table	commit_unit.h	/^   conflict_table_t m_conflict_table;$/;"	m	class:conflict_table_perfect
m_conflict_table_bf	commit_unit.h	/^   versioning_bloomfilter* m_conflict_table_bf;$/;"	m	class:conflict_detector
m_conflict_table_bf_false_positives	commit_unit.cc	/^   unsigned long long m_conflict_table_bf_false_positives;$/;"	m	class:commit_unit_stats	file:
m_conflict_table_bf_n_funcs	commit_unit.cc	/^   unsigned m_conflict_table_bf_n_funcs;$/;"	m	class:commit_unit_options	file:
m_conflict_table_bf_size	commit_unit.cc	/^   unsigned m_conflict_table_bf_size;$/;"	m	class:commit_unit_options	file:
m_conflict_table_bf_true_negatives	commit_unit.cc	/^   unsigned long long m_conflict_table_bf_true_negatives;$/;"	m	class:commit_unit_stats	file:
m_conflict_table_bf_true_positives	commit_unit.cc	/^   unsigned long long m_conflict_table_bf_true_positives;$/;"	m	class:commit_unit_stats	file:
m_conflict_table_granularity	commit_unit.cc	/^   unsigned m_conflict_table_granularity; $/;"	m	class:commit_unit_options	file:
m_conflict_table_hash	commit_unit.h	/^   conflict_table_hash m_conflict_table_hash;$/;"	m	class:conflict_detector
m_conflict_table_hash_evictions	commit_unit.cc	/^   unsigned long long m_conflict_table_hash_evictions;$/;"	m	class:commit_unit_stats	file:
m_conflict_table_hash_hits	commit_unit.cc	/^   unsigned long long m_conflict_table_hash_hits;$/;"	m	class:commit_unit_stats	file:
m_conflict_table_hash_misses	commit_unit.cc	/^   unsigned long long m_conflict_table_hash_misses;$/;"	m	class:commit_unit_stats	file:
m_conflict_table_hash_sets	commit_unit.cc	/^   unsigned m_conflict_table_hash_sets;$/;"	m	class:commit_unit_options	file:
m_conflict_table_hash_ways	commit_unit.cc	/^   unsigned m_conflict_table_hash_ways;$/;"	m	class:commit_unit_options	file:
m_conflict_table_perfect	commit_unit.h	/^   conflict_table_perfect m_conflict_table_perfect;$/;"	m	class:conflict_detector
m_conflict_table_size	commit_unit.cc	/^   pow2_histogram m_conflict_table_size;$/;"	m	class:commit_unit_stats	file:
m_core	shader.h	/^    class shader_core_ctx *m_core;$/;"	m	class:pipelined_simd_unit	typeref:class:pipelined_simd_unit::shader_core_ctx
m_core	shader.h	/^    shader_core_ctx **m_core;$/;"	m	class:simt_core_cluster
m_core	shader.h	/^    shader_core_ctx *m_core;$/;"	m	class:perfect_memory_interface
m_core	shader.h	/^    shader_core_ctx *m_core;$/;"	m	class:shader_memory_interface
m_core	shader.h	/^   class shader_core_ctx *m_core;$/;"	m	class:ldst_unit	typeref:class:ldst_unit::shader_core_ctx
m_core	shader.h	/^   shader_core_ctx *m_core; \/\/ for warp info access $/;"	m	class:tx_log_walker
m_core_config	power_stat.h	/^   const shader_core_config *m_core_config;$/;"	m	class:power_mem_stat_t
m_core_config	shader.h	/^   const shader_core_config *m_core_config; $/;"	m	class:tx_log_walker
m_core_id	gpu-cache.h	/^    int m_core_id; \/\/ which shader core is using this$/;"	m	class:tag_array
m_core_id	shader.h	/^    unsigned m_core_id;$/;"	m	class:shader_core_mem_fetch_allocator
m_core_id	shader.h	/^   unsigned m_core_id;$/;"	m	class:tx_log_walker
m_core_sim_order	shader.h	/^    std::list<unsigned> m_core_sim_order;$/;"	m	class:simt_core_cluster
m_core_stats	power_stat.h	/^   shader_core_stats * m_core_stats;$/;"	m	class:power_core_stat_t
m_core_stats	power_stat.h	/^   shader_core_stats * m_core_stats;$/;"	m	class:power_mem_stat_t
m_core_stats	shader.h	/^   shader_core_stats &m_core_stats; \/\/ for power model stats $/;"	m	class:tx_log_walker
m_cta_id	shader.h	/^    unsigned m_cta_id;$/;"	m	class:shd_warp_t
m_cta_id	shader.h	/^   unsigned m_cta_id; \/\/ hardware CTA this thread belongs$/;"	m	class:thread_ctx_t
m_cta_issue_next_core	shader.h	/^    unsigned m_cta_issue_next_core;$/;"	m	class:simt_core_cluster
m_cta_status	shader.h	/^    unsigned m_cta_status[MAX_CTA_PER_SHADER]; \/\/ CTAs status $/;"	m	class:shader_core_ctx
m_cta_to_warps	shader.h	/^   cta_to_warp_t m_cta_to_warps; $/;"	m	class:barrier_set_t
m_ctrl_size	mem_fetch.h	/^   unsigned m_ctrl_size; \/\/ how big would all this meta data be in hardware (does not necessarily match actual size of mem_fetch)$/;"	m	class:mem_fetch
m_cu	shader.h	/^      collector_unit_t  *m_cu; $/;"	m	class:opndcoll_rfu_t::op_t
m_cu	shader.h	/^   std::vector<collector_unit_t *> m_cu;$/;"	m	class:opndcoll_rfu_t
m_cu_alloc_fail	shader.h	/^      commit_unit_reply_t m_cu_alloc_fail;$/;"	m	struct:tx_log_walker::commit_tx_t
m_cu_alloc_pass	shader.h	/^      commit_unit_reply_t m_cu_alloc_pass;$/;"	m	struct:tx_log_walker::commit_tx_t
m_cu_allocation_retries	shader.cc	/^   linear_histogram m_cu_allocation_retries;$/;"	m	class:tx_log_walker_stats	file:
m_cu_commit_pending	shader.h	/^      commit_unit_reply_t m_cu_commit_pending;$/;"	m	struct:tx_log_walker::commit_tx_t
m_cu_fail	shader.h	/^      commit_unit_reply_t m_cu_fail;$/;"	m	struct:tx_log_walker::commit_tx_t
m_cu_mem_fetch_fields	commit_unit.h	/^    cu_mem_fetch_lookup m_cu_mem_fetch_fields; $/;"	m	class:commit_unit
m_cu_pass	shader.h	/^      commit_unit_reply_t m_cu_pass;$/;"	m	struct:tx_log_walker::commit_tx_t
m_cu_reply_started	shader.h	/^      bool m_cu_reply_started; $/;"	m	struct:tx_log_walker::commit_tx_t
m_cu_reply_time_end	shader.h	/^      unsigned m_cu_reply_time_end; $/;"	m	struct:tx_log_walker::commit_tx_t
m_cu_reply_time_start	shader.h	/^      unsigned m_cu_reply_time_start; $/;"	m	struct:tx_log_walker::commit_tx_t
m_cu_response_iface	l2cache.h	/^   class L2icnt_interface *m_cu_response_iface;$/;"	m	class:memory_sub_partition	typeref:class:memory_sub_partition::L2icnt_interface
m_cu_sets	shader.h	/^       uint_vector_t m_cu_sets;$/;"	m	class:opndcoll_rfu_t::input_port_t
m_cuda_properties	gpu-sim.h	/^   const struct cudaDeviceProp     *m_cuda_properties;$/;"	m	class:gpgpu_sim	typeref:struct:gpgpu_sim::cudaDeviceProp
m_cuid	shader.h	/^      unsigned m_cuid; \/\/ collector unit hw id$/;"	m	class:opndcoll_rfu_t::collector_unit_t
m_curr_lin_hist	stat-tool.h	/^   linear_histogram_snapshot m_curr_lin_hist;$/;"	m	class:linear_histogram_logger
m_current_req_queue	l2cache.h	/^   unsigned m_current_req_queue;$/;"	m	class:memory_sub_partition
m_current_response	gpu-cache.h	/^    std::list<new_addr_type> m_current_response;$/;"	m	class:mshr_table
m_current_response_ready	gpu-cache.h	/^    bool m_current_response_ready;$/;"	m	class:mshr_table
m_current_warp_id	shader.h	/^   int m_current_warp_id; $/;"	m	class:tx_log_walker
m_current_wid	shader.h	/^   unsigned m_current_wid; $/;"	m	class:history_file_t
m_cus	shader.h	/^   cu_sets_t m_cus;$/;"	m	class:opndcoll_rfu_t
m_cycle	stat-tool.h	/^   unsigned long long  m_cycle;$/;"	m	class:linear_histogram_logger
m_cycle	stat-tool.h	/^   unsigned long long  m_cycle;$/;"	m	class:linear_histogram_snapshot
m_cycle	stat-tool.h	/^   unsigned long long  m_cycle;$/;"	m	class:thread_CFlocality
m_cycle	stat-tool.h	/^   unsigned long long  m_cycle;$/;"	m	class:thread_insn_span
m_data	delayqueue.h	/^   T *m_data;$/;"	m	struct:fifo_data
m_data	gpu-cache.h	/^        T         *m_data;$/;"	m	class:tex_cache::fifo
m_data	gpu-cache.h	/^    table m_data;$/;"	m	class:mshr_table
m_data	tm_conflict_detector.h	/^    std::vector<blk_info> m_data;$/;"	m	class:tm_conflict_detector
m_data_port_occupied_cycles	gpu-cache.h	/^        int m_data_port_occupied_cycles; \/\/< Number of cycle that the data port remains used $/;"	m	class:baseline_cache::bandwidth_management
m_data_port_width	gpu-cache.h	/^    unsigned m_data_port_width; \/\/< number of byte the cache can access per cycle $/;"	m	class:cache_config
m_data_size	gpu-cache.h	/^        unsigned   m_data_size;$/;"	m	struct:tex_cache::fragment_entry
m_data_size	gpu-cache.h	/^        unsigned m_data_size;$/;"	m	struct:baseline_cache::extra_mf_fields
m_data_size	mem_fetch.h	/^   unsigned m_data_size; \/\/ how much data is being written$/;"	m	class:mem_fetch
m_delayed_fcd_cd_mode	commit_unit.cc	/^   unsigned int m_delayed_fcd_cd_mode;$/;"	m	class:commit_unit_options	file:
m_delayfcd_reads_checked	commit_unit.h	/^    unsigned m_delayfcd_reads_checked; \/\/ number of reads checked against CD table$/;"	m	class:commit_entry
m_delayfcd_writes_stored	commit_unit.h	/^    unsigned m_delayfcd_writes_stored; \/\/ number of writes written to CD table$/;"	m	class:commit_entry
m_detect_conflicting_cid	commit_unit.cc	/^   bool m_detect_conflicting_cid; $/;"	m	class:commit_unit_options	file:
m_directory_full	coherence_manager.h	/^	std::map<new_addr_type, coherence_directory_block_t*> m_directory_full;$/;"	m	class:coherence_manager
m_dirty	gpu-cache.h	/^    bool             m_dirty; $/;"	m	struct:cache_block_t
m_disabled	gpu-cache.h	/^    bool m_disabled;$/;"	m	class:cache_config
m_dispatch_port	shader.h	/^    std::vector<pipeline_stage_name_t> m_dispatch_port;$/;"	m	class:shader_core_ctx
m_dispatch_reg	shader.h	/^    warp_inst_t *m_dispatch_reg;$/;"	m	class:simd_function_unit
m_dispatch_units	shader.h	/^   std::vector<dispatch_unit_t> m_dispatch_units;$/;"	m	class:opndcoll_rfu_t
m_distance_fcd_pass	commit_unit.cc	/^   pow2_histogram m_distance_fcd_pass;$/;"	m	class:commit_unit_stats	file:
m_distance_retire_head	commit_unit.cc	/^   pow2_histogram m_distance_retire_head; $/;"	m	class:commit_unit_stats	file:
m_done	shader.h	/^         bool m_done; $/;"	m	class:tx_log_walker::iwcd_uarch_info::uarch_event
m_done_exit	shader.h	/^    bool m_done_exit; \/\/ true once thread exit has been registered for threads in this warp$/;"	m	class:shd_warp_t
m_dram	dram_sched.h	/^   dram_t *m_dram;$/;"	m	class:frfcfs_scheduler
m_dram	l2cache.h	/^   class dram_t *m_dram;$/;"	m	class:memory_partition_unit	typeref:class:memory_partition_unit::dram_t
m_dram_L2_queue	l2cache.h	/^   fifo_pipeline<mem_fetch> *m_dram_L2_queue;$/;"	m	class:memory_sub_partition
m_dram_latency_queue	l2cache.h	/^   std::list<dram_delay_t> m_dram_latency_queue;$/;"	m	class:memory_partition_unit
m_dummy_mode	commit_unit.cc	/^   bool m_dummy_mode;$/;"	m	class:commit_unit_options	file:
m_dump_timestamps	commit_unit.cc	/^   bool m_dump_timestamps; $/;"	m	class:commit_unit_options	file:
m_dynamic_warp_id	shader.h	/^    unsigned m_dynamic_warp_id;$/;"	m	class:shader_core_ctx
m_dynamic_warp_id	shader.h	/^    unsigned m_dynamic_warp_id;$/;"	m	class:shd_warp_t
m_enable_tm_token	scoreboard.h	/^    bool m_enable_tm_token; $/;"	m	class:Scoreboard
m_entry_lifetime	commit_unit.cc	/^   pow2_histogram m_entry_lifetime; $/;"	m	class:commit_unit_stats	file:
m_event_q	shader.h	/^      std::list<uarch_event> m_event_q; $/;"	m	class:tx_log_walker::iwcd_uarch_info
m_executed_kernel_names	gpu-sim.h	/^   std::vector<std::string> m_executed_kernel_names; \/\/< names of kernel for stat printout $/;"	m	class:gpgpu_sim
m_executed_kernel_uids	gpu-sim.h	/^   std::vector<unsigned> m_executed_kernel_uids; \/\/< uids of kernel launches for stat printout$/;"	m	class:gpgpu_sim
m_extra_mf_fields	gpu-cache.h	/^    extra_mf_fields_lookup m_extra_mf_fields;$/;"	m	class:baseline_cache
m_extra_mf_fields	gpu-cache.h	/^    extra_mf_fields_lookup m_extra_mf_fields;$/;"	m	class:tex_cache
m_extra_mf_fields	shader.h	/^   extra_mf_fields_lookup m_extra_mf_fields; $/;"	m	class:tx_log_walker
m_fail	commit_unit.h	/^    bool m_fail; $/;"	m	class:commit_entry
m_fail_at_revalidation	commit_unit.cc	/^   bool m_fail_at_revalidation;$/;"	m	class:commit_unit_options	file:
m_fast_match	commit_unit.cc	/^   bool m_fast_match; $/;"	m	class:commit_unit_options	file:
m_fcd_mode	commit_unit.cc	/^   unsigned int m_fcd_mode;$/;"	m	class:commit_unit_options	file:
m_fill_port_occupied_cycles	gpu-cache.h	/^        int m_fill_port_occupied_cycles; \/\/< Number of cycle that the fill port remains used $/;"	m	class:baseline_cache::bandwidth_management
m_fill_time	commit_unit.cc	/^   pow2_histogram m_fill_time;$/;"	m	class:commit_unit_stats	file:
m_fill_time	commit_unit.h	/^    unsigned m_fill_time; $/;"	m	class:commit_entry
m_fill_time	gpu-cache.h	/^    unsigned         m_fill_time;$/;"	m	struct:cache_block_t
m_final_pass	commit_unit.h	/^    bool m_final_pass;$/;"	m	class:commit_entry
m_finish_commit_q	shader.h	/^   std::list<warp_inst_t> m_finish_commit_q; $/;"	m	class:tx_log_walker
m_finished_kernel	gpu-sim.h	/^   std::list<unsigned> m_finished_kernel;$/;"	m	class:gpgpu_sim
m_fragment_fifo	gpu-cache.h	/^    fifo<fragment_entry>    m_fragment_fifo;$/;"	m	class:tex_cache
m_fragment_fifo_entries	gpu-cache.h	/^        unsigned m_fragment_fifo_entries;$/;"	m	union:cache_config::__anon2
m_free	shader.h	/^      bool m_free;$/;"	m	class:opndcoll_rfu_t::collector_unit_t
m_frfcfs_scheduler	dram.h	/^   class frfcfs_scheduler* m_frfcfs_scheduler;$/;"	m	class:dram_t	typeref:class:dram_t::frfcfs_scheduler
m_fu	shader.h	/^    std::vector<simd_function_unit*> m_fu; \/\/ stallable pipelines should be last in this array$/;"	m	class:shader_core_ctx
m_full_line_mask	gpu-cache.h	/^    mem_access_byte_mask_t m_full_line_mask; $/;"	m	class:cache_config
m_g_tm_token_cnt	scoreboard.cc	/^   unsigned m_g_tm_token_cnt;  \/\/ number of TM tokens across the GPU $/;"	m	class:scoreboard_options	file:
m_gen_L2_acc	commit_unit.cc	/^   int m_gen_L2_acc; $/;"	m	class:commit_unit_options	file:
m_gpgpusim_wrapper	gpu-sim.h	/^   class gpgpu_sim_wrapper *m_gpgpusim_wrapper;$/;"	m	class:gpgpu_sim	typeref:class:gpgpu_sim::gpgpu_sim_wrapper
m_gpu	shader.h	/^    gpgpu_sim *m_gpu;$/;"	m	class:simt_core_cluster
m_h3mask	gpu-cache.h	/^    std::vector<new_addr_type> m_h3mask; $/;"	m	class:cache_config
m_has_atomic	gpu-cache.h	/^        bool m_has_atomic; $/;"	m	struct:mshr_table::mshr_entry
m_hazard_detection_read_done_mask	commit_unit.h	/^   active_mask_t m_hazard_detection_read_done_mask; $/;"	m	class:warp_commit_entry
m_hazard_detection_write_done_mask	commit_unit.h	/^   active_mask_t m_hazard_detection_write_done_mask; $/;"	m	class:warp_commit_entry
m_head	delayqueue.h	/^   fifo_data<T> *m_head;$/;"	m	class:fifo_pipeline
m_head	gpu-cache.h	/^        unsigned   m_head; \/\/ next entry goes here$/;"	m	class:tex_cache::fifo
m_history_file	shader.h	/^   history_file_t m_history_file; $/;"	m	class:opndcoll_rfu_t
m_ibuffer	shader.h	/^    ibuffer_entry m_ibuffer[IBUFFER_SIZE]; $/;"	m	class:shd_warp_t
m_icnt	shader.h	/^    mem_fetch_interface *m_icnt;$/;"	m	class:shader_core_ctx
m_icnt	shader.h	/^   class mem_fetch_interface *&m_icnt;$/;"	m	class:ldst_unit	typeref:class:ldst_unit::mem_fetch_interface
m_icnt	shader.h	/^   class mem_fetch_interface *&m_icnt;$/;"	m	class:tx_log_walker	typeref:class:tx_log_walker::mem_fetch_interface
m_icnt_L2_queue	l2cache.h	/^   fifo_pipeline<mem_fetch> *m_icnt_L2_queue;$/;"	m	class:memory_sub_partition
m_icnt_receive_time	mem_fetch.h	/^   unsigned m_icnt_receive_time; \/\/ set to gpu_sim_cycle + interconnect_latency when fixed icnt latency mode is enabled$/;"	m	class:mem_fetch
m_id	l2cache.h	/^   unsigned m_id;  \/\/< the global sub partition ID$/;"	m	class:memory_sub_partition
m_id	l2cache.h	/^   unsigned m_id;$/;"	m	class:memory_partition_unit
m_id	shader.h	/^    int m_id;$/;"	m	class:scheduler_unit
m_id	stat-tool.h	/^   int m_id;$/;"	m	class:insn_warp_occ_logger
m_id	stat-tool.h	/^   int m_id;$/;"	m	class:linear_histogram_logger
m_ideal_L2_commit	commit_unit.cc	/^   bool m_ideal_L2_commit; $/;"	m	class:commit_unit_options	file:
m_ideal_L2_validation	commit_unit.cc	/^   bool m_ideal_L2_validation; $/;"	m	class:commit_unit_options	file:
m_imiss_pending	shader.h	/^    bool m_imiss_pending;$/;"	m	class:shd_warp_t
m_in	shader.h	/^       port_vector_t m_in,m_out;$/;"	m	class:opndcoll_rfu_t::input_port_t
m_in_pipeline	shader.h	/^   int m_in_pipeline;$/;"	m	class:thread_ctx_t
m_in_ports	shader.h	/^   std::vector<input_port_t> m_in_ports;$/;"	m	class:opndcoll_rfu_t
m_in_rollback	shader.h	/^   bool m_in_rollback; $/;"	m	class:history_file_t
m_in_tx_commit	scoreboard.h	/^    std::vector<bool> m_in_tx_commit; \/\/ track which warp is currently committing$/;"	m	class:Scoreboard
m_incoming_traffic_stats	shader.h	/^    traffic_breakdown *m_incoming_traffic_stats; \/\/ memory partition to core $/;"	m	class:shader_core_stats
m_index	gpu-cache.h	/^        unsigned m_index; \/\/ where in cache should block be placed?$/;"	m	struct:tex_cache::rob_entry
m_infinite_table	shader.cc	/^   tr1_hash_map<addr_t, int> m_infinite_table; $/;"	m	class:ownership_table	file:
m_inflight_mem_accesses	shader.h	/^   unsigned m_inflight_mem_accesses;$/;"	m	class:thread_ctx_t
m_initialized	shader.h	/^   bool m_initialized;$/;"	m	class:opndcoll_rfu_t
m_inner_level_prioritization	shader.h	/^    scheduler_prioritization_type m_inner_level_prioritization;$/;"	m	class:two_level_active_scheduler
m_input_queue	commit_unit.h	/^    std::list<mem_fetch*> m_input_queue; \/\/ input messages $/;"	m	class:commit_unit
m_input_queue_length	commit_unit.cc	/^   unsigned int m_input_queue_length;$/;"	m	class:commit_unit_options	file:
m_input_queue_size	commit_unit.cc	/^   pow2_histogram m_input_queue_size; $/;"	m	class:commit_unit_stats	file:
m_insn_span_count	stat-tool.h	/^   span_count_map m_insn_span_count;$/;"	m	class:thread_insn_span
m_insn_warp_occ	stat-tool.h	/^   std::vector<linear_histogram> m_insn_warp_occ;$/;"	m	class:insn_warp_occ_logger
m_inst	mem_fetch.h	/^   warp_inst_t m_inst;$/;"	m	class:mem_fetch
m_inst	shader.h	/^       const warp_inst_t *m_inst;$/;"	m	struct:shd_warp_t::ibuffer_entry
m_inst	shader.h	/^      warp_inst_t m_inst; $/;"	m	struct:tx_log_walker::warp_commit_tx_t
m_inst_fetch_buffer	shader.h	/^    ifetch_buffer_t           m_inst_fetch_buffer;$/;"	m	class:shader_core_ctx
m_inst_in_pipeline	shader.h	/^    unsigned m_inst_in_pipeline;$/;"	m	class:shd_warp_t
m_intra_warp_aborts	shader.cc	/^   linear_histogram m_intra_warp_aborts; $/;"	m	class:tx_log_walker_stats	file:
m_intra_warp_cd_cycle	shader.cc	/^   std::map<int,unsigned> m_intra_warp_cd_cycle; $/;"	m	class:tx_log_walker_stats	file:
m_intra_warp_cd_cycle_pending	shader.h	/^      int m_intra_warp_cd_cycle_pending; \/\/ approx model for intra warp cd overhead$/;"	m	struct:tx_log_walker::warp_commit_tx_t
m_intra_warp_cd_cycle_per_warp	shader.cc	/^   pow2_histogram m_intra_warp_cd_cycle_per_warp; $/;"	m	class:tx_log_walker_stats	file:
m_intra_warp_cd_warps	shader.h	/^   std::set<int> m_intra_warp_cd_warps; \/\/ warp currently doing intra warp conflict detection $/;"	m	class:tx_log_walker_warpc
m_intra_warp_pre_cd_active	shader.cc	/^   linear_histogram m_intra_warp_pre_cd_active; $/;"	m	class:tx_log_walker_stats	file:
m_invalidate_count	tm_conflict_detector.h	/^    unsigned m_invalidate_count; \/\/ number of invaliate acks to wait for before updating nstid$/;"	m	class:tm_conflict_detector
m_is_aborted	mem_fetch.h	/^   bool m_is_aborted;$/;"	m	class:mem_fetch
m_is_stalled	mem_fetch.h	/^   bool m_is_stalled;$/;"	m	class:mem_fetch
m_is_transaction_dst	shader.h	/^      bool m_is_transaction_dst; $/;"	m	class:opndcoll_rfu_t::op_t
m_issue_port	shader.h	/^    std::vector<pipeline_stage_name_t> m_issue_port;$/;"	m	class:shader_core_ctx
m_issued_inflight_insn	scoreboard.h	/^    std::vector<int> m_issued_inflight_insn;$/;"	m	class:Scoreboard
m_iwcd_uarch_info	shader.h	/^      iwcd_uarch_info m_iwcd_uarch_info; \/\/ info for intra warp cd timing model $/;"	m	struct:tx_log_walker::warp_commit_tx_t
m_last_access_time	coherence_manager.h	/^    unsigned         m_last_access_time;$/;"	m	struct:coherence_cache_block_t
m_last_access_time	coherence_manager.h	/^    unsigned        m_last_access_time;$/;"	m	struct:coherence_directory_block_t
m_last_access_time	gpu-cache.h	/^    unsigned         m_last_access_time;$/;"	m	struct:cache_block_t
m_last_borrower	l2cache.h	/^      int m_last_borrower; $/;"	m	class:memory_partition_unit::arbitration_metadata
m_last_cluster_issue	gpu-sim.h	/^   unsigned m_last_cluster_issue;$/;"	m	class:gpgpu_sim
m_last_cu	shader.h	/^      unsigned  m_last_cu; \/\/ first cu to check while arb-ing banks (rr)$/;"	m	class:opndcoll_rfu_t::arbiter_t
m_last_cu	shader.h	/^      unsigned m_last_cu; \/\/ dispatch ready cu's rr$/;"	m	class:opndcoll_rfu_t::dispatch_unit_t
m_last_fetch	shader.h	/^    unsigned long long m_last_fetch;$/;"	m	class:shd_warp_t
m_last_inst_gpu_sim_cycle	shader.h	/^    unsigned long long m_last_inst_gpu_sim_cycle;$/;"	m	class:shader_core_ctx
m_last_inst_gpu_sim_cycle	shader.h	/^   unsigned long long m_last_inst_gpu_sim_cycle;$/;"	m	class:ldst_unit
m_last_inst_gpu_tot_sim_cycle	shader.h	/^    unsigned long long m_last_inst_gpu_tot_sim_cycle;$/;"	m	class:shader_core_ctx
m_last_inst_gpu_tot_sim_cycle	shader.h	/^   unsigned long long m_last_inst_gpu_tot_sim_cycle;$/;"	m	class:ldst_unit
m_last_issued_kernel	gpu-sim.h	/^   unsigned m_last_issued_kernel;$/;"	m	class:gpgpu_sim
m_last_num_sim_insn	shader.h	/^	unsigned *m_last_num_sim_insn;$/;"	m	struct:shader_core_stats_pod
m_last_num_sim_winsn	shader.h	/^	unsigned *m_last_num_sim_winsn;$/;"	m	struct:shader_core_stats_pod
m_last_req_queue	l2cache.h	/^   unsigned m_last_req_queue;$/;"	m	class:memory_sub_partition
m_last_request_uid	mem_fetch.h	/^   unsigned m_last_request_uid; \/\/ for debugging dangling pointers $/;"	m	class:mem_fetch
m_last_row	dram_sched.h	/^   std::list<std::list<dram_req_t*>::iterator>                 **m_last_row;$/;"	m	class:frfcfs_scheduler
m_last_shader_dynamic_warp_issue_distro	shader.h	/^    std::vector<unsigned> m_last_shader_dynamic_warp_issue_distro;$/;"	m	class:shader_core_stats
m_last_shader_warp_slot_issue_distro	shader.h	/^    std::vector<unsigned> m_last_shader_warp_slot_issue_distro;$/;"	m	class:shader_core_stats
m_last_supervised_issued	shader.h	/^    std::vector< shd_warp_t* >::const_iterator m_last_supervised_issued;$/;"	m	class:scheduler_unit
m_last_warp_fetched	shader.h	/^    int  m_last_warp_fetched;$/;"	m	class:shader_core_ctx
m_ldst_unit	shader.h	/^    ldst_unit *m_ldst_unit;$/;"	m	class:shader_core_ctx
m_length	delayqueue.h	/^   unsigned int m_length;$/;"	m	class:fifo_pipeline
m_lin_hist_archive	stat-tool.h	/^   std::list<linear_histogram_snapshot> m_lin_hist_archive;$/;"	m	class:linear_histogram_logger
m_line_sz	gpu-cache.h	/^    unsigned m_line_sz;$/;"	m	class:cache_config
m_line_sz_log2	gpu-cache.h	/^    unsigned m_line_sz_log2;$/;"	m	class:cache_config
m_linear_buffer	commit_unit.h	/^    linear_buffer_t m_linear_buffer;$/;"	m	class:cu_access_set
m_linear_buffer_limit	commit_unit.h	/^    int m_linear_buffer_limit; $/;"	m	class:cu_access_set
m_linear_histogram	stat-tool.h	/^   std::vector<int> m_linear_histogram;$/;"	m	class:linear_histogram_snapshot
m_lines	coherence_manager.h	/^    coherence_cache_block_t *m_lines; \/* nset x assoc lines in total *\/$/;"	m	class:coherence_tag_array
m_lines	commit_unit.h	/^   conflict_table_hash_entry* m_lines;$/;"	m	class:conflict_table_hash
m_lines	gpu-cache.h	/^    cache_block_t *m_lines; \/* nbanks x nset x assoc lines in total *\/$/;"	m	class:tag_array
m_list	gpu-cache.h	/^        std::list<mem_fetch*> m_list;$/;"	m	struct:mshr_table::mshr_entry
m_local_write_misses	gpu-cache.h	/^    unsigned m_local_write_misses;$/;"	m	class:cache_stats
m_local_write_misses_full_cacheline	gpu-cache.h	/^    unsigned m_local_write_misses_full_cacheline;$/;"	m	class:cache_stats
m_log_type	shader.h	/^       enum log_acc_type_t m_log_type;$/;"	m	struct:tx_log_walker::extra_mf_fields	typeref:enum:tx_log_walker::extra_mf_fields::log_acc_type_t
m_marked	tm_conflict_detector.h	/^        bool m_marked;$/;"	m	struct:tm_conflict_detector::blk_info
m_max_active_warps	shader.h	/^	unsigned m_max_active_warps;$/;"	m	class:two_level_active_scheduler
m_max_commit_id	commit_unit.h	/^   int m_max_commit_id; $/;"	m	class:warp_commit_entry
m_max_commit_id_with_skip	commit_unit.h	/^   int m_max_commit_id_with_skip; $/;"	m	class:warp_commit_entry
m_max_cta_per_core	shader.h	/^   unsigned m_max_cta_per_core;$/;"	m	class:barrier_set_t
m_max_len	delayqueue.h	/^   unsigned int m_max_len;$/;"	m	class:fifo_pipeline
m_max_merged	gpu-cache.h	/^    const unsigned m_max_merged;$/;"	m	class:mshr_table
m_max_warps_per_core	shader.h	/^   unsigned m_max_warps_per_core;$/;"	m	class:barrier_set_t
m_maximum	histogram.h	/^   int m_maximum;      \/\/ the maximum sample$/;"	m	class:binned_histogram
m_mem_config	mem_fetch.h	/^   const class memory_config *m_mem_config;$/;"	m	class:mem_fetch	typeref:class:mem_fetch::memory_config
m_mem_config	power_stat.h	/^   const struct memory_config *m_mem_config;$/;"	m	class:power_stat_t	typeref:struct:power_stat_t::memory_config
m_mem_fetch_allocator	shader.h	/^    shader_core_mem_fetch_allocator *m_mem_fetch_allocator;$/;"	m	class:shader_core_ctx
m_mem_out	shader.h	/^    register_set* m_mem_out;$/;"	m	class:scheduler_unit
m_mem_rc	shader.h	/^   enum mem_stage_stall_type m_mem_rc;$/;"	m	class:ldst_unit	typeref:enum:ldst_unit::mem_stage_stall_type
m_mem_stats	power_stat.h	/^   memory_stats_t *m_mem_stats;$/;"	m	class:power_mem_stat_t
m_membar	shader.h	/^    bool     m_membar;             \/\/ if true, warp is waiting at memory barrier$/;"	m	class:shd_warp_t
m_memfetch_creator	gpu-cache.h	/^    mem_fetch_allocator *m_memfetch_creator;$/;"	m	class:data_cache
m_memory_config	commit_unit.cc	/^   const memory_config *m_memory_config;$/;"	m	class:commit_unit_mf_allocator	file:
m_memory_config	commit_unit.h	/^    const memory_config *m_memory_config;$/;"	m	class:commit_unit
m_memory_config	gpu-sim.h	/^    memory_config m_memory_config;$/;"	m	class:gpgpu_sim_config
m_memory_config	gpu-sim.h	/^   const struct memory_config      *m_memory_config;$/;"	m	class:gpgpu_sim	typeref:struct:gpgpu_sim::memory_config
m_memory_config	l2cache.h	/^    const memory_config *m_memory_config;$/;"	m	class:partition_mf_allocator
m_memory_config	mem_latency_stat.h	/^   const struct memory_config *m_memory_config;$/;"	m	class:memory_stats_t	typeref:struct:memory_stats_t::memory_config
m_memory_config	shader.h	/^    const memory_config *m_memory_config;$/;"	m	class:shader_core_ctx
m_memory_config	shader.h	/^    const memory_config *m_memory_config;$/;"	m	class:shader_core_mem_fetch_allocator
m_memory_config	shader.h	/^   const memory_config *m_memory_config; $/;"	m	class:tx_log_walker
m_memory_config	shader.h	/^   const memory_config *m_memory_config;$/;"	m	class:ldst_unit
m_memory_partition_unit	dram.h	/^   class memory_partition_unit *m_memory_partition_unit;$/;"	m	class:dram_t	typeref:class:dram_t::memory_partition_unit
m_memory_partition_unit	gpu-sim.h	/^   class memory_partition_unit **m_memory_partition_unit;$/;"	m	class:gpgpu_sim	typeref:class:gpgpu_sim::memory_partition_unit
m_memory_stats	gpu-sim.h	/^   class memory_stats_t     *m_memory_stats;$/;"	m	class:gpgpu_sim	typeref:class:gpgpu_sim::memory_stats_t
m_memory_stats	shader.h	/^    memory_stats_t *m_memory_stats;$/;"	m	class:simt_core_cluster
m_memory_sub_partition	gpu-sim.h	/^   class memory_sub_partition **m_memory_sub_partition;$/;"	m	class:gpgpu_sim	typeref:class:gpgpu_sim::memory_sub_partition
m_memport	gpu-cache.h	/^    mem_fetch_interface    *m_memport;$/;"	m	class:tex_cache
m_memport	gpu-cache.h	/^    mem_fetch_interface *m_memport;$/;"	m	class:baseline_cache
m_metadata	shader.h	/^         unsigned m_metadata; \/\/ entry_id or smem access count$/;"	m	class:tx_log_walker::iwcd_uarch_info::uarch_event
m_mf_alloc	commit_unit.h	/^    commit_unit_mf_allocator *m_mf_alloc; \/\/ for generating L2 access $/;"	m	class:commit_unit
m_mf_alloc	shader.h	/^   mem_fetch_allocator *m_mf_alloc; $/;"	m	class:tx_log_walker
m_mf_allocator	l2cache.h	/^   partition_mf_allocator *m_mf_allocator;$/;"	m	class:memory_sub_partition
m_mf_allocator	shader.h	/^   shader_core_mem_fetch_allocator *m_mf_allocator;$/;"	m	class:ldst_unit
m_min_len	delayqueue.h	/^   unsigned int m_min_len;$/;"	m	class:fifo_pipeline
m_miss	gpu-cache.h	/^        bool       m_miss;        \/\/ true if sent memory request$/;"	m	struct:tex_cache::fragment_entry
m_miss	gpu-cache.h	/^    unsigned m_miss;$/;"	m	class:tag_array
m_miss_queue	gpu-cache.h	/^    std::list<mem_fetch*> m_miss_queue;$/;"	m	class:baseline_cache
m_miss_queue_size	gpu-cache.h	/^        unsigned m_miss_queue_size;$/;"	m	union:cache_config::__anon4
m_miss_queue_status	gpu-cache.h	/^    enum mem_fetch_status m_miss_queue_status;$/;"	m	class:baseline_cache	typeref:enum:baseline_cache::mem_fetch_status
m_mpid	commit_unit.h	/^    int m_mpid; $/;"	m	class:commit_entry
m_mshr_entries	gpu-cache.h	/^        unsigned m_mshr_entries;$/;"	m	union:cache_config::__anon2
m_mshr_max_merge	gpu-cache.h	/^        unsigned m_mshr_max_merge;$/;"	m	union:cache_config::__anon3
m_mshr_type	gpu-cache.h	/^    enum mshr_config_t m_mshr_type;$/;"	m	class:cache_config	typeref:enum:cache_config::mshr_config_t
m_mshrs	gpu-cache.h	/^    mshr_table m_mshrs;$/;"	m	class:baseline_cache
m_n_active_cta	shader.h	/^    unsigned m_n_active_cta; \/\/ number of Cooperative Thread Arrays (blocks) currently running on this shader.$/;"	m	class:shader_core_ctx
m_n_active_entries	commit_unit.h	/^    int m_n_active_entries; \/\/ entries that are between head and retire, not skipped or unused$/;"	m	class:commit_unit
m_n_active_entries_have_rs	commit_unit.h	/^    int m_n_active_entries_have_rs; \/\/ active entries that have a read-set$/;"	m	class:commit_unit
m_n_active_entries_have_ws	commit_unit.h	/^    int m_n_active_entries_have_ws; \/\/ active entries that have a write-set$/;"	m	class:commit_unit
m_n_active_entries_need_rs	commit_unit.h	/^    int m_n_active_entries_need_rs; \/\/ active entries that need a read-set (no RS needed after PASS\/FAIL)$/;"	m	class:commit_unit
m_n_active_entries_need_ws	commit_unit.h	/^    int m_n_active_entries_need_ws; \/\/ active entries that need a write-set (no WS needed after FAIL)$/;"	m	class:commit_unit
m_n_atomic	shader.h	/^    unsigned m_n_atomic;           \/\/ number of outstanding atomic operations $/;"	m	class:shd_warp_t
m_n_bins	stat-tool.h	/^   int m_n_bins;$/;"	m	class:linear_histogram_logger
m_n_channel	addrdec.h	/^   int m_n_channel;$/;"	m	class:linear_to_raw_address_translation
m_n_commit_write_pending	commit_unit.h	/^    int m_n_commit_write_pending; $/;"	m	class:commit_entry
m_n_commit_writes	commit_unit.h	/^    unsigned m_n_commit_writes;$/;"	m	class:commit_unit
m_n_commit_writes_processed	commit_unit.h	/^    unsigned m_n_commit_writes_processed;$/;"	m	class:commit_unit
m_n_diverge	shader.h	/^    unsigned *m_n_diverge;    \/\/ number of divergence occurring in this shader$/;"	m	struct:shader_core_stats_pod
m_n_element	delayqueue.h	/^   unsigned int m_n_element;$/;"	m	class:fifo_pipeline
m_n_hit	gpu-cache.h	/^    mutable unsigned m_n_hit;       \/\/\/< number of access that hit an entry in the mshr $/;"	m	class:mshr_table
m_n_hit_ready	gpu-cache.h	/^    mutable unsigned m_n_hit_ready; \/\/\/< number of access that hit a ready entry in the mshr $/;"	m	class:mshr_table
m_n_input_pkt_processed	commit_unit.h	/^    unsigned m_n_input_pkt_processed; $/;"	m	class:commit_unit
m_n_logical_tm_req	shader.h	/^    unsigned m_n_logical_tm_req;   \/\/ number of outstanding logical tm requeist$/;"	m	class:shd_warp_t
m_n_logical_tm_req_per_thread	shader.h	/^    std::vector<unsigned> m_n_logical_tm_req_per_thread;$/;"	m	class:shd_warp_t
m_n_mem	gpu-sim.h	/^   unsigned m_n_mem;$/;"	m	struct:memory_config
m_n_mem_sub_partition	gpu-sim.h	/^   unsigned m_n_mem_sub_partition;$/;"	m	struct:memory_config
m_n_probe	gpu-cache.h	/^    mutable unsigned m_n_probe;     \/\/\/< number of query into mshr$/;"	m	class:mshr_table
m_n_recency_bf_activity	commit_unit.h	/^    unsigned m_n_recency_bf_activity; $/;"	m	class:commit_unit
m_n_reply_sent	commit_unit.h	/^    unsigned m_n_reply_sent; $/;"	m	class:commit_unit
m_n_revalidations	commit_unit.h	/^    unsigned m_n_revalidations; $/;"	m	class:commit_unit
m_n_shader	mem_latency_stat.h	/^   unsigned m_n_shader;$/;"	m	class:memory_stats_t
m_n_sub_partition_in_channel	addrdec.h	/^   int m_n_sub_partition_in_channel; $/;"	m	class:linear_to_raw_address_translation
m_n_sub_partition_per_memory_channel	gpu-sim.h	/^   unsigned m_n_sub_partition_per_memory_channel;$/;"	m	struct:memory_config
m_n_tm_tokens	scoreboard.h	/^    unsigned m_n_tm_tokens; \/\/ number of available tokens for TM $/;"	m	class:Scoreboard
m_n_tx_done_fill	commit_unit.h	/^    unsigned m_n_tx_done_fill;$/;"	m	class:commit_unit
m_n_tx_fail	commit_unit.h	/^    unsigned m_n_tx_fail; $/;"	m	class:commit_unit
m_n_tx_pass	commit_unit.h	/^    unsigned m_n_tx_pass; $/;"	m	class:commit_unit
m_n_tx_read_set	commit_unit.h	/^    unsigned m_n_tx_read_set; $/;"	m	class:commit_unit
m_n_tx_skip	commit_unit.h	/^    unsigned m_n_tx_skip;$/;"	m	class:commit_unit
m_n_tx_write_set	commit_unit.h	/^    unsigned m_n_tx_write_set; $/;"	m	class:commit_unit
m_n_validation_pending	commit_unit.h	/^    int m_n_validation_pending; $/;"	m	class:commit_entry
m_n_validations	commit_unit.h	/^    unsigned m_n_validations; $/;"	m	class:commit_unit
m_n_validations_processed	commit_unit.h	/^    unsigned m_n_validations_processed; $/;"	m	class:commit_unit
m_name	commit_unit.cc	/^      std::string m_name;$/;"	m	struct:commit_unit_stats::cid_pointer_stats	file:
m_name	delayqueue.h	/^   const char* m_name;$/;"	m	class:fifo_pipeline
m_name	gpu-cache.h	/^    std::string m_name;$/;"	m	class:baseline_cache
m_name	gpu-cache.h	/^    std::string m_name;$/;"	m	class:tex_cache
m_name	histogram.h	/^   std::string m_name;$/;"	m	class:binned_histogram
m_name	shader.h	/^    std::string m_name;$/;"	m	class:simd_function_unit
m_name	shader.h	/^   std::string m_name;$/;"	m	struct:thread_state_stat
m_name	stat-tool.h	/^   std::string m_name;$/;"	m	class:linear_histogram_logger
m_name	stat-tool.h	/^   std::string m_name;$/;"	m	class:thread_CFlocality
m_nbins	histogram.h	/^   int m_nbins;$/;"	m	class:binned_histogram
m_nbytes	shader.h	/^    unsigned m_nbytes;$/;"	m	struct:ifetch_buffer_t
m_network_name	traffic_breakdown.h	/^   std::string m_network_name; $/;"	m	class:traffic_breakdown
m_next	delayqueue.h	/^   fifo_data *m_next;$/;"	m	struct:fifo_data
m_next	shader.h	/^    unsigned m_next;$/;"	m	class:shd_warp_t
m_next_cu	shader.h	/^      unsigned m_next_cu;  \/\/ for initialization$/;"	m	class:opndcoll_rfu_t::dispatch_unit_t
m_next_cycle_prioritized_warps	shader.h	/^    std::vector< shd_warp_t* > m_next_cycle_prioritized_warps;$/;"	m	class:scheduler_unit
m_next_global	shader.h	/^   mem_fetch *m_next_global;$/;"	m	class:ldst_unit
m_next_pc	shader.h	/^    address_type m_next_pc;$/;"	m	class:shd_warp_t
m_next_tid	tm_conflict_detector.h	/^    unsigned m_next_tid;$/;"	m	class:tm_tid_vendor
m_next_wb	shader.h	/^   warp_inst_t m_next_wb;$/;"	m	class:ldst_unit
m_non_rf_operands	power_stat.h	/^    unsigned *m_non_rf_operands[NUM_STAT_IDX];$/;"	m	struct:shader_core_power_stats_pod
m_non_rf_operands	shader.h	/^    unsigned *m_non_rf_operands;$/;"	m	struct:shader_core_stats_pod
m_normal_icnt	shader.h	/^    mem_fetch_interface *m_normal_icnt;$/;"	m	class:shader_core_ctx
m_not_completed	shader.h	/^    unsigned m_not_completed; \/\/ number of threads to be completed (==0 when all thread on this core completed) $/;"	m	class:shader_core_ctx
m_not_ready	shader.h	/^      std::bitset<MAX_REG_OPERANDS*2> m_not_ready;$/;"	m	class:opndcoll_rfu_t::collector_unit_t
m_nset	gpu-cache.h	/^    unsigned m_nset;$/;"	m	class:cache_config
m_nset_log2	gpu-cache.h	/^    unsigned m_nset_log2;$/;"	m	class:cache_config
m_nsharers	coherence_manager.h	/^    unsigned        m_nsharers;$/;"	m	struct:coherence_directory_block_t
m_nstid	tm_conflict_detector.h	/^    unsigned m_nstid;$/;"	m	class:tm_conflict_detector
m_nthreads	coherence_manager.h	/^	unsigned m_nthreads;$/;"	m	class:coherence_manager
m_nthreads	stat-tool.h	/^   int m_nthreads;$/;"	m	class:thread_CFlocality
m_num	gpu-cache.h	/^        unsigned   m_num;  \/\/ how many in fifo?$/;"	m	class:tex_cache::fifo
m_num_FPdecoded_insn	power_stat.h	/^    unsigned *m_num_FPdecoded_insn[NUM_STAT_IDX]; \/\/ number of instructions committed by this shader core$/;"	m	struct:shader_core_power_stats_pod
m_num_FPdecoded_insn	shader.h	/^    unsigned *m_num_FPdecoded_insn;$/;"	m	struct:shader_core_stats_pod
m_num_INTdecoded_insn	power_stat.h	/^    unsigned *m_num_INTdecoded_insn[NUM_STAT_IDX]; \/\/ number of instructions committed by this shader core$/;"	m	struct:shader_core_power_stats_pod
m_num_INTdecoded_insn	shader.h	/^    unsigned *m_num_INTdecoded_insn;$/;"	m	struct:shader_core_stats_pod
m_num_banks	shader.h	/^      unsigned m_num_banks;$/;"	m	class:opndcoll_rfu_t::arbiter_t
m_num_banks	shader.h	/^      unsigned m_num_banks;$/;"	m	class:opndcoll_rfu_t::collector_unit_t
m_num_banks	shader.h	/^   unsigned m_num_banks;$/;"	m	class:opndcoll_rfu_t
m_num_collector_sets	shader.h	/^   unsigned m_num_collector_sets;$/;"	m	class:opndcoll_rfu_t
m_num_collectors	shader.h	/^      unsigned m_num_collectors;$/;"	m	class:opndcoll_rfu_t::arbiter_t
m_num_collectors	shader.h	/^      unsigned m_num_collectors;$/;"	m	class:opndcoll_rfu_t::dispatch_unit_t
m_num_decoded_insn	power_stat.h	/^    unsigned *m_num_decoded_insn[NUM_STAT_IDX]; \/\/ number of instructions committed by this shader core$/;"	m	struct:shader_core_power_stats_pod
m_num_decoded_insn	shader.h	/^    unsigned *m_num_decoded_insn; \/\/ number of instructions decoded by this shader core$/;"	m	struct:shader_core_stats_pod
m_num_entries	gpu-cache.h	/^    const unsigned m_num_entries;$/;"	m	class:mshr_table
m_num_fp_acesses	power_stat.h	/^    unsigned *m_num_fp_acesses[NUM_STAT_IDX];$/;"	m	struct:shader_core_power_stats_pod
m_num_fp_acesses	shader.h	/^    unsigned *m_num_fp_acesses;$/;"	m	struct:shader_core_stats_pod
m_num_fpdiv_acesses	power_stat.h	/^    unsigned *m_num_fpdiv_acesses[NUM_STAT_IDX];$/;"	m	struct:shader_core_power_stats_pod
m_num_fpdiv_acesses	shader.h	/^    unsigned *m_num_fpdiv_acesses;$/;"	m	struct:shader_core_stats_pod
m_num_fpmul_acesses	power_stat.h	/^    unsigned *m_num_fpmul_acesses[NUM_STAT_IDX];$/;"	m	struct:shader_core_power_stats_pod
m_num_fpmul_acesses	shader.h	/^    unsigned *m_num_fpmul_acesses;$/;"	m	struct:shader_core_stats_pod
m_num_function_units	shader.h	/^    unsigned m_num_function_units;$/;"	m	class:shader_core_ctx
m_num_ialu_acesses	power_stat.h	/^    unsigned *m_num_ialu_acesses[NUM_STAT_IDX];$/;"	m	struct:shader_core_power_stats_pod
m_num_ialu_acesses	shader.h	/^    unsigned *m_num_ialu_acesses;$/;"	m	struct:shader_core_stats_pod
m_num_idiv_acesses	power_stat.h	/^    unsigned *m_num_idiv_acesses[NUM_STAT_IDX];$/;"	m	struct:shader_core_power_stats_pod
m_num_idiv_acesses	shader.h	/^    unsigned *m_num_idiv_acesses;$/;"	m	struct:shader_core_stats_pod
m_num_imul24_acesses	power_stat.h	/^    unsigned *m_num_imul24_acesses[NUM_STAT_IDX];$/;"	m	struct:shader_core_power_stats_pod
m_num_imul24_acesses	shader.h	/^    unsigned *m_num_imul24_acesses;$/;"	m	struct:shader_core_stats_pod
m_num_imul32_acesses	power_stat.h	/^    unsigned *m_num_imul32_acesses[NUM_STAT_IDX];$/;"	m	struct:shader_core_power_stats_pod
m_num_imul32_acesses	shader.h	/^    unsigned *m_num_imul32_acesses;$/;"	m	struct:shader_core_stats_pod
m_num_imul_acesses	power_stat.h	/^    unsigned *m_num_imul_acesses[NUM_STAT_IDX];$/;"	m	struct:shader_core_power_stats_pod
m_num_imul_acesses	shader.h	/^    unsigned *m_num_imul_acesses;$/;"	m	struct:shader_core_stats_pod
m_num_loadqueued_insn	power_stat.h	/^    unsigned *m_num_loadqueued_insn[NUM_STAT_IDX];$/;"	m	struct:shader_core_power_stats_pod
m_num_loadqueued_insn	shader.h	/^    unsigned *m_num_loadqueued_insn;$/;"	m	struct:shader_core_stats_pod
m_num_mem_acesses	power_stat.h	/^    unsigned *m_num_mem_acesses[NUM_STAT_IDX];$/;"	m	struct:shader_core_power_stats_pod
m_num_mem_acesses	shader.h	/^    unsigned *m_num_mem_acesses;$/;"	m	struct:shader_core_stats_pod
m_num_mem_committed	power_stat.h	/^    unsigned *m_num_mem_committed[NUM_STAT_IDX];$/;"	m	struct:shader_core_power_stats_pod
m_num_mem_committed	shader.h	/^    unsigned *m_num_mem_committed;$/;"	m	struct:shader_core_stats_pod
m_num_pending	dram_sched.h	/^   unsigned m_num_pending;$/;"	m	class:frfcfs_scheduler
m_num_sfu_acesses	power_stat.h	/^    unsigned *m_num_sfu_acesses[NUM_STAT_IDX];$/;"	m	struct:shader_core_power_stats_pod
m_num_sfu_acesses	shader.h	/^    unsigned *m_num_sfu_acesses;$/;"	m	struct:shader_core_stats_pod
m_num_sfu_committed	power_stat.h	/^    unsigned *m_num_sfu_committed[NUM_STAT_IDX];$/;"	m	struct:shader_core_power_stats_pod
m_num_sfu_committed	shader.h	/^    unsigned *m_num_sfu_committed;$/;"	m	struct:shader_core_stats_pod
m_num_sim_insn	shader.h	/^    unsigned *m_num_sim_insn; \/\/ number of scalar thread instructions committed by this shader core$/;"	m	struct:shader_core_stats_pod
m_num_sim_winsn	shader.h	/^    unsigned *m_num_sim_winsn; \/\/ number of warp instructions committed by this shader core$/;"	m	struct:shader_core_stats_pod
m_num_sp_acesses	power_stat.h	/^    unsigned *m_num_sp_acesses[NUM_STAT_IDX];$/;"	m	struct:shader_core_power_stats_pod
m_num_sp_acesses	shader.h	/^    unsigned *m_num_sp_acesses;$/;"	m	struct:shader_core_stats_pod
m_num_sp_committed	power_stat.h	/^    unsigned *m_num_sp_committed[NUM_STAT_IDX];$/;"	m	struct:shader_core_power_stats_pod
m_num_sp_committed	shader.h	/^    unsigned *m_num_sp_committed;$/;"	m	struct:shader_core_stats_pod
m_num_storequeued_insn	power_stat.h	/^    unsigned *m_num_storequeued_insn[NUM_STAT_IDX];$/;"	m	struct:shader_core_power_stats_pod
m_num_storequeued_insn	shader.h	/^    unsigned *m_num_storequeued_insn;$/;"	m	struct:shader_core_stats_pod
m_num_tex_inst	power_stat.h	/^    unsigned *m_num_tex_inst[NUM_STAT_IDX];$/;"	m	struct:shader_core_power_stats_pod
m_num_tex_inst	shader.h	/^    unsigned *m_num_tex_inst;$/;"	m	struct:shader_core_stats_pod
m_num_tlb_accesses	shader.h	/^    unsigned *m_num_tlb_accesses;$/;"	m	struct:shader_core_stats_pod
m_num_tlb_hits	shader.h	/^    unsigned *m_num_tlb_hits;$/;"	m	struct:shader_core_stats_pod
m_num_total_req_queue	l2cache.h	/^   unsigned m_num_total_req_queue; $/;"	m	class:memory_sub_partition
m_num_trans_acesses	power_stat.h	/^    unsigned *m_num_trans_acesses[NUM_STAT_IDX];$/;"	m	struct:shader_core_power_stats_pod
m_num_trans_acesses	shader.h	/^    unsigned *m_num_trans_acesses;$/;"	m	struct:shader_core_stats_pod
m_num_warps_to_limit	shader.h	/^    unsigned m_num_warps_to_limit;$/;"	m	class:swl_scheduler
m_num_writeback_clients	shader.h	/^   unsigned m_num_writeback_clients;$/;"	m	class:ldst_unit
m_nvalidsharers	coherence_manager.h	/^    unsigned        m_nvalidsharers;$/;"	m	struct:coherence_directory_block_t
m_op	shader.h	/^      op_t m_op;$/;"	m	class:opndcoll_rfu_t::allocation_t
m_operand	shader.h	/^      unsigned  m_operand; \/\/ operand offset in instruction. e.g., add r1,r2,r3; r2 is oprd 0, r3 is 1 (r1 is dst)$/;"	m	class:opndcoll_rfu_t::op_t
m_operand_collector	shader.h	/^    opndcoll_rfu_t            m_operand_collector;$/;"	m	class:shader_core_ctx
m_operand_collector	shader.h	/^   opndcoll_rfu_t *m_operand_collector;$/;"	m	class:ldst_unit
m_out	shader.h	/^       port_vector_t m_in,m_out;$/;"	m	class:opndcoll_rfu_t::input_port_t
m_out_message_queue	shader.h	/^   std::list<mem_fetch*> m_out_message_queue; \/\/ outgoing message queue infinite size to simplify timing $/;"	m	class:tx_log_walker
m_out_message_queue_size	shader.cc	/^   pow2_histogram m_out_message_queue_size; $/;"	m	class:tx_log_walker_stats	file:
m_out_txreply_queue	shader.h	/^   std::list<mem_fetch*> m_out_txreply_queue; \/\/ prioritized outgoing message queue for TX_FAIL or TX_PASS$/;"	m	class:tx_log_walker
m_out_txreply_queue_size	shader.cc	/^   pow2_histogram m_out_txreply_queue_size; $/;"	m	class:tx_log_walker_stats	file:
m_outer_level_prioritization	shader.h	/^    scheduler_prioritization_type m_outer_level_prioritization;$/;"	m	class:two_level_active_scheduler
m_outgoing_traffic_stats	shader.h	/^    traffic_breakdown *m_outgoing_traffic_stats; \/\/ core to memory partitions$/;"	m	class:shader_core_stats
m_output_register	shader.h	/^      register_set* m_output_register; \/\/ pipeline register to issue to when ready$/;"	m	class:opndcoll_rfu_t::collector_unit_t
m_overclock_hazard_detect	commit_unit.cc	/^   unsigned int m_overclock_hazard_detect; $/;"	m	class:commit_unit_options	file:
m_overflow_core	tm_conflict_detector.h	/^    unsigned m_overflow_core;$/;"	m	class:tm_tid_vendor
m_overflow_req	tm_conflict_detector.h	/^    mem_fetch *m_overflow_req;$/;"	m	class:tm_tid_vendor
m_overflow_state	tm_conflict_detector.h	/^    bool m_overflow_state;$/;"	m	class:tm_tid_vendor
m_ownership_aliasing_depth_avg	shader.cc	/^   pow2_histogram m_ownership_aliasing_depth_avg; $/;"	m	class:tx_log_walker_stats	file:
m_ownership_aliasing_depth_max	shader.cc	/^   pow2_histogram m_ownership_aliasing_depth_max; $/;"	m	class:tx_log_walker_stats	file:
m_ownership_aliasing_depth_usage	shader.cc	/^   pow2_histogram m_ownership_aliasing_depth_usage; $/;"	m	class:tx_log_walker_stats	file:
m_ownership_table_size	shader.cc	/^   pow2_histogram m_ownership_table_size; $/;"	m	class:tx_log_walker_stats	file:
m_parallel_process_coalesced_input	commit_unit.cc	/^   bool m_parallel_process_coalesced_input; $/;"	m	class:commit_unit_options	file:
m_partition_addr	mem_fetch.h	/^   new_addr_type m_partition_addr; \/\/ linear physical address *within* dram partition (partition bank select bits squeezed out)$/;"	m	class:mem_fetch
m_partition_id	commit_unit.h	/^    unsigned m_partition_id;$/;"	m	class:commit_unit
m_partition_id	tm_conflict_detector.h	/^    unsigned m_partition_id;$/;"	m	class:tm_conflict_detector
m_pass	shader.h	/^      bool m_pass;  \/\/ did the tx pass validation?$/;"	m	struct:tx_log_walker::commit_tx_t
m_pass_fail_time	commit_unit.cc	/^   pow2_histogram m_pass_fail_time; $/;"	m	class:commit_unit_stats	file:
m_pass_fail_time	commit_unit.h	/^    unsigned m_pass_fail_time;$/;"	m	class:commit_entry
m_pc	shader.h	/^    address_type m_pc;$/;"	m	struct:ifetch_buffer_t
m_pending_cu_alloc	shader.h	/^      commit_unit_reply_t m_pending_cu_alloc;$/;"	m	struct:tx_log_walker::commit_tx_t
m_pending_cu_reply	shader.h	/^      commit_unit_reply_t m_pending_cu_reply;$/;"	m	struct:tx_log_walker::commit_tx_t
m_pending_fills	gpu-cache.h	/^    int              m_pending_fills; \/\/ when a single cache line needs to be filled by multiple fetches (TM only)$/;"	m	struct:cache_block_t
m_pending_hit	gpu-cache.h	/^    unsigned m_pending_hit; \/\/ number of cache miss that hit a line that is allocated but not filled$/;"	m	class:tag_array
m_pending_warps	shader.h	/^	std::deque< shd_warp_t* > m_pending_warps; $/;"	m	class:two_level_active_scheduler
m_pending_writes	shader.h	/^   std::map<unsigned\/*warp_id*\/, std::map<unsigned\/*regnum*\/,unsigned\/*count*\/> > m_pending_writes;$/;"	m	class:ldst_unit
m_perfect_icnt	shader.h	/^    mem_fetch_interface *m_perfect_icnt;$/;"	m	class:shader_core_ctx
m_pipeline_depth	shader.h	/^    unsigned m_pipeline_depth;$/;"	m	class:pipelined_simd_unit
m_pipeline_duty_cycle	power_stat.h	/^    float *m_pipeline_duty_cycle[NUM_STAT_IDX];$/;"	m	struct:shader_core_power_stats_pod
m_pipeline_duty_cycle	shader.h	/^    float *m_pipeline_duty_cycle;$/;"	m	struct:shader_core_stats_pod
m_pipeline_reg	shader.h	/^    std::vector<register_set> m_pipeline_reg;$/;"	m	class:shader_core_ctx
m_pipeline_reg	shader.h	/^    warp_inst_t **m_pipeline_reg;$/;"	m	class:pipelined_simd_unit
m_power_stats	gpu-sim.h	/^   class power_stat_t *m_power_stats;$/;"	m	class:gpgpu_sim	typeref:class:gpgpu_sim::power_stat_t
m_prev_snapshot_access	gpu-cache.h	/^    unsigned m_prev_snapshot_access;$/;"	m	class:tag_array
m_prev_snapshot_miss	gpu-cache.h	/^    unsigned m_prev_snapshot_miss;$/;"	m	class:tag_array
m_prev_snapshot_pending_hit	gpu-cache.h	/^    unsigned m_prev_snapshot_pending_hit;$/;"	m	class:tag_array
m_prioritization	shader.h	/^    scheduler_prioritization_type m_prioritization;$/;"	m	class:swl_scheduler
m_private_credit	l2cache.h	/^      std::vector<int> m_private_credit; $/;"	m	class:memory_partition_unit::arbitration_metadata
m_private_credit_limit	l2cache.h	/^      int m_private_credit_limit; $/;"	m	class:memory_partition_unit::arbitration_metadata
m_queue	dram_sched.h	/^   std::list<dram_req_t*>                                    *m_queue;$/;"	m	class:frfcfs_scheduler
m_queue	shader.h	/^      std::list<op_t> *m_queue;$/;"	m	class:opndcoll_rfu_t::arbiter_t
m_queue_size	tm_conflict_detector.h	/^    static const unsigned m_queue_size = 4;$/;"	m	class:tm_tid_vendor
m_raw_addr	mem_fetch.h	/^   addrdec_t m_raw_addr; \/\/ raw physical address (i.e., decoded DRAM chip-row-bank-column address)$/;"	m	class:mem_fetch
m_rd_hit	gpu-cache.h	/^        (data_cache::*m_rd_hit)( new_addr_type addr,$/;"	m	class:data_cache	typeref:enum:data_cache::m_rd_hit
m_rd_miss	gpu-cache.h	/^        (data_cache::*m_rd_miss)( new_addr_type addr,$/;"	m	class:data_cache	typeref:enum:data_cache::m_rd_miss
m_read_buffer_usage	commit_unit.cc	/^   pow2_histogram m_read_buffer_usage; $/;"	m	class:commit_unit_stats	file:
m_read_log_send_q	shader.h	/^      std::list<log_send_status_t> m_read_log_send_q; $/;"	m	struct:tx_log_walker::commit_tx_t
m_read_regfile_acesses	power_stat.h	/^    unsigned *m_read_regfile_acesses[NUM_STAT_IDX];$/;"	m	struct:shader_core_power_stats_pod
m_read_regfile_acesses	shader.h	/^    unsigned *m_read_regfile_acesses;$/;"	m	struct:shader_core_stats_pod
m_read_set	commit_unit.h	/^    cu_access_set m_read_set; $/;"	m	class:commit_entry
m_read_set	tm_conflict_detector.h	/^        std::bitset<MAX_CORES> m_read_set;$/;"	m	struct:tm_conflict_detector::blk_info
m_read_set_access_coalesced	commit_unit.cc	/^   unsigned long long m_read_set_access_coalesced;$/;"	m	class:commit_unit_stats	file:
m_read_set_access_raw	commit_unit.cc	/^   unsigned long long m_read_set_access_raw;$/;"	m	class:commit_unit_stats	file:
m_ready	gpu-cache.h	/^        bool m_ready;$/;"	m	struct:tex_cache::rob_entry
m_recognize_tx_load	gpu-cache.h	/^    bool m_recognize_tx_load;$/;"	m	class:l1_cache
m_register	shader.h	/^      unsigned  m_register;$/;"	m	class:opndcoll_rfu_t::op_t
m_register_set	shader.h	/^   std::vector< std::set<unsigned> > m_register_set; $/;"	m	class:history_file_t
m_replacement_policy	gpu-cache.h	/^    enum replacement_policy_t m_replacement_policy; \/\/ 'L' = LRU, 'F' = FIFO$/;"	m	class:cache_config	typeref:enum:cache_config::replacement_policy_t
m_reply_sent	commit_unit.h	/^    bool m_reply_sent; \/\/ to detect redundant replies $/;"	m	class:commit_entry
m_req_acks	tm_conflict_detector.h	/^    std::bitset<MAX_CORES> m_req_acks; \/\/ set to 1 when overflow start request sent, set to 0 when ack received$/;"	m	class:tm_tid_vendor
m_request	gpu-cache.h	/^        mem_fetch *m_request;     \/\/ request information$/;"	m	struct:tex_cache::fragment_entry
m_request	gpu-cache.h	/^        mem_fetch *m_request;$/;"	m	struct:tex_cache::rob_entry
m_request_fifo	gpu-cache.h	/^    fifo<mem_fetch*>        m_request_fifo;$/;"	m	class:tex_cache
m_request_fifo_entries	gpu-cache.h	/^        unsigned m_request_fifo_entries;$/;"	m	union:cache_config::__anon3
m_request_queue_status	gpu-cache.h	/^    enum mem_fetch_status   m_request_queue_status;$/;"	m	class:tex_cache	typeref:enum:tex_cache::mem_fetch_status
m_request_tracker	commit_unit.h	/^    std::set<mem_fetch*> &m_request_tracker; \/\/ tracking sent L2 access $/;"	m	class:commit_unit
m_request_tracker	l2cache.h	/^   std::set<mem_fetch*> m_request_tracker;$/;"	m	class:memory_sub_partition
m_request_uid	mem_fetch.h	/^   unsigned m_request_uid;$/;"	m	class:mem_fetch
m_requests	tm_conflict_detector.h	/^    std::list<mem_fetch*> m_requests;$/;"	m	class:tm_tid_vendor
m_res_fail	gpu-cache.h	/^    unsigned m_res_fail;$/;"	m	class:tag_array
m_reset_at_snap_shot	stat-tool.h	/^   bool m_reset_at_snap_shot;$/;"	m	class:linear_histogram_logger
m_response	tm_conflict_detector.h	/^    std::list<mem_fetch*> m_response;$/;"	m	class:tm_tid_vendor
m_response_fifo	shader.h	/^    std::list<mem_fetch*> m_response_fifo;$/;"	m	class:simt_core_cluster
m_response_fifo	shader.h	/^   std::list<mem_fetch*> m_response_fifo;$/;"	m	class:ldst_unit
m_response_port	commit_unit.h	/^    mem_fetch_interface *m_response_port;$/;"	m	class:commit_unit
m_response_port	tm_conflict_detector.h	/^    mem_fetch_interface *m_response_port;$/;"	m	class:tm_conflict_detector
m_response_queue	commit_unit.h	/^    std::list<mem_fetch*> m_response_queue; \/\/ reply messages generated$/;"	m	class:commit_unit
m_response_queue	tm_conflict_detector.h	/^    std::list<mem_fetch*> m_response_queue; \/\/ abort messages generated$/;"	m	class:tm_conflict_detector
m_response_queue_size	commit_unit.cc	/^   pow2_histogram m_response_queue_size; $/;"	m	class:commit_unit_stats	file:
m_response_ready	gpu-cache.h	/^        bool m_response_ready; $/;"	m	struct:mshr_table::mshr_entry
m_result_bus	shader.h	/^    std::vector< std::bitset<MAX_ALU_LATENCY>* > m_result_bus;$/;"	m	class:shader_core_ctx
m_result_fifo	gpu-cache.h	/^    fifo<mem_fetch*>        m_result_fifo; \/\/ next completed texture fetch$/;"	m	class:tex_cache
m_result_fifo_entries	gpu-cache.h	/^    unsigned m_result_fifo_entries;$/;"	m	class:cache_config
m_result_port	shader.h	/^    register_set *m_result_port;$/;"	m	class:pipelined_simd_unit
m_retire_ptr_at_fill	commit_unit.h	/^    int m_retire_ptr_at_fill; \/\/ where retire ptr was at first validation$/;"	m	class:commit_entry
m_retire_time	commit_unit.cc	/^   pow2_histogram m_retire_time;$/;"	m	class:commit_unit_stats	file:
m_retired_time	commit_unit.h	/^    unsigned m_retired_time;$/;"	m	class:commit_entry
m_retry_delay	shader.h	/^      unsigned long long m_retry_delay; \/\/ for throttling transaction retry $/;"	m	struct:tx_log_walker::warp_commit_tx_t
m_revalidate	commit_unit.h	/^    bool m_revalidate; $/;"	m	class:commit_entry
m_revalidate_set	commit_unit.h	/^    bool m_revalidate_set; \/\/ the revalidation flag was set $/;"	m	class:commit_entry
m_revalidation_distance	commit_unit.cc	/^   pow2_histogram m_revalidation_distance;$/;"	m	class:commit_unit_stats	file:
m_revalidation_table	commit_unit.h	/^    cu_revalidation_lookup m_revalidation_table; $/;"	m	class:commit_unit
m_revalidation_wait_time	commit_unit.cc	/^   pow2_histogram m_revalidation_wait_time;$/;"	m	class:commit_unit_stats	file:
m_revalidation_wait_time	commit_unit.h	/^    unsigned m_revalidation_wait_time;$/;"	m	class:commit_entry
m_rfu	shader.h	/^      opndcoll_rfu_t *m_rfu;$/;"	m	class:opndcoll_rfu_t::collector_unit_t
m_rob	gpu-cache.h	/^    fifo<rob_entry>         m_rob;$/;"	m	class:tex_cache
m_rob_entries	gpu-cache.h	/^        unsigned m_rob_entries;$/;"	m	union:cache_config::__anon4
m_rob_index	gpu-cache.h	/^        unsigned m_rob_index;$/;"	m	struct:tex_cache::extra_mf_fields
m_rob_status	gpu-cache.h	/^    enum mem_fetch_status   m_rob_status;$/;"	m	class:tex_cache	typeref:enum:tex_cache::mem_fetch_status
m_rop	l2cache.h	/^   std::queue<rop_delay_t> m_rop;$/;"	m	class:memory_sub_partition
m_rop2L2	commit_unit.h	/^    std::queue<rop_delay_t> &m_rop2L2; \/\/ modeling delay for L2 access $/;"	m	class:commit_unit
m_rop_latency	commit_unit.cc	/^   int m_rop_latency;$/;"	m	class:commit_unit_options	file:
m_running_kernels	gpu-sim.h	/^   std::vector<kernel_info_t*> m_running_kernels;$/;"	m	class:gpgpu_sim
m_scoreboard	shader.h	/^    Scoreboard               *m_scoreboard;$/;"	m	class:shader_core_ctx
m_scoreboard	shader.h	/^    Scoreboard* m_scoreboard; $/;"	m	class:scheduler_unit
m_scoreboard	shader.h	/^   Scoreboard *m_scoreboard;$/;"	m	class:ldst_unit
m_sent_cu_entry	shader.h	/^      commit_unit_reply_t m_sent_cu_entry; \/\/ which CU were sent a read or write log entry$/;"	m	struct:tx_log_walker::commit_tx_t
m_sent_icnt_traffic	commit_unit.h	/^    unsigned m_sent_icnt_traffic; $/;"	m	class:commit_unit
m_sent_icnt_traffic	shader.cc	/^   std::map<int,unsigned*> m_sent_icnt_traffic; $/;"	m	class:tx_log_walker_stats	file:
m_sent_icnt_traffic	shader.h	/^   unsigned m_sent_icnt_traffic; \/\/ amount of traffic sent from tx_log_walker, in flits $/;"	m	class:tx_log_walker
m_set_utility	gpu-cache.h	/^    std::vector<unsigned> m_set_utility; $/;"	m	class:cache_stats
m_sets	commit_unit.h	/^   unsigned m_sets;$/;"	m	class:conflict_table_hash
m_sfu_out	shader.h	/^    register_set* m_sfu_out;$/;"	m	class:scheduler_unit
m_shader	shader.h	/^    class shader_core_ctx *m_shader;$/;"	m	class:shd_warp_t	typeref:class:shd_warp_t::shader_core_ctx
m_shader	shader.h	/^    shader_core_ctx* m_shader;$/;"	m	class:scheduler_unit
m_shader	shader.h	/^   shader_core_ctx                 *m_shader;$/;"	m	class:opndcoll_rfu_t
m_shader_config	coherence_manager.h	/^	const shader_core_config *m_shader_config;$/;"	m	class:coherence_manager
m_shader_config	commit_unit.h	/^    const shader_core_config *m_shader_config;$/;"	m	class:commit_unit
m_shader_config	commit_unit.h	/^   const shader_core_config* m_shader_config;$/;"	m	class:conflict_table_hash
m_shader_config	gpu-sim.h	/^    shader_core_config m_shader_config;$/;"	m	class:gpgpu_sim_config
m_shader_config	gpu-sim.h	/^   const struct shader_core_config *m_shader_config;$/;"	m	class:gpgpu_sim	typeref:struct:gpgpu_sim::shader_core_config
m_shader_config	mem_latency_stat.h	/^   const struct shader_core_config *m_shader_config;$/;"	m	class:memory_stats_t	typeref:struct:memory_stats_t::shader_core_config
m_shader_config	tm_conflict_detector.h	/^    const shader_core_config *m_shader_config;$/;"	m	class:tm_conflict_detector
m_shader_config	tm_conflict_detector.h	/^    const shader_core_config *m_shader_config;$/;"	m	class:tm_tid_vendor
m_shader_dynamic_warp_issue_distro	shader.h	/^    std::vector< std::vector<unsigned> > m_shader_dynamic_warp_issue_distro;$/;"	m	class:shader_core_stats
m_shader_stats	gpu-sim.h	/^   class shader_core_stats  *m_shader_stats;$/;"	m	class:gpgpu_sim	typeref:class:gpgpu_sim::shader_core_stats
m_shader_warp_slot_issue_distro	shader.h	/^    std::vector< std::vector<unsigned> > m_shader_warp_slot_issue_distro;$/;"	m	class:shader_core_stats
m_shared_credit	l2cache.h	/^      int m_shared_credit; $/;"	m	class:memory_partition_unit::arbitration_metadata
m_shared_credit_limit	l2cache.h	/^      int m_shared_credit_limit; $/;"	m	class:memory_partition_unit::arbitration_metadata
m_sharers	coherence_manager.h	/^    std::set<unsigned>      m_sharers;$/;"	m	struct:coherence_directory_block_t
m_sid	commit_unit.h	/^    int m_sid;$/;"	m	class:commit_entry
m_sid	commit_unit.h	/^   int m_sid; $/;"	m	class:warp_commit_entry
m_sid	mem_fetch.h	/^   unsigned m_sid;$/;"	m	class:mem_fetch
m_sid	scoreboard.h	/^    unsigned m_sid;$/;"	m	class:Scoreboard
m_sid	shader.h	/^    unsigned m_sid; \/\/ shader id$/;"	m	class:shader_core_ctx
m_sid	shader.h	/^   unsigned m_sid;$/;"	m	class:ldst_unit
m_simd_width	stat-tool.h	/^   int m_simd_width;$/;"	m	class:insn_warp_occ_logger
m_simt_stack	scoreboard.h	/^    simt_stack **m_simt_stack;$/;"	m	class:Scoreboard
m_simt_stack	shader.h	/^    simt_stack** m_simt_stack;$/;"	m	class:scheduler_unit
m_size	commit_unit.h	/^   unsigned m_size;$/;"	m	class:conflict_table_hash
m_size	gpu-cache.h	/^        unsigned   m_size; \/\/ maximum number of entries in fifo$/;"	m	class:tex_cache::fifo
m_size	l2cache.h	/^    unsigned m_size;$/;"	m	class:tm_req_stall_queue
m_skip_entry	commit_unit.h	/^    bool m_skip_entry; \/\/ this is a skip entry $/;"	m	class:commit_entry
m_skip_vector	tm_conflict_detector.h	/^    std::bitset<MAX_CORES> m_skip_vector;$/;"	m	class:tm_conflict_detector
m_snap_shot_interval	stat-tool.h	/^   unsigned long long  m_snap_shot_interval;$/;"	m	class:snap_shot_trigger
m_sp_out	shader.h	/^    register_set* m_sp_out;$/;"	m	class:scheduler_unit
m_special_cache_config	gpu-sim.h	/^   std::map<std::string, FuncCache> m_special_cache_config;$/;"	m	class:gpgpu_sim
m_src_op	shader.h	/^      op_t *m_src_op;$/;"	m	class:opndcoll_rfu_t::collector_unit_t
m_stall_at_addr	mem_fetch.h	/^   addr_t m_stall_at_addr;$/;"	m	class:mem_fetch
m_stall_duration	commit_unit.cc	/^      pow2_histogram m_stall_duration; \/\/ how long as the pointer been stuck $/;"	m	struct:commit_unit_stats::cid_pointer_stats	file:
m_stall_queue	l2cache.h	/^    std::map<addr_t, tm_stall_queue> m_stall_queue;$/;"	m	class:tm_req_stall_queue
m_stall_reason	commit_unit.cc	/^      std::vector<unsigned int> m_stall_reason; $/;"	m	struct:commit_unit_stats::cid_pointer_stats	file:
m_stalled	shader.h	/^      bool m_stalled;$/;"	m	struct:tx_log_walker::warp_commit_tx_t
m_stalled_mask	mem_fetch.h	/^   std::bitset<32>m_stalled_mask;$/;"	m	class:mem_fetch
m_stalled_uid	mem_fetch.h	/^   int m_stalled_uid;$/;"	m	class:mem_fetch
m_started	shader.h	/^         bool m_started; $/;"	m	class:tx_log_walker::iwcd_uarch_info::uarch_event
m_state	commit_unit.h	/^    enum commit_state m_state;$/;"	m	class:commit_entry	typeref:enum:commit_entry::commit_state
m_state	shader.h	/^      enum commit_tx_state_t m_state;$/;"	m	struct:tx_log_walker::commit_tx_t	typeref:enum:tx_log_walker::commit_tx_t::commit_tx_state_t
m_state_cycles	shader.h	/^   std::vector<unsigned long long> m_state_cycles;$/;"	m	struct:thread_state_stat
m_state_cycles_atomic	shader.h	/^   thread_state_stat m_state_cycles_atomic;$/;"	m	class:thread_ctx_t
m_state_cycles_nonatomic	shader.h	/^   thread_state_stat m_state_cycles_nonatomic;$/;"	m	class:thread_ctx_t
m_state_cycles_tx_aborted	shader.h	/^   thread_state_stat m_state_cycles_tx_aborted;$/;"	m	class:thread_ctx_t
m_state_cycles_tx_useful	shader.h	/^   thread_state_stat m_state_cycles_tx_useful;$/;"	m	class:thread_ctx_t
m_stats	dram.h	/^   struct memory_stats_t *m_stats;$/;"	m	class:dram_t	typeref:struct:dram_t::memory_stats_t
m_stats	dram_sched.h	/^   memory_stats_t *m_stats;$/;"	m	class:frfcfs_scheduler
m_stats	gpu-cache.h	/^    cache_stats m_stats;$/;"	m	class:baseline_cache
m_stats	gpu-cache.h	/^    cache_stats m_stats;$/;"	m	class:tex_cache
m_stats	gpu-cache.h	/^    std::vector< std::vector<unsigned> > m_stats;$/;"	m	class:cache_stats
m_stats	l2cache.h	/^   class memory_stats_t *m_stats;$/;"	m	class:memory_partition_unit	typeref:class:memory_partition_unit::memory_stats_t
m_stats	l2cache.h	/^   class memory_stats_t *m_stats;$/;"	m	class:memory_sub_partition	typeref:class:memory_sub_partition::memory_stats_t
m_stats	shader.h	/^    shader_core_stats *m_stats;$/;"	m	class:scheduler_unit
m_stats	shader.h	/^    shader_core_stats *m_stats;$/;"	m	class:shader_core_ctx
m_stats	shader.h	/^    shader_core_stats *m_stats;$/;"	m	class:simt_core_cluster
m_stats	shader.h	/^   shader_core_stats *m_stats; $/;"	m	class:ldst_unit
m_stats	shader.h	/^   tx_log_walker_stats &m_stats;$/;"	m	class:tx_log_walker
m_stats	traffic_breakdown.h	/^   traffic_stat_t m_stats; $/;"	m	class:traffic_breakdown
m_stats_accesses	coherence_manager.h	/^    unsigned m_stats_accesses;$/;"	m	class:coherence_manager
m_stats_accesses	coherence_manager.h	/^    unsigned m_stats_accesses;$/;"	m	class:coherence_tag_array
m_stats_accesses_tm	coherence_manager.h	/^    unsigned m_stats_accesses_tm;$/;"	m	class:coherence_manager
m_stats_capacity_evictions_per_hw_thread	coherence_manager.h	/^    std::map<unsigned, unsigned> m_stats_capacity_evictions_per_hw_thread;     \/\/ keep track of # of L0 evictions per hw thread$/;"	m	class:coherence_manager
m_stats_capacity_evictions_per_sw_thread	coherence_manager.h	/^    std::map<unsigned, unsigned> m_stats_capacity_evictions_per_sw_thread;     \/\/ keep track of # of L0 evictions per sw thread$/;"	m	class:coherence_manager
m_stats_capacity_evictions_per_txn	coherence_manager.h	/^    std::map<unsigned, unsigned> m_stats_capacity_evictions_per_txn;        \/\/ keep track of # of L0 evictions per unique txn$/;"	m	class:coherence_manager
m_stats_directory_all_blocks	coherence_manager.h	/^    std::set<unsigned> m_stats_directory_all_blocks;                                \/\/ to keep a list of all blocks allocated$/;"	m	class:coherence_manager
m_stats_directory_all_blocks_invalidations	coherence_manager.h	/^    std::map<new_addr_type,unsigned> m_stats_directory_all_blocks_invalidations;    \/\/ keep track of invalidations per block address$/;"	m	class:coherence_manager
m_stats_directory_all_blocks_nsharersmax	coherence_manager.h	/^    std::map<new_addr_type,unsigned> m_stats_directory_all_blocks_nsharersmax;      \/\/ keep track of max sharers per block address$/;"	m	class:coherence_manager
m_stats_evictions	coherence_manager.h	/^    unsigned m_stats_evictions;$/;"	m	class:coherence_tag_array
m_stats_evictions_modified	coherence_manager.h	/^    unsigned m_stats_evictions_modified;$/;"	m	class:coherence_tag_array
m_stats_evictions_shared	coherence_manager.h	/^    unsigned m_stats_evictions_shared;$/;"	m	class:coherence_tag_array
m_stats_hist_sharers_invalidated_on_write	coherence_manager.h	/^    linear_histogram m_stats_hist_sharers_invalidated_on_write;$/;"	m	class:coherence_manager
m_stats_hist_sharers_invalidated_on_write_diffcore	coherence_manager.h	/^    linear_histogram m_stats_hist_sharers_invalidated_on_write_diffcore;$/;"	m	class:coherence_manager
m_stats_hist_sharers_invalidated_on_write_diffcore_tm	coherence_manager.h	/^    linear_histogram m_stats_hist_sharers_invalidated_on_write_diffcore_tm;$/;"	m	class:coherence_manager
m_stats_hist_sharers_invalidated_on_write_samecore	coherence_manager.h	/^    linear_histogram m_stats_hist_sharers_invalidated_on_write_samecore;$/;"	m	class:coherence_manager
m_stats_hist_sharers_invalidated_on_write_samecore_tm	coherence_manager.h	/^    linear_histogram m_stats_hist_sharers_invalidated_on_write_samecore_tm;$/;"	m	class:coherence_manager
m_stats_hist_sharers_invalidated_on_write_tm	coherence_manager.h	/^    linear_histogram m_stats_hist_sharers_invalidated_on_write_tm;$/;"	m	class:coherence_manager
m_stats_hits	coherence_manager.h	/^    unsigned m_stats_hits;$/;"	m	class:coherence_manager
m_stats_hits	coherence_manager.h	/^    unsigned m_stats_hits;$/;"	m	class:coherence_tag_array
m_stats_hw_threads	coherence_manager.h	/^    std::set<unsigned> m_stats_hw_threads;                                   \/\/ keep track of hw threads used$/;"	m	class:coherence_manager
m_stats_invalidations	coherence_manager.h	/^    unsigned m_stats_invalidations;$/;"	m	class:coherence_tag_array
m_stats_invalidations_diffcore	coherence_manager.h	/^	unsigned m_stats_invalidations_diffcore;$/;"	m	class:coherence_manager
m_stats_invalidations_diffcore_tm	coherence_manager.h	/^    unsigned m_stats_invalidations_diffcore_tm;$/;"	m	class:coherence_manager
m_stats_invalidations_on_writes_total	coherence_manager.h	/^    unsigned m_stats_invalidations_on_writes_total;$/;"	m	class:coherence_manager
m_stats_invalidations_samecore	coherence_manager.h	/^	unsigned m_stats_invalidations_samecore;$/;"	m	class:coherence_manager
m_stats_invalidations_samecore_tm	coherence_manager.h	/^    unsigned m_stats_invalidations_samecore_tm;$/;"	m	class:coherence_manager
m_stats_invalidations_total	coherence_manager.h	/^	unsigned m_stats_invalidations_total;$/;"	m	class:coherence_manager
m_stats_invalidations_total_tm	coherence_manager.h	/^    unsigned m_stats_invalidations_total_tm;$/;"	m	class:coherence_manager
m_stats_misses	coherence_manager.h	/^    unsigned m_stats_misses;$/;"	m	class:coherence_manager
m_stats_misses	coherence_manager.h	/^    unsigned m_stats_misses;$/;"	m	class:coherence_tag_array
m_stats_reads	coherence_manager.h	/^    unsigned m_stats_reads;$/;"	m	class:coherence_manager
m_stats_reads_tm	coherence_manager.h	/^    unsigned m_stats_reads_tm;$/;"	m	class:coherence_manager
m_stats_sw_threads	coherence_manager.h	/^    std::set<unsigned> m_stats_sw_threads;                                   \/\/ keep track of sw threads used$/;"	m	class:coherence_manager
m_stats_tm_aborts	coherence_manager.h	/^    unsigned m_stats_tm_aborts;$/;"	m	class:coherence_manager
m_stats_tm_access_mode_reads	coherence_manager.h	/^    unsigned m_stats_tm_access_mode_reads;$/;"	m	class:coherence_manager
m_stats_tm_commits	coherence_manager.h	/^    unsigned m_stats_tm_commits;$/;"	m	class:coherence_manager
m_stats_txns	coherence_manager.h	/^    std::set<unsigned> m_stats_txns;                                         \/\/ keep track of txns used$/;"	m	class:coherence_manager
m_stats_txns_per_hw_thread	coherence_manager.h	/^    std::map<unsigned, std::set<unsigned> > m_stats_txns_per_hw_thread;        \/\/ keep track of # of transactions per hw thread$/;"	m	class:coherence_manager
m_stats_txns_per_sw_thread	coherence_manager.h	/^    std::map<unsigned, std::set<unsigned> > m_stats_txns_per_sw_thread;        \/\/ keep track of # of transactions per sw thread$/;"	m	class:coherence_manager
m_stats_txns_warp_group	coherence_manager.h	/^    std::list<std::set<unsigned> > m_stats_txns_warp_group;                  \/\/ use this to store txns warp groups$/;"	m	class:coherence_manager
m_stats_txns_warp_group_evictions	coherence_manager.h	/^    std::list<unsigned> m_stats_txns_warp_group_evictions;                   \/\/ keep track of # of evictions in group$/;"	m	class:coherence_manager
m_stats_writes	coherence_manager.h	/^    unsigned m_stats_writes;$/;"	m	class:coherence_manager
m_stats_writes_tm	coherence_manager.h	/^    unsigned m_stats_writes_tm;$/;"	m	class:coherence_manager
m_status	coherence_manager.h	/^    coherence_cache_block_state    m_status;$/;"	m	struct:coherence_cache_block_t
m_status	coherence_manager.h	/^    coherence_cache_block_state    m_status;$/;"	m	struct:coherence_directory_block_t
m_status	gpu-cache.h	/^    cache_block_state    m_status;$/;"	m	struct:cache_block_t
m_status	mem_fetch.h	/^   enum mem_fetch_status m_status;$/;"	m	class:mem_fetch	typeref:enum:mem_fetch::mem_fetch_status
m_status_change	mem_fetch.h	/^   unsigned long long m_status_change;$/;"	m	class:mem_fetch
m_stores_outstanding	shader.h	/^    unsigned m_stores_outstanding; \/\/ number of store requests sent but not yet acknowledged$/;"	m	class:shd_warp_t
m_stride	histogram.h	/^   int m_stride;$/;"	m	class:linear_histogram
m_sub_partition	l2cache.h	/^   class memory_sub_partition **m_sub_partition; $/;"	m	class:memory_partition_unit	typeref:class:memory_partition_unit::memory_sub_partition
m_sum	histogram.h	/^   signed long long int m_sum; \/\/ for calculating the average$/;"	m	class:binned_histogram
m_supervised_warps	shader.h	/^    std::vector< shd_warp_t* > m_supervised_warps;$/;"	m	class:scheduler_unit
m_table	shader.cc	/^   std::vector<int> m_table; $/;"	m	class:ownership_table	file:
m_table_second_hash	shader.cc	/^   std::vector<int> m_table_second_hash; $/;"	m	class:ownership_table	file:
m_table_size	shader.cc	/^   size_t m_table_size; $/;"	m	class:ownership_table	file:
m_tag	coherence_manager.h	/^    new_addr_type    m_tag;$/;"	m	struct:coherence_cache_block_t
m_tag	gpu-cache.h	/^    new_addr_type    m_tag;$/;"	m	struct:cache_block_t
m_tag_array	gpu-cache.h	/^    tag_array*  m_tag_array;$/;"	m	class:baseline_cache
m_tags	gpu-cache.h	/^    tag_array               m_tags;$/;"	m	class:tex_cache
m_tags	tm_conflict_detector.h	/^    tag_array             m_tags;$/;"	m	class:tm_conflict_detector
m_tail	delayqueue.h	/^   fifo_data<T> *m_tail;$/;"	m	class:fifo_pipeline
m_tail	gpu-cache.h	/^        unsigned   m_tail; \/\/ oldest entry found here$/;"	m	class:tex_cache::fifo
m_thd_span	stat-tool.h	/^   thread_insn_span m_thd_span;$/;"	m	class:thread_CFlocality
m_thd_span_archive	stat-tool.h	/^   std::list<thread_insn_span> m_thd_span_archive;$/;"	m	class:thread_CFlocality
m_threadState	shader.h	/^    thread_ctx_t             *m_threadState;$/;"	m	class:shader_core_ctx
m_thread_pc	stat-tool.h	/^   std::vector<address_type> m_thread_pc;$/;"	m	class:thread_CFlocality
m_thread_processing	shader.h	/^      int m_thread_processing; \/\/ the thread that is processed now $/;"	m	struct:tx_log_walker::warp_commit_tx_t
m_thread_state	shader.h	/^      std::vector<commit_tx_t> m_thread_state; $/;"	m	struct:tx_log_walker::warp_commit_tx_t
m_tid	shader.h	/^       unsigned m_tid;$/;"	m	struct:tx_log_walker::extra_mf_fields
m_tid	tm_conflict_detector.h	/^        unsigned m_tid; \/\/ tid that marked this line$/;"	m	struct:tm_conflict_detector::blk_info
m_time	gpu-cache.h	/^        unsigned m_time; \/\/ which cycle did this entry become ready?$/;"	m	struct:tex_cache::rob_entry
m_timelinef	shader.h	/^   FILE *m_timelinef;$/;"	m	class:tx_log_walker
m_timeout_validation_cycle	shader.h	/^   unsigned long long m_timeout_validation_cycle;$/;"	m	class:thread_ctx_t
m_timeout_validation_mode	shader.h	/^   bool m_timeout_validation_mode;  \/\/ Was timed out, ignore any returning instructions$/;"	m	class:thread_ctx_t
m_timeout_validation_mode_set	shader.h	/^   bool m_timeout_validation_mode_set;$/;"	m	class:thread_ctx_t
m_timestamp	mem_fetch.h	/^   unsigned m_timestamp;  \/\/ set to gpu_sim_cycle+gpu_tot_sim_cycle at struct creation$/;"	m	class:mem_fetch
m_timestamp2	mem_fetch.h	/^   unsigned m_timestamp2; \/\/ set to gpu_sim_cycle+gpu_tot_sim_cycle when pushed onto icnt to shader; only used for reads$/;"	m	class:mem_fetch
m_timestamp_file	commit_unit.h	/^    FILE *m_timestamp_file;$/;"	m	class:commit_entry
m_timestamp_file	commit_unit.h	/^    FILE *m_timestamp_file;$/;"	m	class:commit_unit
m_tm_commit	scoreboard.h	/^    bool m_tm_commit; $/;"	m	class:Scoreboard
m_tm_manager	commit_unit.h	/^    class tm_manager_inf* m_tm_manager; $/;"	m	class:commit_entry	typeref:class:commit_entry::tm_manager_inf
m_tm_manager	mem_fetch.h	/^   class tm_manager_inf* m_tm_manager; $/;"	m	class:mem_fetch	typeref:class:mem_fetch::tm_manager_inf
m_tm_manager	shader.h	/^      tm_manager_inf *m_tm_manager; $/;"	m	struct:tx_log_walker::commit_tx_t
m_tm_rollback	scoreboard.h	/^    unsigned m_tm_rollback; $/;"	m	class:Scoreboard
m_tm_token	scoreboard.cc	/^   global_tm_token m_tm_token; $/;"	m	class:global_scoreboard	file:
m_tm_token	scoreboard.h	/^    std::set<unsigned> m_tm_token; $/;"	m	class:Scoreboard
m_tm_token_cnt	scoreboard.cc	/^   unsigned m_tm_token_cnt;  \/\/ number of TM tokens per core $/;"	m	class:scoreboard_options	file:
m_tm_warp_info	shader.h	/^    tm_warp_info m_tm_warp_info;$/;"	m	class:shd_warp_t
m_total_cta_launched	gpu-sim.h	/^   unsigned m_total_cta_launched;$/;"	m	class:gpgpu_sim
m_tpc	commit_unit.h	/^    int m_tpc; $/;"	m	class:commit_entry
m_tpc	mem_fetch.h	/^   unsigned m_tpc;$/;"	m	class:mem_fetch
m_tpc	shader.h	/^    unsigned m_tpc; \/\/ texture processor cluster id (aka, node id when using interconnect concentration)$/;"	m	class:shader_core_ctx
m_tpc	shader.h	/^   unsigned m_tpc;$/;"	m	class:ldst_unit
m_tracefile	gpu-cache.h	/^    FILE *m_tracefile; $/;"	m	class:baseline_cache
m_transaction_id	mem_fetch.h	/^   unsigned m_transaction_id;$/;"	m	class:mem_fetch
m_transactional	mem_fetch.h	/^   bool m_transactional; $/;"	m	class:mem_fetch
m_type	mem_fetch.h	/^   enum mf_type m_type;$/;"	m	class:mem_fetch	typeref:enum:mem_fetch::mf_type
m_type	shader.h	/^         enum event_type m_type; $/;"	m	class:tx_log_walker::iwcd_uarch_info::uarch_event	typeref:enum:tx_log_walker::iwcd_uarch_info::uarch_event::event_type
m_type_id	gpu-cache.h	/^    int m_type_id; \/\/ what kind of cache is this (normal, texture, constant)$/;"	m	class:tag_array
m_uid	coherence_manager.h	/^    unsigned m_uid; \/\/ unique thread id of thread using this cache$/;"	m	class:coherence_tag_array
m_unit	l2cache.h	/^    memory_sub_partition *m_unit;$/;"	m	class:L2icnt_interface
m_unit	l2cache.h	/^    memory_sub_partition *m_unit;$/;"	m	class:L2interface
m_unused_time	commit_unit.cc	/^   pow2_histogram m_unused_time;$/;"	m	class:commit_unit_stats	file:
m_update_done_mem_version	commit_unit.h	/^    mem_version_t m_update_done_mem_version; \/\/ the latest commit_id that updates the global memory location$/;"	m	class:commit_unit
m_update_sent_mem_version	commit_unit.h	/^    mem_version_t m_update_sent_mem_version; \/\/ the latest commit_id that has sent a update request $/;"	m	class:commit_unit
m_use_bloomfilter	commit_unit.cc	/^   bool m_use_bloomfilter; $/;"	m	class:commit_unit_options	file:
m_use_set_index_hash	gpu-cache.h	/^    bool m_use_set_index_hash; $/;"	m	class:cache_config
m_valid	gpu-cache.h	/^        bool m_valid;$/;"	m	struct:baseline_cache::extra_mf_fields
m_valid	gpu-cache.h	/^        bool m_valid;$/;"	m	struct:tex_cache::data_block
m_valid	gpu-cache.h	/^        bool m_valid;$/;"	m	struct:tex_cache::extra_mf_fields
m_valid	gpu-cache.h	/^    bool m_valid;$/;"	m	class:cache_config
m_valid	gpu-sim.h	/^	bool m_valid;$/;"	m	struct:power_config
m_valid	gpu-sim.h	/^    bool m_valid;$/;"	m	class:gpgpu_sim_config
m_valid	gpu-sim.h	/^   bool m_valid;$/;"	m	struct:memory_config
m_valid	shader.h	/^       bool m_valid;$/;"	m	struct:shd_warp_t::ibuffer_entry
m_valid	shader.h	/^       bool m_valid;$/;"	m	struct:tx_log_walker::extra_mf_fields
m_valid	shader.h	/^      bool m_valid;$/;"	m	class:opndcoll_rfu_t::op_t
m_valid	shader.h	/^    bool m_valid;$/;"	m	struct:ifetch_buffer_t
m_valid	tm_conflict_detector.h	/^        bool m_valid;$/;"	m	struct:tm_conflict_detector::blk_info
m_validation_L2_access	commit_unit.cc	/^   unsigned long long m_validation_L2_access;$/;"	m	class:commit_unit_stats	file:
m_validation_L2_hit	commit_unit.cc	/^   unsigned long long m_validation_L2_hit;$/;"	m	class:commit_unit_stats	file:
m_validation_coalescing_queue	commit_unit.h	/^    mem_op_queue_t m_validation_coalescing_queue; $/;"	m	class:commit_unit
m_validation_done_mask	commit_unit.h	/^   active_mask_t m_validation_done_mask; $/;"	m	class:warp_commit_entry
m_validation_latency	commit_unit.cc	/^   pow2_histogram m_validation_latency; $/;"	m	class:commit_unit_stats	file:
m_validation_queue	commit_unit.h	/^    mem_op_queue_t m_validation_queue; $/;"	m	class:commit_unit
m_validation_queue_size	commit_unit.cc	/^   pow2_histogram m_validation_queue_size; $/;"	m	class:commit_unit_stats	file:
m_validation_wait_time	commit_unit.cc	/^   pow2_histogram m_validation_wait_time;$/;"	m	class:commit_unit_stats	file:
m_validation_wait_time	commit_unit.h	/^    unsigned m_validation_wait_time;$/;"	m	class:commit_entry
m_vwait_nostall	commit_unit.cc	/^   bool m_vwait_nostall; $/;"	m	class:commit_unit_options	file:
m_warp	shader.h	/^      const warp_inst_t *m_warp;$/;"	m	class:opndcoll_rfu_t::op_t
m_warp	shader.h	/^      warp_inst_t  *m_warp;$/;"	m	class:opndcoll_rfu_t::collector_unit_t
m_warp	shader.h	/^    std::vector<shd_warp_t>   m_warp;   \/\/ per warp information array$/;"	m	class:shader_core_ctx
m_warp	shader.h	/^    std::vector<shd_warp_t>* m_warp;$/;"	m	class:scheduler_unit
m_warp	shader.h	/^   std::vector<shd_warp_t>& m_warp;$/;"	m	class:tx_log_walker
m_warp_active	shader.h	/^   warp_set_t m_warp_active;$/;"	m	class:barrier_set_t
m_warp_at_barrier	shader.h	/^   warp_set_t m_warp_at_barrier;$/;"	m	class:barrier_set_t
m_warp_commit_entry_table	commit_unit.h	/^    warp_commit_entry_table m_warp_commit_entry_table; $/;"	m	class:commit_unit
m_warp_id	shader.h	/^      unsigned  m_warp_id; $/;"	m	class:opndcoll_rfu_t::op_t
m_warp_id	shader.h	/^      unsigned m_warp_id;$/;"	m	class:opndcoll_rfu_t::collector_unit_t
m_warp_id	shader.h	/^    unsigned m_warp_id;$/;"	m	class:shd_warp_t
m_warp_id	shader.h	/^    unsigned m_warp_id;$/;"	m	struct:ifetch_buffer_t
m_warp_level_hazard_detect	commit_unit.cc	/^   bool m_warp_level_hazard_detect; $/;"	m	class:commit_unit_options	file:
m_warp_read_log_size	shader.cc	/^   pow2_histogram m_warp_read_log_size; $/;"	m	class:tx_log_walker_stats	file:
m_warp_size	shader.h	/^    unsigned m_warp_size;$/;"	m	class:shd_warp_t
m_warp_size	shader.h	/^   const unsigned m_warp_size; $/;"	m	class:tx_log_walker
m_warp_size	shader.h	/^   unsigned m_warp_size;$/;"	m	class:opndcoll_rfu_t
m_warp_write_log_size	shader.cc	/^   pow2_histogram m_warp_write_log_size; $/;"	m	class:tx_log_walker_stats	file:
m_ways	commit_unit.h	/^   unsigned m_ways;$/;"	m	class:conflict_table_hash
m_wid	commit_unit.h	/^    int m_wid; $/;"	m	class:commit_entry
m_wid	commit_unit.h	/^   int m_wid; $/;"	m	class:warp_commit_entry
m_wid	mem_fetch.h	/^   unsigned m_wid;$/;"	m	class:mem_fetch
m_wid	shader.h	/^       unsigned m_wid;$/;"	m	struct:tx_log_walker::extra_mf_fields
m_wr_alloc_type	gpu-cache.h	/^    mem_access_type m_wr_alloc_type; \/\/ Specifies type of write allocate request (e.g., L1 or L2)$/;"	m	class:data_cache
m_wr_hit	gpu-cache.h	/^        (data_cache::*m_wr_hit)( new_addr_type addr,$/;"	m	class:data_cache	typeref:enum:data_cache::m_wr_hit
m_wr_miss	gpu-cache.h	/^        (data_cache::*m_wr_miss)( new_addr_type addr,$/;"	m	class:data_cache	typeref:enum:data_cache::m_wr_miss
m_wrbk_type	gpu-cache.h	/^    mem_access_type m_wrbk_type; \/\/ Specifies type of writeback request (e.g., L1 or L2)$/;"	m	class:data_cache
m_write_alloc_policy	gpu-cache.h	/^    write_allocate_policy_t m_write_alloc_policy;	\/\/ 'W' = Write allocate, 'N' = No write allocate$/;"	m	class:cache_config
m_write_buffer_usage	commit_unit.cc	/^   pow2_histogram m_write_buffer_usage; $/;"	m	class:commit_unit_stats	file:
m_write_log_send_q	shader.h	/^      std::list<log_send_status_t> m_write_log_send_q; $/;"	m	struct:tx_log_walker::commit_tx_t
m_write_policy	gpu-cache.h	/^    enum write_policy_t m_write_policy;             \/\/ 'T' = write through, 'B' = write back, 'R' = read only$/;"	m	class:cache_config	typeref:enum:cache_config::write_policy_t
m_write_regfile_acesses	power_stat.h	/^    unsigned *m_write_regfile_acesses[NUM_STAT_IDX];$/;"	m	struct:shader_core_power_stats_pod
m_write_regfile_acesses	shader.h	/^    unsigned *m_write_regfile_acesses;$/;"	m	struct:shader_core_stats_pod
m_write_set	commit_unit.h	/^    cu_access_set m_write_set; $/;"	m	class:commit_entry
m_write_set_access_coalesced	commit_unit.cc	/^   unsigned long long m_write_set_access_coalesced;$/;"	m	class:commit_unit_stats	file:
m_write_set_access_raw	commit_unit.cc	/^   unsigned long long m_write_set_access_raw;$/;"	m	class:commit_unit_stats	file:
m_writeback_arb	shader.h	/^   unsigned m_writeback_arb; \/\/ round-robin arbiter for writeback contention between L1T, L1C, shared$/;"	m	class:ldst_unit
m_youngest_conflicting_commit_id	commit_unit.h	/^    int m_youngest_conflicting_commit_id;$/;"	m	class:commit_entry
made_read_mfs	shader.h	/^    unsigned made_read_mfs;$/;"	m	struct:shader_core_stats_pod
made_write_mfs	shader.h	/^    unsigned made_write_mfs;$/;"	m	struct:shader_core_stats_pod
mark	shader.cc	/^   void mark(addr_t address_tag, int thread_id) $/;"	f	class:ownership_table
mark_check_intra_warp_conflict_detection	shader.cc	/^active_mask_t tx_log_walker::mark_check_intra_warp_conflict_detection(warp_inst_t &inst, $/;"	f	class:tx_log_walker
mark_dirty	gpu-cache.h	/^    void mark_dirty() { m_dirty = true; }$/;"	f	struct:cache_block_t
mark_last_use	gpu-cache.cc	/^void l1_cache::mark_last_use( new_addr_type addr, bool check_hit )$/;"	f	class:l1_cache
mark_last_use	gpu-cache.h	/^    virtual void mark_last_use( new_addr_type addr, bool check_hit = true ) $/;"	f	class:data_cache
mark_last_use	gpu-cache.h	/^    void mark_last_use() $/;"	f	struct:cache_block_t
mark_modified	coherence_manager.h	/^    void mark_modified( unsigned time )$/;"	f	struct:coherence_cache_block_t
mark_priority_check_intra_warp_conflict_detection	shader.cc	/^active_mask_t tx_log_walker::mark_priority_check_intra_warp_conflict_detection(warp_inst_t &inst, $/;"	f	class:tx_log_walker
mark_ready	gpu-cache.cc	/^void mshr_table::mark_ready( new_addr_type block_addr, bool &has_atomic ){$/;"	f	class:mshr_table
mark_shared	coherence_manager.h	/^    void mark_shared( unsigned time )$/;"	f	struct:coherence_cache_block_t
match	commit_unit.cc	/^bool cu_access_set::match(new_addr_type addr) const$/;"	f	class:cu_access_set
max_conc_access2samerow	mem_latency_stat.h	/^   unsigned int **max_conc_access2samerow; \/\/max_conc_access2samerow[dram chip id][bank id]$/;"	m	class:memory_stats_t
max_concurrent_kernel	gpu-sim.h	/^    unsigned max_concurrent_kernel;$/;"	m	class:gpgpu_sim_config
max_cta	shader.cc	/^unsigned int shader_core_config::max_cta( const kernel_info_t &k ) const$/;"	f	class:shader_core_config
max_cta	shader.cc	/^unsigned simt_core_cluster::max_cta( const kernel_info_t &kernel )$/;"	f	class:simt_core_cluster
max_cta_per_core	shader.h	/^    unsigned max_cta_per_core; \/\/Limit on number of concurrent CTAs in shader core$/;"	m	struct:shader_core_config
max_dq_latency	mem_latency_stat.h	/^   unsigned max_dq_latency;$/;"	m	class:memory_stats_t
max_icnt2mem_latency	mem_latency_stat.h	/^   unsigned max_icnt2mem_latency;$/;"	m	class:memory_stats_t
max_icnt2sh_latency	mem_latency_stat.h	/^   unsigned max_icnt2sh_latency;$/;"	m	class:memory_stats_t
max_mf_latency	mem_latency_stat.h	/^   unsigned max_mf_latency;$/;"	m	class:memory_stats_t
max_mrq_latency	mem_latency_stat.h	/^   unsigned max_mrq_latency;$/;"	m	class:memory_stats_t
max_mrqs	dram.h	/^   unsigned int max_mrqs;$/;"	m	class:dram_t
max_mrqs_temp	dram.h	/^   unsigned int max_mrqs_temp;$/;"	m	class:dram_t
max_servicetime2samerow	mem_latency_stat.h	/^   unsigned int **max_servicetime2samerow; \/\/max_servicetime2samerow[dram chip id][bank id]$/;"	m	class:memory_stats_t
max_set_util	gpu-cache.h	/^    unsigned max_set_util; $/;"	m	struct:cache_sub_stats
max_set_util_count	gpu-cache.h	/^    unsigned max_set_util_count; $/;"	m	struct:cache_sub_stats
max_sfu_latency	shader.h	/^    unsigned max_sfu_latency;$/;"	m	struct:shader_core_config
max_size	stack.h	/^   int max_size;$/;"	m	struct:__anon5
max_sp_latency	shader.h	/^    unsigned max_sp_latency;$/;"	m	struct:shader_core_config
max_warps	mem_latency_stat.h	/^   unsigned max_warps;$/;"	m	class:memory_stats_t
max_warps_per_shader	shader.h	/^    unsigned max_warps_per_shader; $/;"	m	struct:shader_core_config
mcpat_cycle	power_interface.cc	/^void mcpat_cycle(const gpgpu_sim_config &config, const struct shader_core_config *shdr_config, class gpgpu_sim_wrapper *wrapper, class power_stat_t *power_stats, unsigned stat_sample_freq, unsigned tot_cycle, unsigned cycle, unsigned tot_inst, unsigned inst){$/;"	f
mcpat_reset_perf_count	power_interface.cc	/^void mcpat_reset_perf_count(class gpgpu_sim_wrapper *wrapper){$/;"	f
mem2device	shader.h	/^    unsigned mem2device(unsigned memid) const { return memid + n_simt_clusters; }$/;"	f	struct:shader_core_config
mem_access	coherence_manager.cc	/^void coherence_manager::mem_access(unsigned hwtid, new_addr_type addr, unsigned time, bool write, ptx_thread_info* thread_state)$/;"	f	class:coherence_manager
mem_access_type_stats	mem_latency_stat.h	/^   unsigned ***mem_access_type_stats; \/\/ dram access type classification$/;"	m	class:memory_stats_t
mem_fetch	mem_fetch.cc	/^mem_fetch::mem_fetch( const mem_access_t &access, $/;"	f	class:mem_fetch
mem_fetch	mem_fetch.h	/^    mem_fetch(): m_stalled_mask((unsigned long long)0) { \/\/hack for logical timestamp based tm manager$/;"	f	class:mem_fetch
mem_fetch	mem_fetch.h	/^class mem_fetch {$/;"	c
mem_fetch_pts	mem_fetch.h	/^   unsigned long long mem_fetch_pts;$/;"	m	class:mem_fetch
mem_instruction_stats	gpu-sim.cc	/^void shader_core_ctx::mem_instruction_stats(const warp_inst_t &inst)$/;"	f	class:shader_core_ctx
mem_op_queue_t	commit_unit.h	/^    typedef std::list<cu_mem_acc> mem_op_queue_t; $/;"	t	class:commit_unit
mem_power_stats_pod	power_stat.h	/^struct mem_power_stats_pod{$/;"	s
mem_stage_access_type	stats.h	/^enum mem_stage_access_type {$/;"	g
mem_stage_stall_type	stats.h	/^enum mem_stage_stall_type {$/;"	g
mem_version_t	commit_unit.h	/^    typedef tr1_hash_map<addr_t, int> mem_version_t;$/;"	t	class:commit_unit
memlatstat_done	mem_latency_stat.cc	/^unsigned memory_stats_t::memlatstat_done(mem_fetch *mf )$/;"	f	class:memory_stats_t
memlatstat_dram_access	mem_latency_stat.cc	/^void memory_stats_t::memlatstat_dram_access(mem_fetch *mf)$/;"	f	class:memory_stats_t
memlatstat_icnt2mem_pop	mem_latency_stat.cc	/^void memory_stats_t::memlatstat_icnt2mem_pop(mem_fetch *mf)$/;"	f	class:memory_stats_t
memlatstat_lat_pw	mem_latency_stat.cc	/^void memory_stats_t::memlatstat_lat_pw()$/;"	f	class:memory_stats_t
memlatstat_print	mem_latency_stat.cc	/^void memory_stats_t::memlatstat_print( unsigned n_mem, unsigned gpu_mem_n_bk )$/;"	f	class:memory_stats_t
memlatstat_read_done	mem_latency_stat.cc	/^void memory_stats_t::memlatstat_read_done(mem_fetch *mf)$/;"	f	class:memory_stats_t
memory_config	gpu-sim.h	/^   memory_config()$/;"	f	struct:memory_config
memory_config	gpu-sim.h	/^struct memory_config {$/;"	s
memory_cycle	shader.cc	/^bool ldst_unit::memory_cycle( warp_inst_t &inst, mem_stage_stall_type &stall_reason, mem_stage_access_type &access_type ) {$/;"	f	class:ldst_unit
memory_partition_unit	l2cache.cc	/^memory_partition_unit::memory_partition_unit( unsigned partition_id, $/;"	f	class:memory_partition_unit
memory_partition_unit	l2cache.h	/^class memory_partition_unit$/;"	c
memory_stats_t	mem_latency_stat.cc	/^memory_stats_t::memory_stats_t( unsigned n_shader, const struct shader_core_config *shader_config, const struct memory_config *mem_config )$/;"	f	class:memory_stats_t
memory_stats_t	mem_latency_stat.h	/^class memory_stats_t {$/;"	c
memory_sub_partition	l2cache.cc	/^memory_sub_partition::memory_sub_partition( unsigned sub_partition_id, $/;"	f	class:memory_sub_partition
memory_sub_partition	l2cache.h	/^class memory_sub_partition$/;"	c
mf_lat_pw_table	mem_latency_stat.h	/^   unsigned mf_lat_pw_table[32]; \/\/table storing values of mf latency Per Window$/;"	m	class:memory_stats_t
mf_lat_table	mem_latency_stat.h	/^   unsigned mf_lat_table[32];$/;"	m	class:memory_stats_t
mf_max_lat_table	mem_latency_stat.h	/^   unsigned ** mf_max_lat_table; \/\/mf latency sums[dram chip id][bank id]$/;"	m	class:memory_stats_t
mf_num_lat_pw	mem_latency_stat.h	/^   unsigned mf_num_lat_pw;$/;"	m	class:memory_stats_t
mf_packet_size	traffic_breakdown.h	/^   typedef unsigned int mf_packet_size; $/;"	t	class:traffic_breakdown
mf_packet_type	traffic_breakdown.h	/^   typedef std::string mf_packet_type;  \/\/ use string so that it remains extensible $/;"	t	class:traffic_breakdown
mf_tot_lat_pw	mem_latency_stat.h	/^   unsigned mf_tot_lat_pw; \/\/total latency summed up per window. divide by mf_num_lat_pw to obtain average latency Per Window$/;"	m	class:memory_stats_t
mf_total_lat	mem_latency_stat.h	/^   unsigned long long int mf_total_lat;$/;"	m	class:memory_stats_t
mf_total_lat_table	mem_latency_stat.h	/^   unsigned long long int ** mf_total_lat_table; \/\/mf latency sums[dram chip id][bank id]$/;"	m	class:memory_stats_t
mf_type	mem_fetch.h	/^enum mf_type {$/;"	g
min3	gpu-misc.h	39;"	d
min_set_util	gpu-cache.h	/^    unsigned min_set_util; $/;"	m	struct:cache_sub_stats
min_set_util_count	gpu-cache.h	/^    unsigned min_set_util_count; $/;"	m	struct:cache_sub_stats
min_snap_shot_interval	stat-tool.cc	/^static unsigned long long  min_snap_shot_interval = 0;$/;"	v	file:
miss_queue_full	gpu-cache.h	/^    bool miss_queue_full(unsigned num_miss){$/;"	f	class:baseline_cache
misses	gpu-cache.h	/^    unsigned misses;$/;"	m	struct:cache_sub_stats
model	shader.h	/^    enum divergence_support_t model;$/;"	m	struct:shader_core_config	typeref:enum:shader_core_config::divergence_support_t
mrq	dram.h	/^   dram_req_t *mrq;$/;"	m	struct:bank_t
mrq_lat_table	mem_latency_stat.h	/^   unsigned mrq_lat_table[32];$/;"	m	class:memory_stats_t
mrqq	dram.h	/^   fifo_pipeline<dram_req_t> *mrqq;$/;"	m	class:dram_t
mrqq_Dist	dram.h	/^   class Stats* mrqq_Dist; \/\/memory request queue inside DRAM  $/;"	m	class:dram_t	typeref:class:dram_t::Stats
mshr_config_t	gpu-cache.h	/^enum mshr_config_t {$/;"	g
mshr_entry	gpu-cache.h	/^        mshr_entry() : m_has_atomic(false), m_response_ready(false) { }$/;"	f	struct:mshr_table::mshr_entry
mshr_entry	gpu-cache.h	/^    struct mshr_entry {$/;"	s	class:mshr_table
mshr_table	gpu-cache.h	/^    mshr_table( unsigned num_entries, unsigned max_merged )$/;"	f	class:mshr_table
mshr_table	gpu-cache.h	/^class mshr_table {$/;"	c
my_time_vector	visualizer.cc	/^   my_time_vector(int ld_size,int st_size){$/;"	f	class:my_time_vector
my_time_vector	visualizer.cc	/^class my_time_vector {$/;"	c	file:
n_access	dram.h	/^   unsigned int n_access;$/;"	m	struct:bank_t
n_act	dram.h	/^   unsigned int n_act;$/;"	m	class:dram_t
n_act	power_stat.h	/^    unsigned *n_act[NUM_STAT_IDX];$/;"	m	struct:mem_power_stats_pod
n_act_partial	dram.h	/^   unsigned int n_act_partial; $/;"	m	class:dram_t
n_activity	dram.h	/^   unsigned int n_activity;$/;"	m	class:dram_t
n_activity	power_stat.h	/^    unsigned *n_activity[NUM_STAT_IDX];$/;"	m	struct:mem_power_stats_pod
n_activity_partial	dram.h	/^   unsigned int n_activity_partial;$/;"	m	class:dram_t
n_atag_cachemiss	shader.cc	/^   unsigned n_atag_cachemiss; $/;"	m	class:tx_log_walker_stats	file:
n_atag_cachercf	shader.cc	/^   unsigned n_atag_cachercf; $/;"	m	class:tx_log_walker_stats	file:
n_atag_read	shader.cc	/^   unsigned n_atag_read; $/;"	m	class:tx_log_walker_stats	file:
n_cmd	dram.h	/^   unsigned int n_cmd;$/;"	m	class:dram_t
n_cmd	power_stat.h	/^    unsigned *n_cmd[NUM_STAT_IDX];$/;"	m	struct:mem_power_stats_pod
n_cmd_partial	dram.h	/^   unsigned int n_cmd_partial;$/;"	m	class:dram_t
n_completed	shader.h	/^    unsigned n_completed;          \/\/ number of threads in warp completed$/;"	m	class:shd_warp_t
n_cu_pass_msg	shader.cc	/^   unsigned n_cu_pass_msg;$/;"	m	class:tx_log_walker_stats	file:
n_data_cachemiss	shader.cc	/^   unsigned n_data_cachemiss; $/;"	m	class:tx_log_walker_stats	file:
n_data_cachercf	shader.cc	/^   unsigned n_data_cachercf; $/;"	m	class:tx_log_walker_stats	file:
n_data_read	shader.cc	/^   unsigned n_data_read; $/;"	m	class:tx_log_walker_stats	file:
n_idle	dram.h	/^   unsigned int n_idle;$/;"	m	struct:bank_t
n_insn	shader.h	/^   unsigned n_insn;$/;"	m	class:thread_ctx_t
n_insn_ac	shader.h	/^   unsigned n_insn_ac;$/;"	m	class:thread_ctx_t
n_intra_warp_aborts_false_positive	shader.cc	/^   unsigned n_intra_warp_aborts_false_positive; $/;"	m	class:tx_log_walker_stats	file:
n_intra_warp_complete_abort	shader.cc	/^   unsigned n_intra_warp_complete_abort; $/;"	m	class:tx_log_walker_stats	file:
n_intra_warp_conflicts_detected	shader.cc	/^   unsigned n_intra_warp_conflicts_detected; $/;"	m	class:tx_log_walker_stats	file:
n_l1_access_ac	shader.h	/^   unsigned n_l1_access_ac; $/;"	m	class:thread_ctx_t
n_l1_mis_ac	shader.h	/^   unsigned n_l1_mis_ac;$/;"	m	class:thread_ctx_t
n_l1_mrghit_ac	shader.h	/^   unsigned n_l1_mrghit_ac;$/;"	m	class:thread_ctx_t
n_mem_to_simt	power_stat.h	/^    long *n_mem_to_simt[NUM_STAT_IDX];$/;"	m	struct:mem_power_stats_pod
n_mem_to_simt	shader.h	/^    long *n_mem_to_simt;$/;"	m	struct:shader_core_stats_pod
n_mem_to_simt_at_pop	l2cache.h	/^   unsigned n_mem_to_simt_at_pop;$/;"	m	class:memory_sub_partition
n_nop	dram.h	/^   unsigned int n_nop;$/;"	m	class:dram_t
n_nop	power_stat.h	/^    unsigned *n_nop[NUM_STAT_IDX];$/;"	m	struct:mem_power_stats_pod
n_nop_partial	dram.h	/^   unsigned int n_nop_partial; $/;"	m	class:dram_t
n_pre	dram.h	/^   unsigned int n_pre;$/;"	m	class:dram_t
n_pre	power_stat.h	/^    unsigned *n_pre[NUM_STAT_IDX];$/;"	m	struct:mem_power_stats_pod
n_pre_commit_validation_abort	shader.cc	/^   unsigned n_pre_commit_validation_abort; $/;"	m	class:tx_log_walker_stats	file:
n_pre_commit_validation_pass	shader.cc	/^   unsigned n_pre_commit_validation_pass; $/;"	m	class:tx_log_walker_stats	file:
n_pre_partial	dram.h	/^   unsigned int n_pre_partial; $/;"	m	class:dram_t
n_rd	dram.h	/^   unsigned int n_rd;$/;"	m	class:dram_t
n_rd	power_stat.h	/^    unsigned *n_rd[NUM_STAT_IDX];$/;"	m	struct:mem_power_stats_pod
n_regfile_gating_group	shader.h	/^    unsigned n_regfile_gating_group;$/;"	m	struct:shader_core_config
n_req	dram.h	/^   unsigned int n_req;$/;"	m	class:dram_t
n_req	power_stat.h	/^    unsigned *n_req[NUM_STAT_IDX];$/;"	m	struct:mem_power_stats_pod
n_req_partial	dram.h	/^   unsigned int n_req_partial;$/;"	m	class:dram_t
n_simt_clusters	shader.h	/^    unsigned n_simt_clusters;$/;"	m	struct:shader_core_config
n_simt_cores_per_cluster	shader.h	/^    unsigned n_simt_cores_per_cluster;$/;"	m	struct:shader_core_config
n_simt_ejection_buffer_size	shader.h	/^    unsigned n_simt_ejection_buffer_size;$/;"	m	struct:shader_core_config
n_simt_to_mem	power_stat.h	/^    long *n_simt_to_mem[NUM_STAT_IDX];$/;"	m	struct:mem_power_stats_pod
n_simt_to_mem	shader.h	/^    long *n_simt_to_mem; \/\/ Interconnect power stats$/;"	m	struct:shader_core_stats_pod
n_thread_CFloggers	stat-tool.cc	/^static int n_thread_CFloggers = 0;$/;"	v	file:
n_thread_per_shader	shader.h	/^    unsigned n_thread_per_shader;$/;"	m	struct:shader_core_config
n_warp_commit_attempt	shader.cc	/^   unsigned n_warp_commit_attempt; $/;"	m	class:tx_log_walker_stats	file:
n_warp_commit_read_only	shader.cc	/^   unsigned n_warp_commit_read_only;$/;"	m	class:tx_log_walker_stats	file:
n_wr	dram.h	/^   unsigned int n_wr;$/;"	m	class:dram_t
n_wr	power_stat.h	/^    unsigned *n_wr[NUM_STAT_IDX];$/;"	m	struct:mem_power_stats_pod
n_writes	dram.h	/^   unsigned int n_writes;$/;"	m	struct:bank_t
nbk	gpu-sim.h	/^   unsigned nbk;$/;"	m	struct:memory_config
nbkgrp	gpu-sim.h	/^   unsigned nbkgrp; \/\/ number of bank groups (has to be power of 2)$/;"	m	struct:memory_config
nbytes	dram.h	/^   unsigned int nbytes;$/;"	m	class:dram_req_t
need_do_commit	shader.cc	/^bool tx_log_walker::need_do_commit(warp_inst_t &inst) $/;"	f	class:tx_log_walker
network_mode	icnt_wrapper.h	/^enum network_mode {$/;"	g
new_grid	shader.h	/^    void new_grid()$/;"	f	class:shader_core_stats
new_stack	stack.cc	/^Stack* new_stack(int size) {$/;"	f
new_window	gpu-cache.cc	/^void tag_array::new_window()$/;"	f	class:tag_array
next_access	gpu-cache.cc	/^mem_fetch *mshr_table::next_access(){$/;"	f	class:mshr_table
next_access	gpu-cache.h	/^    mem_fetch *next_access(){return m_mshrs.next_access();}$/;"	f	class:baseline_cache
next_access	gpu-cache.h	/^    mem_fetch *next_access(){return m_result_fifo.pop();}$/;"	f	class:tex_cache
next_clock_domain	gpu-sim.cc	/^int gpgpu_sim::next_clock_domain(void) $/;"	f	class:gpgpu_sim
next_coalesced_op	commit_unit.h	/^       cu_mem_acc& next_coalesced_op() { return m_coalesced_ops.front(); }$/;"	f	class:commit_unit::cu_mem_acc
next_coalesced_packet	mem_fetch.cc	/^mem_fetch* mem_fetch::next_coalesced_packet()$/;"	f	class:mem_fetch
next_commit_ready	shader.cc	/^warp_inst_t& tx_log_walker::next_commit_ready()$/;"	f	class:tx_log_walker
next_event_done	shader.h	/^      void next_event_done() {$/;"	f	class:tx_log_walker::iwcd_uarch_info
next_event_in_queue	shader.h	/^      uarch_event & next_event_in_queue() {$/;"	f	class:tx_log_walker::iwcd_uarch_info
next_pc	shader.cc	/^address_type shader_core_ctx::next_pc( int tid ) const$/;"	f	class:shader_core_ctx
next_pop_index	gpu-cache.h	/^        unsigned next_pop_index() const $/;"	f	class:tex_cache::fifo
next_read_log_send	shader.h	/^      void next_read_log_send() { m_read_log_send_q.pop_front(); }$/;"	f	struct:tx_log_walker::commit_tx_t
next_snap_shot_cycle	stat-tool.cc	/^static unsigned long long  next_snap_shot_cycle = 0;$/;"	v	file:
next_spill_cycle	stat-tool.cc	/^static unsigned long long  next_spill_cycle = 0;$/;"	v	file:
next_thread	shader.cc	/^void tx_log_walker::warp_commit_tx_t::next_thread()$/;"	f	class:tx_log_walker::warp_commit_tx_t
next_thread_to_non_waiting	shader.cc	/^void tx_log_walker::warp_commit_tx_t::next_thread_to_non_waiting()$/;"	f	class:tx_log_walker::warp_commit_tx_t
next_write_log_send	shader.h	/^      void next_write_log_send() { m_write_log_send_q.pop_front(); }$/;"	f	struct:tx_log_walker::commit_tx_t
null_match	shader.cc	/^bool null_match( warp_inst_t* warp_inst ) { return true; }$/;"	f
num_MCBs_accessed	mem_latency_stat.h	/^   unsigned int *num_MCBs_accessed; \/\/tracks how many memory controllers are accessed whenever any thread in a warp misses in cache$/;"	m	class:memory_stats_t
num_activates	mem_latency_stat.h	/^   unsigned int **num_activates; \/\/num_activates[dram chip id][bank id]$/;"	m	class:memory_stats_t
num_cluster	gpu-sim.h	/^    unsigned num_cluster() const { return m_shader_config.n_simt_clusters; }$/;"	f	class:gpgpu_sim_config
num_coalesced_accesses	commit_unit.cc	/^unsigned commit_unit::num_coalesced_accesses( const std::list<mem_fetch*>& packets ) $/;"	f	class:commit_unit
num_mfs	mem_latency_stat.h	/^   unsigned num_mfs;$/;"	m	class:memory_stats_t
num_pending	dram_sched.h	/^   unsigned num_pending() const { return m_num_pending;}$/;"	f	class:frfcfs_scheduler
num_registers_per_core	gpu-sim.cc	/^int gpgpu_sim::num_registers_per_core() const$/;"	f	class:gpgpu_sim
num_result_bus	shader.h	/^    unsigned num_result_bus;$/;"	m	class:shader_core_ctx
num_shader	gpu-sim.h	/^    unsigned num_shader() const { return m_shader_config.num_shader(); }$/;"	f	class:gpgpu_sim_config
num_shader	shader.h	/^    unsigned num_shader() const { return n_simt_clusters*n_simt_cores_per_cluster; }$/;"	f	struct:shader_core_config
num_warps_issuable	shader.h	/^    unsigned *num_warps_issuable;$/;"	m	struct:shader_core_stats_pod
occupied	shader.h	/^    std::bitset<MAX_ALU_LATENCY> occupied;$/;"	m	class:simd_function_unit
op_t	shader.h	/^      op_t( collector_unit_t *cu, unsigned op, unsigned reg, unsigned num_banks, unsigned bank_warp_shift, bool is_transaction_dst = false )$/;"	f	class:opndcoll_rfu_t::op_t
op_t	shader.h	/^      op_t( const warp_inst_t *warp, unsigned reg, unsigned num_banks, unsigned bank_warp_shift )$/;"	f	class:opndcoll_rfu_t::op_t
op_t	shader.h	/^      op_t( unsigned warp_id, unsigned reg, unsigned num_banks, unsigned bank_warp_shift )$/;"	f	class:opndcoll_rfu_t::op_t
op_t	shader.h	/^      op_t() { m_valid = false; m_is_transaction_dst = false; }$/;"	f	class:opndcoll_rfu_t::op_t
op_t	shader.h	/^   class op_t {$/;"	c	class:opndcoll_rfu_t
operation	commit_unit.h	/^       enum cu_mem_op operation;$/;"	m	class:commit_unit::cu_mem_acc	typeref:enum:commit_unit::cu_mem_acc::cu_mem_op
operation_cycles	shader.h	/^      unsigned operation_cycles() {$/;"	f	class:tx_log_walker::iwcd_uarch_info
operator ()	addrdec.cc	/^   size_t operator()(const addrdec_t &x) const {$/;"	f	class:hash_addrdec_t
operator ()	gpu-cache.cc	/^unsigned &cache_stats::operator()(int access_type, int access_outcome){$/;"	f	class:cache_stats
operator ()	gpu-cache.cc	/^unsigned cache_stats::operator()(int access_type, int access_outcome) const{$/;"	f	class:cache_stats
operator ()	l2cache.h	/^    bool operator()(const logical_mem_fetch &e1, const logical_mem_fetch &e2) {$/;"	f	struct:logical_mem_fetch_compare
operator +	gpu-cache.cc	/^cache_stats cache_stats::operator+(const cache_stats &cs){$/;"	f	class:cache_stats
operator +	gpu-cache.h	/^    cache_sub_stats operator+(const cache_sub_stats &cs){$/;"	f	struct:cache_sub_stats
operator +=	gpu-cache.cc	/^cache_stats &cache_stats::operator+=(const cache_stats &cs){$/;"	f	class:cache_stats
operator +=	gpu-cache.h	/^    cache_sub_stats &operator+=(const cache_sub_stats &css){$/;"	f	struct:cache_sub_stats
operator +=	stat-tool.cc	/^thread_insn_span& thread_insn_span::operator+=(const thread_insn_span& other)$/;"	f	class:thread_insn_span
operator <	addrdec.cc	/^bool operator<(const addrdec_t &x, const addrdec_t &y) $/;"	f
operator =	stat-tool.cc	/^thread_insn_span& thread_insn_span::operator=(const thread_insn_span& other)$/;"	f	class:thread_insn_span
operator =	stat-tool.h	/^   insn_warp_occ_logger& operator=(const insn_warp_occ_logger& p) {$/;"	f	class:insn_warp_occ_logger
operator ==	addrdec.cc	/^bool operator==(const addrdec_t &x, const addrdec_t &y) $/;"	f
opndcoll_rfu_t	shader.h	/^   opndcoll_rfu_t()$/;"	f	class:opndcoll_rfu_t
opndcoll_rfu_t	shader.h	/^class opndcoll_rfu_t { \/\/ operand collector based register file unit$/;"	c
order_by_priority	shader.cc	/^void scheduler_unit::order_by_priority( std::vector< T >& result_list,$/;"	f	class:scheduler_unit
order_lrr	shader.cc	/^void scheduler_unit::order_lrr( std::vector< T >& result_list,$/;"	f	class:scheduler_unit
order_warps	shader.cc	/^void gto_scheduler::order_warps()$/;"	f	class:gto_scheduler
order_warps	shader.cc	/^void lrr_scheduler::order_warps()$/;"	f	class:lrr_scheduler
order_warps	shader.cc	/^void swl_scheduler::order_warps()$/;"	f	class:swl_scheduler
order_warps	shader.cc	/^void two_level_active_scheduler::order_warps()$/;"	f	class:two_level_active_scheduler
out_message_queue_cycle	shader.cc	/^void tx_log_walker::out_message_queue_cycle()$/;"	f	class:tx_log_walker
overal_ld_count	visualizer.cc	/^   int overal_ld_count;$/;"	m	class:my_time_vector	file:
overal_ld_time_dist	visualizer.cc	/^   std::vector<double>  overal_ld_time_dist;$/;"	m	class:my_time_vector	file:
overal_st_count	visualizer.cc	/^   int overal_st_count;$/;"	m	class:my_time_vector	file:
overal_st_time_dist	visualizer.cc	/^   std::vector<double>  overal_st_time_dist;$/;"	m	class:my_time_vector	file:
overflow	commit_unit.cc	/^bool cu_access_set::overflow() const $/;"	f	class:cu_access_set
ownership_table	shader.cc	/^   ownership_table(unsigned size, bool use_bloom_filter) $/;"	f	class:ownership_table
ownership_table	shader.cc	/^class ownership_table $/;"	c	file:
partial_fill	gpu-cache.h	/^    void partial_fill( unsigned time )$/;"	f	struct:cache_block_t
partial_processed_packet	mem_fetch.cc	/^bool mem_fetch::partial_processed_packet() const $/;"	f	class:mem_fetch
partition_address	addrdec.cc	/^new_addr_type linear_to_raw_address_translation::partition_address( new_addr_type addr ) const $/;"	f	class:linear_to_raw_address_translation
partition_mf_allocator	l2cache.h	/^    partition_mf_allocator( const memory_config *config )$/;"	f	class:partition_mf_allocator
partition_mf_allocator	l2cache.h	/^class partition_mf_allocator : public mem_fetch_allocator {$/;"	c
pc	shader.h	/^   unsigned pc;$/;"	m	struct:insn_latency_info
peek	gpu-cache.h	/^        T &peek( unsigned index ) $/;"	f	class:tex_cache::fifo
peek	gpu-cache.h	/^        T &peek() const$/;"	f	class:tex_cache::fifo
peek	gpu-cache.h	/^        const T &peek( unsigned index ) const $/;"	f	class:tex_cache::fifo
pendingWrites	scoreboard.cc	/^bool Scoreboard::pendingWrites(unsigned wid) const$/;"	f	class:Scoreboard
pending_hits	gpu-cache.h	/^    unsigned pending_hits;$/;"	m	struct:cache_sub_stats
pending_writes	dram.h	/^   unsigned int pending_writes;$/;"	m	class:dram_t
perfect_intra_warp_conflict_detection	shader.cc	/^active_mask_t tx_log_walker::perfect_intra_warp_conflict_detection(warp_inst_t &inst) $/;"	f	class:tx_log_walker
perfect_memory_interface	shader.h	/^    perfect_memory_interface( shader_core_ctx *core, simt_core_cluster *cluster ) { m_core=core; m_cluster=cluster; }$/;"	f	class:perfect_memory_interface
perfect_memory_interface	shader.h	/^class perfect_memory_interface : public mem_fetch_interface {$/;"	c
perform_intra_warp_cd_cycle	shader.cc	/^int tx_log_walker::warp_commit_tx_t::perform_intra_warp_cd_cycle() $/;"	f	class:tx_log_walker::warp_commit_tx_t
pipe_widths	shader.h	/^    int pipe_widths[N_PIPELINE_STAGES];$/;"	m	struct:shader_core_config
pipeline_stage_name_decode	shader.h	/^const char* const pipeline_stage_name_decode[] = {$/;"	v
pipeline_stage_name_t	shader.h	/^enum pipeline_stage_name_t {$/;"	g
pipeline_widths_string	shader.h	/^    char* pipeline_widths_string;$/;"	m	struct:shader_core_config
pipelined_simd_unit	shader.cc	/^pipelined_simd_unit::pipelined_simd_unit( register_set* result_port, const shader_core_config *config, unsigned max_latency,shader_core_ctx *core )$/;"	f	class:pipelined_simd_unit
pipelined_simd_unit	shader.h	/^class pipelined_simd_unit : public simd_function_unit {$/;"	c
pmem_exempt_kernel	gpu-sim.h	/^    char *pmem_exempt_kernel;$/;"	m	class:gpgpu_sim_config
pop	delayqueue.h	/^   T* pop() $/;"	f	class:fifo_pipeline
pop	gpu-cache.h	/^        T pop() $/;"	f	class:tex_cache::fifo
pop	l2cache.cc	/^mem_fetch* memory_sub_partition::pop() $/;"	f	class:memory_sub_partition
pop	l2cache.h	/^    void pop(addr_t addr) { $/;"	f	class:tm_req_stall_queue
pop	tm_conflict_detector.h	/^    mem_fetch *pop()$/;"	f	class:tm_tid_vendor
pop_coalesced_op	commit_unit.h	/^       void pop_coalesced_op() { m_coalesced_ops.pop_front(); }$/;"	f	class:commit_unit::cu_mem_acc
pop_coalesced_packet	mem_fetch.cc	/^void mem_fetch::pop_coalesced_packet() $/;"	f	class:mem_fetch
pop_commit_ready	shader.cc	/^void tx_log_walker::pop_commit_ready()$/;"	f	class:tx_log_walker
pop_stack	stack.cc	/^address_type pop_stack(Stack *S) {$/;"	f
port_available_cycles	gpu-cache.h	/^    unsigned long long port_available_cycles; $/;"	m	struct:cache_sub_stats
port_vector_t	shader.h	/^   typedef std::vector<register_set*> port_vector_t;$/;"	t	class:opndcoll_rfu_t
position_of_mrq_chosen	mem_latency_stat.h	/^   unsigned int *position_of_mrq_chosen; \/\/position of mrq in m_queue chosen $/;"	m	class:memory_stats_t
pow2_histogram	histogram.cc	/^pow2_histogram::pow2_histogram (std::string name, int nbins, int* bins) $/;"	f	class:pow2_histogram
pow2_histogram	histogram.h	/^class pow2_histogram : public binned_histogram {$/;"	c
power_config	gpu-sim.h	/^	power_config()$/;"	f	struct:power_config
power_config	gpu-sim.h	/^struct power_config {$/;"	s
power_core_stat_t	power_stat.cc	/^power_core_stat_t::power_core_stat_t( const struct shader_core_config *shader_config, shader_core_stats *core_stats )$/;"	f	class:power_core_stat_t
power_core_stat_t	power_stat.h	/^class power_core_stat_t : public shader_core_power_stats_pod {$/;"	c
power_mem_stat_t	power_stat.cc	/^power_mem_stat_t::power_mem_stat_t(const struct memory_config *mem_config, const struct shader_core_config *shdr_config, memory_stats_t *mem_stats, shader_core_stats *shdr_stats){$/;"	f	class:power_mem_stat_t
power_mem_stat_t	power_stat.h	/^class power_mem_stat_t : public mem_power_stats_pod{$/;"	c
power_stat_t	power_stat.cc	/^power_stat_t::power_stat_t( const struct shader_core_config *shader_config,float * average_pipeline_duty_cycle,float *active_sms,shader_core_stats * shader_stats, const struct memory_config *mem_config,memory_stats_t * memory_stats)$/;"	f	class:power_stat_t
power_stat_t	power_stat.h	/^class power_stat_t {$/;"	c
powli	addrdec.cc	/^static long int powli( long int x, long int y ) \/\/ compute x to the y$/;"	f	file:
pre_commit_validation	shader.cc	/^void tx_log_walker::pre_commit_validation(warp_inst_t &inst) $/;"	f	class:tx_log_walker
prefix_sum_bloom_filter_intra_warp_conflict_detection	shader.cc	/^active_mask_t tx_log_walker::prefix_sum_bloom_filter_intra_warp_conflict_detection(warp_inst_t &inst, $/;"	f	class:tx_log_walker
print	addrdec.cc	/^void addrdec_t::print( FILE *fp ) const$/;"	f	class:addrdec_t
print	coherence_manager.h	/^    void print(FILE *fout)$/;"	f	struct:coherence_cache_block_t
print	commit_unit.cc	/^void commit_entry::print(FILE *fout)$/;"	f	class:commit_entry
print	commit_unit.cc	/^void commit_unit_stats::cid_pointer_stats::print(FILE *fout)$/;"	f	class:commit_unit_stats::cid_pointer_stats
print	commit_unit.cc	/^void commit_unit_stats::print(FILE *fout)$/;"	f	class:commit_unit_stats
print	commit_unit.cc	/^void conflict_table_hash::print(FILE* fp, new_addr_type addr) {$/;"	f	class:conflict_table_hash
print	commit_unit.cc	/^void conflict_table_perfect::print(FILE *fp, new_addr_type addr) const$/;"	f	class:conflict_table_perfect
print	commit_unit.cc	/^void cu_access_set::print(FILE *fout) const $/;"	f	class:cu_access_set
print	delayqueue.h	/^   void print() const$/;"	f	class:fifo_pipeline
print	dram.cc	/^void dram_t::print( FILE* simFile) const$/;"	f	class:dram_t
print	dram_sched.cc	/^void frfcfs_scheduler::print( FILE *fp )$/;"	f	class:frfcfs_scheduler
print	gpu-cache.cc	/^void baseline_cache::print(FILE *fp, unsigned &accesses, unsigned &misses) const{$/;"	f	class:baseline_cache
print	gpu-cache.cc	/^void tag_array::print( FILE *stream, unsigned &total_access, unsigned &total_misses ) const$/;"	f	class:tag_array
print	gpu-cache.h	/^    void print( FILE *fp ) const$/;"	f	class:cache_config
print	gpu-cache.h	/^    void print(FILE *fout)$/;"	f	struct:cache_block_t
print	l2cache.cc	/^void memory_partition_unit::arbitration_metadata::print( FILE *fp ) const $/;"	f	class:memory_partition_unit::arbitration_metadata
print	l2cache.cc	/^void memory_partition_unit::print( FILE *fp ) const$/;"	f	class:memory_partition_unit
print	l2cache.cc	/^void memory_sub_partition::print( FILE *fp ) const$/;"	f	class:memory_sub_partition
print	mem_fetch.cc	/^void mem_fetch::print( FILE *fp, bool print_inst ) const$/;"	f	class:mem_fetch
print	power_stat.cc	/^void power_core_stat_t::print (FILE *fout)$/;"	f	class:power_core_stat_t
print	power_stat.cc	/^void power_mem_stat_t::print (FILE *fout) const {$/;"	f	class:power_mem_stat_t
print	power_stat.cc	/^void power_stat_t::print (FILE *fout) const$/;"	f	class:power_stat_t
print	scoreboard.cc	/^void global_scoreboard::print(FILE *fout) const $/;"	f	class:global_scoreboard
print	shader.cc	/^void history_file_t::print(FILE *fout) $/;"	f	class:history_file_t
print	shader.cc	/^void ldst_unit::print(FILE *fout) const$/;"	f	class:ldst_unit
print	shader.cc	/^void shader_core_stats::print( FILE* fout ) const$/;"	f	class:shader_core_stats
print	shader.cc	/^void shd_warp_t::print( FILE *fout ) const$/;"	f	class:shd_warp_t
print	shader.cc	/^void tx_log_walker::commit_tx_t::print(FILE *fout)$/;"	f	class:tx_log_walker::commit_tx_t
print	shader.cc	/^void tx_log_walker::print(FILE *fout)$/;"	f	class:tx_log_walker
print	shader.cc	/^void tx_log_walker::warp_commit_tx_t::print(FILE *fout)$/;"	f	class:tx_log_walker::warp_commit_tx_t
print	shader.cc	/^void tx_log_walker_stats::print( FILE *fout ) const$/;"	f	class:tx_log_walker_stats
print	shader.cc	/^void tx_log_walker_warpc::print(FILE *fout)$/;"	f	class:tx_log_walker_warpc
print	shader.cc	/^void warp_inst_t::print( FILE *fout ) const$/;"	f	class:warp_inst_t
print	shader.h	/^      void print(FILE *fout) {$/;"	f	struct:tx_log_walker::log_send_status_t
print	shader.h	/^    virtual void print( FILE *fp ) const$/;"	f	class:simd_function_unit
print	shader.h	/^    virtual void print(FILE *fp) const$/;"	f	class:pipelined_simd_unit
print	shader.h	/^   void print(FILE* fout, unsigned long long tot_cycles) const {$/;"	f	struct:thread_state_stat
print	stat-tool.cc	/^void linear_histogram_logger::print(FILE *fout) const$/;"	f	class:linear_histogram_logger
print	stat-tool.h	/^   void print(FILE *fout) const $/;"	f	class:insn_warp_occ_logger
print	stat-tool.h	/^   void print(FILE *fout) const {$/;"	f	class:linear_histogram_snapshot
print	traffic_breakdown.cc	/^void traffic_breakdown::print(FILE* fout)$/;"	f	class:traffic_breakdown
printContents	scoreboard.cc	/^void Scoreboard::printContents() const$/;"	f	class:Scoreboard
print_all_ld	visualizer.cc	/^   void print_all_ld(void) {$/;"	f	class:my_time_vector
print_all_st	visualizer.cc	/^   void print_all_st(void) {$/;"	f	class:my_time_vector
print_cache_stat	l2cache.cc	/^void memory_sub_partition::print_cache_stat(unsigned &accesses, unsigned &misses) const$/;"	f	class:memory_sub_partition
print_cache_stats	shader.cc	/^void ldst_unit::print_cache_stats( FILE *fp, unsigned& dl1_accesses, unsigned& dl1_misses ) {$/;"	f	class:ldst_unit
print_cache_stats	shader.cc	/^void shader_core_ctx::print_cache_stats( FILE *fp, unsigned& dl1_accesses, unsigned& dl1_misses ) {$/;"	f	class:shader_core_ctx
print_cache_stats	shader.cc	/^void simt_core_cluster::print_cache_stats( FILE *fp, unsigned& dl1_accesses, unsigned& dl1_misses ) const {$/;"	f	class:simt_core_cluster
print_dist	visualizer.cc	/^   void print_dist(void) {$/;"	f	class:my_time_vector
print_dram_stats	l2cache.cc	/^void gpgpu_sim::print_dram_stats(FILE *fout) const$/;"	f	class:gpgpu_sim
print_histo	stat-tool.cc	/^void thread_CFlocality::print_histo(FILE *fout) const$/;"	f	class:thread_CFlocality
print_histo	stat-tool.cc	/^void thread_insn_span::print_histo(FILE *fout) const$/;"	f	class:thread_insn_span
print_ibuffer	shader.cc	/^void shd_warp_t::print_ibuffer( FILE *fout ) const$/;"	f	class:shd_warp_t
print_icache_stats	shader.cc	/^void shader_core_ctx::print_icache_stats( FILE *fp, unsigned& il1_accesses, unsigned& il1_misses ) {$/;"	f	class:shader_core_ctx
print_icache_stats	shader.cc	/^void simt_core_cluster::print_icache_stats( FILE *fp, unsigned& il1_accesses, unsigned& il1_misses ) const {$/;"	f	class:simt_core_cluster
print_local_write_misses	gpu-cache.cc	/^void cache_sub_stats::print_local_write_misses(FILE *fout, const char *cache_name) const$/;"	f	class:cache_sub_stats
print_not_completed	shader.cc	/^void simt_core_cluster::print_not_completed( FILE *fp ) const$/;"	f	class:simt_core_cluster
print_port_stats	gpu-cache.cc	/^void cache_sub_stats::print_port_stats(FILE *fout, const char *cache_name) const$/;"	f	class:cache_sub_stats
print_sanity_counters	commit_unit.cc	/^void commit_unit::print_sanity_counters(FILE *fp)$/;"	f	class:commit_unit
print_set_util	gpu-cache.cc	/^void cache_sub_stats::print_set_util(FILE *fout, const char *cache_name) const$/;"	f	class:cache_sub_stats
print_span	stat-tool.cc	/^void thread_CFlocality::print_span(FILE *fout) const$/;"	f	class:thread_CFlocality
print_span	stat-tool.cc	/^void thread_insn_span::print_span(FILE *fout) const$/;"	f	class:thread_insn_span
print_sparse_histo	stat-tool.cc	/^void thread_insn_span::print_sparse_histo(FILE *fout) const$/;"	f	class:thread_insn_span
print_sparse_histo	stat-tool.cc	/^void thread_insn_span::print_sparse_histo(gzFile fout) const$/;"	f	class:thread_insn_span
print_stage	shader.cc	/^void shader_core_ctx::print_stage(unsigned int stage, FILE *fout ) const$/;"	f	class:shader_core_ctx
print_stat	dram.cc	/^void dram_t::print_stat( FILE* simFile ) $/;"	f	class:dram_t
print_stat	gpu-cache.cc	/^void mshr_table::print_stat( FILE *fp ) const $/;"	f	class:mshr_table
print_stat	l2cache.h	/^   void print_stat( FILE *fp ) { m_dram->print_stat(fp); }$/;"	f	class:memory_partition_unit
print_stats	coherence_manager.cc	/^void coherence_manager::print_stats(FILE *fp) {$/;"	f	class:coherence_manager
print_stats	gpu-cache.cc	/^void cache_stats::print_stats(FILE *fout, const char *cache_name) const{$/;"	f	class:cache_stats
print_stats	gpu-sim.cc	/^void gpgpu_sim::print_stats()$/;"	f	class:gpgpu_sim
print_to_file	visualizer.cc	/^   void print_to_file(FILE *outfile) {$/;"	f	class:my_time_vector
print_to_gzfile	visualizer.cc	/^   void print_to_gzfile(gzFile outfile) {$/;"	f	class:my_time_vector
print_visualizer	stat-tool.cc	/^void linear_histogram_logger::print_visualizer(FILE *fout)$/;"	f	class:linear_histogram_logger
print_visualizer	stat-tool.cc	/^void linear_histogram_logger::print_visualizer(gzFile fout)$/;"	f	class:linear_histogram_logger
print_visualizer	stat-tool.cc	/^void thread_CFlocality::print_visualizer(FILE *fout)  $/;"	f	class:thread_CFlocality
print_visualizer	stat-tool.cc	/^void thread_CFlocality::print_visualizer(gzFile fout)$/;"	f	class:thread_CFlocality
print_visualizer	stat-tool.h	/^   void print_visualizer(FILE *fout) const {$/;"	f	class:linear_histogram_snapshot
print_visualizer	stat-tool.h	/^   void print_visualizer(gzFile fout) const {$/;"	f	class:linear_histogram_snapshot
prio	dram.h	/^   unsigned int prio;$/;"	m	class:dram_t
probe	coherence_manager.cc	/^coherence_cache_request_status coherence_tag_array::probe( new_addr_type addr, unsigned &idx ) const$/;"	f	class:coherence_tag_array
probe	commit_unit.cc	/^bool conflict_table_hash::probe(new_addr_type addr, int& probed_entry_idx) const$/;"	f	class:conflict_table_hash
probe	gpu-cache.cc	/^bool mshr_table::probe( new_addr_type block_addr ) const{$/;"	f	class:mshr_table
probe	gpu-cache.cc	/^enum cache_request_status tag_array::probe( new_addr_type addr, unsigned &idx ) const$/;"	f	class:tag_array
process_L1D_mem_fetch	shader.cc	/^void tx_log_walker::process_L1D_mem_fetch(mem_fetch *mf)$/;"	f	class:tx_log_walker
process_banks	shader.h	/^   void process_banks()$/;"	f	class:opndcoll_rfu_t
process_cache_access	shader.cc	/^ldst_unit::process_cache_access( cache_t* cache,$/;"	f	class:ldst_unit
process_coalesced_input_parallel	commit_unit.cc	/^void commit_unit::process_coalesced_input_parallel( mem_fetch *input_msg, unsigned time )$/;"	f	class:commit_unit
process_coalesced_input_serial	commit_unit.cc	/^void commit_unit::process_coalesced_input_serial( mem_fetch *input_msg, unsigned time )$/;"	f	class:commit_unit
process_commit	shader.cc	/^bool tx_log_walker::process_commit(warp_inst_t &inst, $/;"	f	class:tx_log_walker
process_commit_op_reply	commit_unit.cc	/^void commit_unit::process_commit_op_reply(mem_fetch *mf, const cu_mem_acc &mem_op, unsigned time)$/;"	f	class:commit_unit
process_commit_op_reply	commit_unit.cc	/^void commit_unit_logical::process_commit_op_reply(mem_fetch *mf, const cu_mem_acc &mem_op, unsigned time)$/;"	f	class:commit_unit_logical
process_commit_unit_reply	shader.cc	/^bool tx_log_walker::process_commit_unit_reply(mem_fetch *mf)$/;"	f	class:tx_log_walker
process_commit_unit_reply	shader.cc	/^bool tx_log_walker_warpc::process_commit_unit_reply(mem_fetch *mf)$/;"	f	class:tx_log_walker_warpc
process_commit_unit_reply	shader.cc	/^bool tx_log_walker_warpc_logical::process_commit_unit_reply(mem_fetch *mf)$/;"	f	class:tx_log_walker_warpc_logical
process_cu_alloc_reply	shader.cc	/^void tx_log_walker::process_cu_alloc_reply(mem_fetch *mf)$/;"	f	class:tx_log_walker
process_cu_done_commit	shader.cc	/^void tx_log_walker::process_cu_done_commit(mem_fetch *mf)$/;"	f	class:tx_log_walker
process_cu_pass_fail	shader.cc	/^void tx_log_walker::process_cu_pass_fail(mem_fetch *mf) $/;"	f	class:tx_log_walker
process_input	commit_unit.cc	/^void commit_unit::process_input( mem_fetch *mf, unsigned time )$/;"	f	class:commit_unit
process_input	commit_unit.cc	/^void commit_unit_logical::process_input( mem_fetch *mf, unsigned time )$/;"	f	class:commit_unit_logical
process_memory_access_queue	shader.cc	/^mem_stage_stall_type ldst_unit::process_memory_access_queue( cache_t *cache, warp_inst_t &inst )$/;"	f	class:ldst_unit
process_tag_probe	gpu-cache.cc	/^data_cache::process_tag_probe( bool wr,$/;"	f	class:data_cache
process_validation_op_reply	commit_unit.cc	/^void commit_unit::process_validation_op_reply(mem_fetch *mf, const cu_mem_acc &mem_op, unsigned time)$/;"	f	class:commit_unit
profile_thread_states	shader.cc	/^void shader_core_ctx::profile_thread_states()$/;"	f	class:shader_core_ctx
push	delayqueue.h	/^   void push(T* data ) $/;"	f	class:fifo_pipeline
push	dram.cc	/^void dram_t::push( class mem_fetch *data ) $/;"	f	class:dram_t
push	gpu-cache.h	/^        unsigned push( const T &e ) $/;"	f	class:tex_cache::fifo
push	l2cache.cc	/^void memory_sub_partition::push( mem_fetch* req, unsigned long long cycle ) $/;"	f	class:memory_sub_partition
push	l2cache.h	/^        virtual void push(mem_fetch *mf) {$/;"	f	class:L2icnt_interface
push	l2cache.h	/^    virtual void push(mem_fetch *mf) $/;"	f	class:L2interface
push	l2cache.h	/^    void push(addr_t addr, logical_mem_fetch logical_mf) { m_stall_queue[addr].push(logical_mf); }$/;"	f	class:tm_req_stall_queue
push	shader.h	/^    virtual void push(mem_fetch *mf) $/;"	f	class:perfect_memory_interface
push	shader.h	/^    virtual void push(mem_fetch *mf) $/;"	f	class:shader_memory_interface
push	tm_conflict_detector.h	/^    void push( mem_fetch *mf )$/;"	f	class:tm_tid_vendor
push_response_fifo	shader.h	/^    void push_response_fifo(class mem_fetch *mf) {$/;"	f	class:simt_core_cluster
push_stack	stack.cc	/^void push_stack(Stack *S, address_type val) {$/;"	f
pwr_core_stat	power_stat.h	/^   power_core_stat_t * pwr_core_stat;$/;"	m	class:power_stat_t
pwr_mem_stat	power_stat.h	/^   power_mem_stat_t * pwr_mem_stat;$/;"	m	class:power_stat_t
quantize_address	commit_unit.cc	/^new_addr_type conflict_detector::quantize_address(new_addr_type addr)$/;"	f	class:conflict_detector
quantize_address	commit_unit.cc	/^new_addr_type conflict_table_perfect::quantize_address(new_addr_type addr)$/;"	f	class:conflict_table_perfect
que_length	dram.cc	/^unsigned dram_t::que_length() const$/;"	f	class:dram_t
queue_event	shader.h	/^      void queue_event(enum event_type evtype, unsigned metadata) {$/;"	f	class:tx_log_walker::iwcd_uarch_info
queue_limit	dram.cc	/^unsigned int dram_t::queue_limit() const $/;"	f	class:dram_t
rd_hit_base	gpu-cache.cc	/^data_cache::rd_hit_base( new_addr_type addr,$/;"	f	class:data_cache
rd_miss_base	gpu-cache.cc	/^data_cache::rd_miss_base( new_addr_type addr,$/;"	f	class:data_cache
read_counter	commit_unit.h	/^      unsigned read_counter;$/;"	m	struct:conflict_table_perfect::conflict_table_entry
read_log_front	shader.h	/^      log_send_status_t& read_log_front() { assert(not m_read_log_send_q.empty()); return m_read_log_send_q.front(); } $/;"	f	struct:tx_log_walker::commit_tx_t
read_log_sent	shader.cc	/^bool tx_log_walker::commit_tx_t::read_log_sent() { return m_read_log_send_q.empty(); }$/;"	f	class:tx_log_walker::commit_tx_t
read_only_cache	gpu-cache.h	/^    read_only_cache( const char *name, cache_config &config, int core_id, int type_id, mem_fetch_interface *memport, enum mem_fetch_status status )$/;"	f	class:read_only_cache
read_only_cache	gpu-cache.h	/^    read_only_cache( const char *name, cache_config &config, int core_id, int type_id, mem_fetch_interface *memport, enum mem_fetch_status status, tag_array* new_tag_array )$/;"	f	class:read_only_cache
read_only_cache	gpu-cache.h	/^class read_only_cache : public baseline_cache {$/;"	c
read_operands	shader.cc	/^void shader_core_ctx::read_operands()$/;"	f	class:shader_core_ctx
read_set	commit_unit.h	/^    const cu_access_set& read_set() const { return m_read_set; }$/;"	f	class:commit_entry
read_set	commit_unit.h	/^    cu_access_set& read_set() { return m_read_set; }$/;"	f	class:commit_entry
ready	shader.cc	/^bool opndcoll_rfu_t::collector_unit_t::ready() const $/;"	f	class:opndcoll_rfu_t::collector_unit_t
ready_cycle	l2cache.h	/^ 	unsigned long long ready_cycle;$/;"	m	struct:rop_delay_t
ready_cycle	l2cache.h	/^      unsigned long long ready_cycle;$/;"	m	struct:memory_partition_unit::dram_delay_t
recency_bloom_filter_intra_warp_conflict_detection	shader.cc	/^active_mask_t tx_log_walker::recency_bloom_filter_intra_warp_conflict_detection(warp_inst_t &inst, $/;"	f	class:tx_log_walker
record_cache_hit	commit_unit.cc	/^void commit_unit::record_cache_hit(enum cu_mem_op mem_op, enum cache_request_status status)$/;"	f	class:commit_unit
record_invalidation_stats	coherence_manager.cc	/^void coherence_manager::record_invalidation_stats(unsigned hwtid_owner, std::set<unsigned> invalidation_vector, bool is_tm_inst, bool write) {$/;"	f	class:coherence_manager
record_traffic	traffic_breakdown.cc	/^void traffic_breakdown::record_traffic(class mem_fetch * mf, unsigned int size) $/;"	f	class:traffic_breakdown
reg_hazard_table	scoreboard.h	/^    std::vector< std::map<unsigned,enum data_hazard_t> > reg_hazard_table;$/;"	m	class:Scoreboard
reg_options	commit_unit.cc	/^void commit_unit_options::reg_options(option_parser_t opp)$/;"	f	class:commit_unit_options
reg_options	gpu-sim.cc	/^void gpgpu_sim_config::reg_options(option_parser_t opp)$/;"	f	class:gpgpu_sim_config
reg_options	gpu-sim.cc	/^void memory_config::reg_options(class OptionParser * opp)$/;"	f	class:memory_config
reg_options	gpu-sim.cc	/^void power_config::reg_options(class OptionParser * opp)$/;"	f	class:power_config
reg_options	gpu-sim.cc	/^void shader_core_config::reg_options(class OptionParser * opp)$/;"	f	class:shader_core_config
reg_options	scoreboard.cc	/^   void reg_options(option_parser_t opp) {$/;"	f	class:scoreboard_options
reg_table	scoreboard.h	/^    std::vector< std::set<unsigned> > reg_table;$/;"	m	class:Scoreboard
register_bank	shader.cc	/^int register_bank(int regnum, int wid, unsigned num_banks, unsigned bank_warp_shift)$/;"	f
register_cta_thread_exit	shader.cc	/^void shader_core_ctx::register_cta_thread_exit( unsigned cta_num )$/;"	f	class:shader_core_ctx
register_read	commit_unit.cc	/^void conflict_detector::register_read(new_addr_type addr) {$/;"	f	class:conflict_detector
register_read	commit_unit.cc	/^void conflict_table_perfect::register_read(new_addr_type addr) {$/;"	f	class:conflict_table_perfect
reinit	shader.cc	/^void shader_core_ctx::reinit(unsigned start_thread, unsigned end_thread, bool reset_not_completed ) $/;"	f	class:shader_core_ctx
reinit	shader.cc	/^void simt_core_cluster::reinit()$/;"	f	class:simt_core_cluster
reinit_clock_domains	gpu-sim.cc	/^void gpgpu_sim::reinit_clock_domains(void)$/;"	f	class:gpgpu_sim
releaseRegister	scoreboard.cc	/^void Scoreboard::releaseRegister(unsigned wid, unsigned regnum) $/;"	f	class:Scoreboard
releaseRegisters	scoreboard.cc	/^void Scoreboard::releaseRegisters(const class warp_inst_t *inst) $/;"	f	class:Scoreboard
releaseTMRollback	scoreboard.cc	/^void Scoreboard::releaseTMRollback() $/;"	f	class:Scoreboard
releaseTMToken	scoreboard.cc	/^void Scoreboard::releaseTMToken(unsigned warp_id) $/;"	f	class:Scoreboard
release_token	scoreboard.cc	/^void global_scoreboard::release_token(unsigned sid, unsigned wid)$/;"	f	class:global_scoreboard
remove_sharer	coherence_manager.cc	/^bool coherence_manager::remove_sharer(unsigned hwtid, new_addr_type block_addr) {$/;"	f	class:coherence_manager
remove_snap_shot_trigger	stat-tool.cc	/^void remove_snap_shot_trigger (snap_shot_trigger* ss_trigger)$/;"	f
remove_spill_log	stat-tool.cc	/^void remove_spill_log (spill_log_interface* spill_log)$/;"	f
replacement_policy_t	gpu-cache.h	/^enum replacement_policy_t {$/;"	g
replenish_port_bandwidth	gpu-cache.cc	/^void baseline_cache::bandwidth_management::replenish_port_bandwidth()$/;"	f	class:baseline_cache::bandwidth_management
reply_abort	tm_conflict_detector.h	/^    void reply_abort( mem_fetch *mf )$/;"	f	class:tm_tid_vendor
reply_overflow_stop	tm_conflict_detector.h	/^    void reply_overflow_stop( mem_fetch *mf )$/;"	f	class:tm_tid_vendor
req	l2cache.h	/^ 	class mem_fetch* req;$/;"	m	struct:rop_delay_t	typeref:class:rop_delay_t::mem_fetch
req	l2cache.h	/^      class mem_fetch* req;$/;"	m	struct:memory_partition_unit::dram_delay_t	typeref:class:memory_partition_unit::dram_delay_t::mem_fetch
res_fails	gpu-cache.h	/^    unsigned res_fails;$/;"	m	struct:cache_sub_stats
reserveRegister	scoreboard.cc	/^void Scoreboard::reserveRegister(unsigned wid, unsigned regnum, data_hazard_t hazard_type)$/;"	f	class:Scoreboard
reserveRegisters	scoreboard.cc	/^void Scoreboard::reserveRegisters(const class warp_inst_t* inst) $/;"	f	class:Scoreboard
reserveTMRollback	scoreboard.cc	/^void Scoreboard::reserveTMRollback(unsigned warp_id, unsigned releasers) $/;"	f	class:Scoreboard
reserveTMToken	scoreboard.cc	/^void Scoreboard::reserveTMToken(const warp_inst_t *inst) $/;"	f	class:Scoreboard
reset	commit_unit.cc	/^void cu_access_set::reset()$/;"	f	class:cu_access_set
reset	commit_unit.cc	/^void warp_commit_entry::reset() $/;"	f	class:warp_commit_entry
reset	shader.h	/^      void reset() { m_allocation = NO_ALLOC; }$/;"	f	class:opndcoll_rfu_t::allocation_t
reset	shader.h	/^      void reset() { m_valid = false; m_is_transaction_dst = false; }$/;"	f	class:opndcoll_rfu_t::op_t
reset	shader.h	/^      void reset() {$/;"	f	class:tx_log_walker::iwcd_uarch_info
reset	shader.h	/^      void reset() {$/;"	f	struct:tx_log_walker::commit_tx_t
reset	shader.h	/^      void reset() {$/;"	f	struct:tx_log_walker::warp_commit_tx_t
reset	shader.h	/^    void reset()$/;"	f	class:shd_warp_t
reset	shader.h	/^   void reset() {$/;"	f	struct:thread_state_stat
reset	stat-tool.cc	/^void thread_insn_span::reset(unsigned long long  cycle) $/;"	f	class:thread_insn_span
reset	stat-tool.h	/^   void reset(unsigned long long  cycle) {$/;"	f	class:linear_histogram_snapshot
reset_alloction	shader.h	/^      void reset_alloction()$/;"	f	class:opndcoll_rfu_t::arbiter_t
reset_bins	histogram.cc	/^void binned_histogram::reset_bins () {$/;"	f	class:binned_histogram
reset_sharers	coherence_manager.h	/^    void reset_sharers() {$/;"	f	struct:coherence_directory_block_t
reset_stack	stack.cc	/^void reset_stack(Stack *S) {$/;"	f
resize_cache_array	coherence_manager.cc	/^void coherence_manager::resize_cache_array(unsigned new_size)$/;"	f	class:coherence_manager
resolve_intra_warp_cd	shader.cc	/^active_mask_t tx_log_walker::resolve_intra_warp_cd(warp_inst_t &inst, active_mask_t abort_mask)$/;"	f	class:tx_log_walker
response_buffer_full	shader.cc	/^bool ldst_unit::response_buffer_full() const$/;"	f	class:ldst_unit
response_queue_full	shader.h	/^    bool response_queue_full() {$/;"	f	class:simt_core_cluster
return_credit	l2cache.cc	/^void memory_partition_unit::arbitration_metadata::return_credit(int inner_sub_partition_id) $/;"	f	class:memory_partition_unit::arbitration_metadata
return_queue_pop	dram.cc	/^class mem_fetch* dram_t::return_queue_pop() $/;"	f	class:dram_t
return_queue_top	dram.cc	/^class mem_fetch* dram_t::return_queue_top() $/;"	f	class:dram_t
returnq	dram.h	/^   fifo_pipeline<mem_fetch> *returnq;$/;"	m	class:dram_t
returnq_full	dram.cc	/^bool dram_t::returnq_full() const$/;"	f	class:dram_t
revalidation	commit_unit.cc	/^void commit_unit::revalidation(commit_entry &ce)$/;"	f	class:commit_unit
rob_entry	gpu-cache.h	/^        rob_entry( unsigned i, mem_fetch *mf, new_addr_type a ) $/;"	f	struct:tex_cache::rob_entry
rob_entry	gpu-cache.h	/^        rob_entry() { m_ready = false; m_time=0; m_request=NULL; }$/;"	f	struct:tex_cache::rob_entry
rob_entry	gpu-cache.h	/^    struct rob_entry {$/;"	s	class:tex_cache
rollback_callback	shader.cc	/^void shader_core_ctx::rollback_callback( unsigned thread_id, unsigned warp_id, address_type pc ) $/;"	f	class:shader_core_ctx
rop_delay_t	l2cache.h	/^struct rop_delay_t$/;"	s
rop_latency	gpu-sim.h	/^   unsigned rop_latency;$/;"	m	struct:memory_config
row	addrdec.h	/^   unsigned row;$/;"	m	struct:addrdec_t
row	dram.h	/^   unsigned int row;$/;"	m	class:dram_req_t
row_access	mem_latency_stat.h	/^   unsigned int **row_access; \/\/row_access[dram chip id][bank id]$/;"	m	class:memory_stats_t
row_service_timestamp	dram_sched.h	/^   unsigned *row_service_timestamp; \/\/tracks when scheduler began servicing current row$/;"	m	class:frfcfs_scheduler
run_test	addrdec.h	/^   bool run_test; $/;"	m	class:linear_to_raw_address_translation
rw	dram.h	/^   unsigned char rw;    \/\/is the bank reading or writing?$/;"	m	struct:bank_t
rw	dram.h	/^   unsigned char rw;    \/\/is the request a read or a write?$/;"	m	class:dram_req_t
rw	dram.h	/^   unsigned char rw; \/\/was last request a read or write? (important for RTW, WTR)$/;"	m	class:dram_t
rwq	dram.h	/^   fifo_pipeline<dram_req_t> *rwq;$/;"	m	class:dram_t
s_CTA_count_logger	stat-tool.cc	/^static linear_histogram_logger *s_CTA_count_logger = NULL;$/;"	v	file:
s_cache_access_logger	stat-tool.cc	/^static std::vector<linear_histogram_logger> s_cache_access_logger;$/;"	v	file:
s_cache_access_logger_n_types	stat-tool.cc	/^static int s_cache_access_logger_n_types = 0;$/;"	v	file:
s_ids	stat-tool.cc	/^int insn_warp_occ_logger::s_ids = 0;$/;"	m	class:insn_warp_occ_logger	file:
s_ids	stat-tool.cc	/^int linear_histogram_logger::s_ids = 0;$/;"	m	class:linear_histogram_logger	file:
s_ids	stat-tool.h	/^   static int s_ids;$/;"	m	class:insn_warp_occ_logger
s_ids	stat-tool.h	/^   static int s_ids;$/;"	m	class:linear_histogram_logger
s_mem_acc_logger	stat-tool.cc	/^static std::vector<linear_histogram_logger> s_mem_acc_logger;$/;"	v	file:
s_mem_acc_logger_n_bank	stat-tool.cc	/^static int s_mem_acc_logger_n_bank = 0;$/;"	v	file:
s_mem_acc_logger_n_dram	stat-tool.cc	/^static int s_mem_acc_logger_n_dram = 0;$/;"	v	file:
s_mem_lat_logger	stat-tool.cc	/^static std::vector<linear_histogram_logger> s_mem_lat_logger;$/;"	v	file:
s_mem_lat_logger_nbins	stat-tool.cc	/^static int s_mem_lat_logger_nbins = 48;     \/\/ up to 2^24 = 16M$/;"	v	file:
s_mem_lat_logger_used	stat-tool.cc	/^static bool s_mem_lat_logger_used = false;$/;"	v	file:
s_n_commited	shader.cc	/^unsigned tx_log_walker::s_n_commited = 0; $/;"	m	class:tx_log_walker	file:
s_n_commited	shader.h	/^   static unsigned s_n_commited; $/;"	m	class:tx_log_walker
s_next_commit_id	shader.cc	/^unsigned tx_log_walker::warp_commit_tx_t::s_next_commit_id = 1; \/\/ reserve 0?$/;"	m	class:tx_log_walker::warp_commit_tx_t	file:
s_next_commit_id	shader.h	/^      static unsigned int s_next_commit_id;$/;"	m	struct:tx_log_walker::warp_commit_tx_t
s_null_id	shader.cc	/^   static const int s_null_id = -1; $/;"	m	class:ownership_table	file:
s_warp_occ_logger	stat-tool.cc	/^static std::vector<linear_histogram_logger> s_warp_occ_logger;$/;"	v	file:
sample_cache_port_utility	gpu-cache.cc	/^void cache_stats::sample_cache_port_utility(bool data_port_busy, bool fill_port_busy) $/;"	f	class:cache_stats
save_stats	power_stat.cc	/^void power_core_stat_t::save_stats(){$/;"	f	class:power_core_stat_t
save_stats	power_stat.cc	/^void power_mem_stat_t::save_stats(){$/;"	f	class:power_mem_stat_t
save_stats	power_stat.h	/^   void save_stats(){$/;"	f	class:power_stat_t
schedule	dram_sched.cc	/^dram_req_t *frfcfs_scheduler::schedule( unsigned bank, unsigned curr_row )$/;"	f	class:frfcfs_scheduler
scheduler_fifo	dram.cc	/^void dram_t::scheduler_fifo()$/;"	f	class:dram_t
scheduler_frfcfs	dram_sched.cc	/^void dram_t::scheduler_frfcfs()$/;"	f	class:dram_t
scheduler_prioritization_type	shader.h	/^enum scheduler_prioritization_type$/;"	g
scheduler_type	gpu-sim.h	/^   enum dram_ctrl_t scheduler_type;$/;"	m	struct:memory_config	typeref:enum:memory_config::dram_ctrl_t
scheduler_unit	shader.h	/^    scheduler_unit(shader_core_stats* stats, shader_core_ctx* shader, $/;"	f	class:scheduler_unit
scheduler_unit	shader.h	/^class scheduler_unit { \/\/this can be copied freely, so can be used in std containers.$/;"	c
schedulers	shader.h	/^    std::vector<scheduler_unit*>  schedulers;$/;"	m	class:shader_core_ctx
scoreboard_options	scoreboard.cc	/^class scoreboard_options $/;"	c	file:
scoreboard_reg_options	scoreboard.cc	/^void scoreboard_reg_options(option_parser_t opp)$/;"	f
scrub_retired_commit_entries	commit_unit.cc	/^void commit_unit::scrub_retired_commit_entries() $/;"	f	class:commit_unit
select_active_warp	shader.cc	/^int tx_log_walker_warpc::select_active_warp() $/;"	f	class:tx_log_walker_warpc
select_kernel	gpu-sim.cc	/^kernel_info_t *gpgpu_sim::select_kernel()$/;"	f	class:gpgpu_sim
select_stats_status	gpu-cache.cc	/^enum cache_request_status cache_stats::select_stats_status(enum cache_request_status probe, enum cache_request_status access) const {$/;"	f	class:cache_stats
send_coalesced_packet	shader.cc	/^void tx_log_walker::send_coalesced_packet()$/;"	f	class:tx_log_walker
send_coalesced_packet	shader.cc	/^void tx_log_walker_warpc::send_coalesced_packet()$/;"	f	class:tx_log_walker_warpc
send_commit_ack	commit_unit.h	/^    void send_commit_ack() { m_commit_ack_sent = true; }$/;"	f	class:commit_entry
send_log_entry	shader.cc	/^bool tx_log_walker::send_log_entry( const warp_inst_t& inst, unsigned thread_id, int commit_id, $/;"	f	class:tx_log_walker
send_read_request	gpu-cache.cc	/^void baseline_cache::send_read_request(new_addr_type addr, new_addr_type block_addr, unsigned cache_index, mem_fetch *mf,$/;"	f	class:baseline_cache
send_reply	commit_unit.cc	/^void commit_unit::send_reply( unsigned sid, unsigned tpc, unsigned wid, unsigned commit_id, enum mf_type reply_type )$/;"	f	class:commit_unit
send_reply	commit_unit.h	/^    void send_reply() { $/;"	f	class:commit_entry
send_reply_coalesced	commit_unit.cc	/^void commit_unit::send_reply_coalesced( unsigned sid, unsigned tpc, unsigned wid, unsigned commit_id, enum mf_type reply_type )$/;"	f	class:commit_unit
send_reply_scalar	commit_unit.cc	/^void commit_unit::send_reply_scalar( unsigned sid, unsigned tpc, unsigned wid, unsigned commit_id, enum mf_type reply_type )$/;"	f	class:commit_unit
send_to_L2	commit_unit.cc	/^void commit_unit::send_to_L2(unsigned long long time, commit_unit::cu_mem_acc mem_op)$/;"	f	class:commit_unit
send_tx_pass_fail	shader.cc	/^void tx_log_walker::send_tx_pass_fail(warp_commit_tx_t &cmt_warp, int warp_id, int thread_id)$/;"	f	class:tx_log_walker
send_tx_pass_fail	shader.cc	/^void tx_log_walker_warpc::send_tx_pass_fail(warp_commit_tx_t &cmt_warp, int warp_id, int thread_id)$/;"	f	class:tx_log_walker_warpc
send_write_request	gpu-cache.cc	/^void data_cache::send_write_request(mem_fetch *mf, cache_event request, unsigned time, std::list<cache_event> &events){$/;"	f	class:data_cache
sent	shader.h	/^      bool sent; $/;"	m	struct:tx_log_walker::log_send_status_t
sent_commit_write	commit_unit.h	/^    void sent_commit_write() { m_n_commit_write_pending += 1; }$/;"	f	class:commit_entry
sent_validation	commit_unit.h	/^    void sent_validation() { m_n_validation_pending += 1; }$/;"	f	class:commit_entry
set_addr	mem_fetch.h	/^   void set_addr(new_addr_type addr) { m_access.set_addr(addr); }$/;"	f	class:mem_fetch
set_cache_config	gpu-sim.cc	/^void gpgpu_sim::set_cache_config(std::string kernel_name)$/;"	f	class:gpgpu_sim
set_cache_config	gpu-sim.cc	/^void gpgpu_sim::set_cache_config(std::string kernel_name,  FuncCache cacheConfig )$/;"	f	class:gpgpu_sim
set_commit_id	mem_fetch.h	/^   void set_commit_id( int cid ) { m_commit_id = cid; }$/;"	f	class:mem_fetch
set_commit_pending_ptr	commit_unit.h	/^    void set_commit_pending_ptr(std::bitset<16>* commit_pending) { m_commit_pending_flag = commit_pending; }$/;"	f	class:commit_entry
set_commit_pending_ptr	mem_fetch.h	/^   void set_commit_pending_ptr(std::bitset<16> *commit_pending) { m_commit_pending_flag = commit_pending; }$/;"	f	class:mem_fetch
set_commit_unit_generated	mem_fetch.h	/^   void set_commit_unit_generated() { m_commit_unit_generated = true; }$/;"	f	class:mem_fetch
set_completed	shader.h	/^    void set_completed( unsigned lane ) $/;"	f	class:shd_warp_t
set_cycle	stat-tool.h	/^   void set_cycle(unsigned long long  cycle) { m_cycle = cycle; }$/;"	f	class:linear_histogram_snapshot
set_data_size	mem_fetch.h	/^   void     set_data_size( unsigned size ) { m_data_size=size; }$/;"	f	class:mem_fetch
set_done	l2cache.cc	/^void memory_partition_unit::set_done( mem_fetch *mf )$/;"	f	class:memory_partition_unit
set_done	l2cache.cc	/^void memory_sub_partition::set_done( mem_fetch *mf )$/;"	f	class:memory_sub_partition
set_done_exit	shader.h	/^    void set_done_exit() { m_done_exit=true; }$/;"	f	class:shd_warp_t
set_dram_power_stats	dram.cc	/^void dram_t::set_dram_power_stats(	unsigned &cmd,$/;"	f	class:dram_t
set_dram_power_stats	l2cache.cc	/^void memory_partition_unit::set_dram_power_stats(unsigned &n_cmd,$/;"	f	class:memory_partition_unit
set_fail	commit_unit.h	/^    void set_fail() { m_fail = true; } \/\/ used only by fail_at_revalidation$/;"	f	class:commit_entry
set_final	commit_unit.h	/^    void set_final(bool pass) { m_final_pass = pass; }$/;"	f	class:commit_entry
set_icnt_receive_time	mem_fetch.h	/^   void set_icnt_receive_time( unsigned t ) { m_icnt_receive_time=t; }$/;"	f	class:mem_fetch
set_id	stat-tool.h	/^   void set_id(int id) { m_id = id; }$/;"	f	class:insn_warp_occ_logger
set_id	stat-tool.h	/^   void set_id(int id) { m_id = id; }$/;"	f	class:linear_histogram_logger
set_imiss_pending	shader.h	/^    void set_imiss_pending() { m_imiss_pending=true; }$/;"	f	class:shd_warp_t
set_index	gpu-cache.cc	/^unsigned cache_config::set_index( new_addr_type addr ) const$/;"	f	class:cache_config
set_index	gpu-cache.cc	/^unsigned l2_cache_config::set_index(new_addr_type addr) const{$/;"	f	class:l2_cache_config
set_index_hashed	gpu-cache.cc	/^unsigned cache_config::set_index_hashed( new_addr_type addr ) const$/;"	f	class:cache_config
set_is_aborted	mem_fetch.h	/^   void set_is_aborted() { m_is_aborted = true; }$/;"	f	class:mem_fetch
set_is_stalled	mem_fetch.h	/^   void set_is_stalled() { m_is_stalled = true; }$/;"	f	class:mem_fetch
set_is_transactional	mem_fetch.h	/^   void set_is_transactional() { m_transactional=true; }$/;"	f	class:mem_fetch
set_kernel	shader.cc	/^void shader_core_ctx::set_kernel( kernel_info_t *k ) $/;"	f	class:shader_core_ctx
set_kernel_done	gpu-sim.cc	/^void gpgpu_sim::set_kernel_done( kernel_info_t *kernel ) $/;"	f	class:gpgpu_sim
set_last_fetch	shader.h	/^    void set_last_fetch( unsigned long long sim_cycle ) { m_last_fetch=sim_cycle; }$/;"	f	class:shd_warp_t
set_max_cta	shader.cc	/^void shader_core_ctx::set_max_cta( const kernel_info_t &kernel ) $/;"	f	class:shader_core_ctx
set_mem_fetch_pts	mem_fetch.h	/^   void set_mem_fetch_pts(unsigned long long pts) { mem_fetch_pts = pts; }$/;"	f	class:mem_fetch
set_membar	shader.h	/^    void set_membar() { m_membar=true; }$/;"	f	class:shd_warp_t
set_memory_partition_id	mem_fetch.h	/^   void set_memory_partition_id( unsigned chip ) { m_raw_addr.chip=chip; }$/;"	f	class:mem_fetch
set_min_length	delayqueue.h	/^   void set_min_length(unsigned int new_min_len) $/;"	f	class:fifo_pipeline
set_next_pc	shader.h	/^    void set_next_pc( address_type pc ) { m_next_pc = pc; }$/;"	f	class:shd_warp_t
set_perfect_memory	shader.h	/^    void set_perfect_memory(bool activate) $/;"	f	class:simt_core_cluster
set_perfect_memory	shader.h	/^   void set_perfect_memory(bool perfect_memory) $/;"	f	class:shader_core_ctx
set_prop	gpu-sim.cc	/^void gpgpu_sim::set_prop( cudaDeviceProp *prop )$/;"	f	class:gpgpu_sim
set_reply	mem_fetch.h	/^   void set_reply() $/;"	f	class:mem_fetch
set_retire_cid_at_fill	commit_unit.h	/^    void set_retire_cid_at_fill( int retire_ptr ) { m_retire_ptr_at_fill = retire_ptr; }$/;"	f	class:commit_entry
set_return_timestamp	mem_fetch.h	/^   void set_return_timestamp( unsigned t ) { m_timestamp2=t; }$/;"	f	class:mem_fetch
set_revalidate	commit_unit.h	/^    void set_revalidate(bool revalidate) { $/;"	f	class:commit_entry
set_size	commit_unit.h	/^       void set_size(new_addr_type new_size) { $/;"	f	class:commit_unit::cu_mem_acc
set_skip	commit_unit.h	/^    void set_skip() { m_skip_entry = true; }$/;"	f	class:commit_entry
set_span	stat-tool.cc	/^void thread_insn_span::set_span( address_type pc ) $/;"	f	class:thread_insn_span
set_spill_interval	stat-tool.cc	/^void set_spill_interval (unsigned long long  interval)$/;"	f
set_stall_addr	mem_fetch.h	/^   void set_stall_addr(addr_t addr) { m_stall_at_addr = addr; }$/;"	f	class:mem_fetch
set_stalled_uid	mem_fetch.h	/^   void set_stalled_uid(int uid) { m_stalled_uid = uid; }$/;"	f	class:mem_fetch
set_state	commit_unit.cc	/^void commit_entry::set_state(enum commit_state state)$/;"	f	class:commit_entry
set_status	mem_fetch.cc	/^void mem_fetch::set_status( enum mem_fetch_status status, unsigned long long cycle ) $/;"	f	class:mem_fetch
set_sub_partition_id	mem_fetch.h	/^   void set_sub_partition_id( unsigned sub_partition ) { m_raw_addr.sub_partition = sub_partition; }$/;"	f	class:mem_fetch
set_timestamp_file	commit_unit.h	/^    void set_timestamp_file(FILE *timestamp_file, int mpid) { m_timestamp_file = timestamp_file; m_mpid = mpid; } $/;"	f	class:commit_entry
set_tm_manager	commit_unit.cc	/^void commit_entry::set_tm_manager(class tm_manager_inf* tm_manager)$/;"	f	class:commit_entry
set_tm_manager_ptr	mem_fetch.h	/^   void set_tm_manager_ptr(class tm_manager_inf * p_tm_manager) { m_tm_manager = p_tm_manager; }$/;"	f	class:mem_fetch
set_transaction_id	mem_fetch.h	/^   void set_transaction_id( unsigned trid ) { m_transaction_id=trid; }$/;"	f	class:mem_fetch
set_tx_origin	commit_unit.cc	/^void commit_entry::set_tx_origin(int sid, int tpc, int wid) $/;"	f	class:commit_entry
set_type	mem_fetch.h	/^   void set_type( enum mf_type t ) { m_type=t; }$/;"	f	class:mem_fetch
set_youngest_conflicting_commit_id	commit_unit.h	/^    void set_youngest_conflicting_commit_id (int youngest_commit_id) {$/;"	f	class:commit_entry
setup_log	shader.cc	/^void tx_log_walker::commit_tx_t::setup_log(const tm_warp_info &warp_info, bool read_log, bool write_log)$/;"	f	class:tx_log_walker::commit_tx_t
sfu	shader.cc	/^sfu:: sfu(  register_set* result_port, const shader_core_config *config,shader_core_ctx *core  )$/;"	f	class:sfu
sfu	shader.h	/^class sfu : public pipelined_simd_unit$/;"	c
shader_CTA_count_create	stat-tool.cc	/^void shader_CTA_count_create( int n_shaders, unsigned long long  logging_interval)$/;"	f
shader_CTA_count_log	stat-tool.cc	/^void shader_CTA_count_log( int shader_id, int nCTAadded )$/;"	f
shader_CTA_count_print	stat-tool.cc	/^void shader_CTA_count_print( FILE *fout )$/;"	f
shader_CTA_count_unlog	stat-tool.cc	/^void shader_CTA_count_unlog( int shader_id, int nCTAdone )$/;"	f
shader_CTA_count_visualizer_gzprint	stat-tool.cc	/^void shader_CTA_count_visualizer_gzprint( gzFile fout )$/;"	f
shader_CTA_count_visualizer_print	stat-tool.cc	/^void shader_CTA_count_visualizer_print( FILE *fout )$/;"	f
shader_cache_access_create	stat-tool.cc	/^void shader_cache_access_create( int n_loggers, int n_types, unsigned long long  logging_interval)$/;"	f
shader_cache_access_log	stat-tool.cc	/^void shader_cache_access_log( int logger_id, int type, int miss)$/;"	f
shader_cache_access_print	stat-tool.cc	/^void shader_cache_access_print( FILE *fout )$/;"	f
shader_cache_access_unlog	stat-tool.cc	/^void shader_cache_access_unlog( int logger_id, int type, int miss)$/;"	f
shader_clock	gpu-sim.cc	/^int gpgpu_sim::shader_clock() const$/;"	f	class:gpgpu_sim
shader_config	gpu-sim.h	/^    const shader_core_config &shader_config() const { return m_shader_config; }$/;"	f	class:gpgpu_sim_config
shader_core	shader.h	/^   shader_core_ctx *shader_core() { return m_shader; }$/;"	f	class:opndcoll_rfu_t
shader_core_config	shader.h	/^    shader_core_config(){$/;"	f	struct:shader_core_config
shader_core_config	shader.h	/^struct shader_core_config : public core_config$/;"	s
shader_core_ctx	shader.cc	/^shader_core_ctx::shader_core_ctx( class gpgpu_sim *gpu, $/;"	f	class:shader_core_ctx
shader_core_ctx	shader.h	/^class shader_core_ctx : public core_t {$/;"	c
shader_core_mem_fetch_allocator	shader.h	/^    shader_core_mem_fetch_allocator( unsigned core_id, unsigned cluster_id, const memory_config *config )$/;"	f	class:shader_core_mem_fetch_allocator
shader_core_mem_fetch_allocator	shader.h	/^class shader_core_mem_fetch_allocator : public mem_fetch_allocator {$/;"	c
shader_core_power_stats_pod	power_stat.h	/^struct shader_core_power_stats_pod {$/;"	s
shader_core_stats	shader.cc	/^shader_core_stats::shader_core_stats( const shader_core_config *config )$/;"	f	class:shader_core_stats
shader_core_stats	shader.h	/^class shader_core_stats : public shader_core_stats_pod {$/;"	c
shader_core_stats_pod	shader.h	/^struct shader_core_stats_pod {$/;"	s
shader_core_stats_pod_start	shader.h	/^	void* shader_core_stats_pod_start[]; \/\/ DO NOT MOVE FROM THE TOP - spaceless pointer to the start of this structure$/;"	m	struct:shader_core_stats_pod
shader_cycle_distro	shader.h	/^    unsigned *shader_cycle_distro;$/;"	m	struct:shader_core_stats_pod
shader_cycles	shader.h	/^	unsigned long long *shader_cycles;$/;"	m	struct:shader_core_stats_pod
shader_mem_acc_create	stat-tool.cc	/^void shader_mem_acc_create( int n_loggers, int n_dram, int n_bank, unsigned long long  logging_interval)$/;"	f
shader_mem_acc_log	stat-tool.cc	/^void shader_mem_acc_log( int logger_id, int dram_id, int bank, char rw)$/;"	f
shader_mem_acc_print	stat-tool.cc	/^void shader_mem_acc_print( FILE *fout )$/;"	f
shader_mem_acc_snapshot	stat-tool.cc	/^void shader_mem_acc_snapshot( int logger_id, unsigned long long  current_cycle)$/;"	f
shader_mem_lat_create	stat-tool.cc	/^void shader_mem_lat_create( int n_loggers, unsigned long long  logging_interval)$/;"	f
shader_mem_lat_log	stat-tool.cc	/^void shader_mem_lat_log( int logger_id, int latency)$/;"	f
shader_mem_lat_print	stat-tool.cc	/^void shader_mem_lat_print( FILE *fout )$/;"	f
shader_mem_lat_snapshot	stat-tool.cc	/^void shader_mem_lat_snapshot( int logger_id, unsigned long long  current_cycle)$/;"	f
shader_memory_interface	shader.h	/^    shader_memory_interface( shader_core_ctx *core, simt_core_cluster *cluster ) { m_core=core; m_cluster=cluster; }$/;"	f	class:shader_memory_interface
shader_memory_interface	shader.h	/^class shader_memory_interface : public mem_fetch_interface {$/;"	c
shader_print_cache_stats	shader.cc	/^void gpgpu_sim::shader_print_cache_stats( FILE *fout ) const{$/;"	f	class:gpgpu_sim
shader_print_il1_miss_stat	shader.cc	/^void gpgpu_sim::shader_print_il1_miss_stat( FILE *fout ) const$/;"	f	class:gpgpu_sim
shader_print_scheduler_stat	shader.cc	/^void gpgpu_sim::shader_print_scheduler_stat( FILE* fout, bool print_dynamic_info ) const$/;"	f	class:gpgpu_sim
shader_warp_occ_create	stat-tool.cc	/^void shader_warp_occ_create( int n_loggers, int simd_width, unsigned long long  logging_interval)$/;"	f
shader_warp_occ_log	stat-tool.cc	/^void shader_warp_occ_log( int logger_id, int warp_occ)$/;"	f
shader_warp_occ_print	stat-tool.cc	/^void shader_warp_occ_print( FILE *fout )$/;"	f
shader_warp_occ_snapshot	stat-tool.cc	/^void shader_warp_occ_snapshot( int logger_id, unsigned long long  current_cycle)$/;"	f
shared_cycle	shader.cc	/^bool ldst_unit::shared_cycle( warp_inst_t &inst, mem_stage_stall_type &rc_fail, mem_stage_access_type &fail_type)$/;"	f	class:ldst_unit
shared_mem_size	gpu-sim.cc	/^int gpgpu_sim::shared_mem_size() const$/;"	f	class:gpgpu_sim
shd_warp_t	shader.h	/^    shd_warp_t( class shader_core_ctx *shader, unsigned warp_size) $/;"	f	class:shd_warp_t
shd_warp_t	shader.h	/^class shd_warp_t {$/;"	c
shmem_read_access	power_stat.h	/^    unsigned *shmem_read_access[NUM_STAT_IDX];   \/\/ Shared memory access$/;"	m	struct:mem_power_stats_pod
sid_to_cid	shader.h	/^    unsigned sid_to_cid( unsigned sid )     const { return sid % n_simt_cores_per_cluster; }$/;"	f	struct:shader_core_config
sid_to_cluster	shader.h	/^    unsigned sid_to_cluster( unsigned sid ) const { return sid \/ n_simt_cores_per_cluster; }$/;"	f	struct:shader_core_config
signal_commit_done	commit_unit.cc	/^void warp_commit_entry::signal_commit_done(const commit_entry& cmt_entry) $/;"	f	class:warp_commit_entry
signal_final_outcome	commit_unit.cc	/^void warp_commit_entry::signal_final_outcome(const commit_entry& cmt_entry) $/;"	f	class:warp_commit_entry
signal_hazard_detection_read_done	commit_unit.cc	/^void warp_commit_entry::signal_hazard_detection_read_done(const commit_entry& cmt_entry)$/;"	f	class:warp_commit_entry
signal_hazard_detection_write_done	commit_unit.cc	/^void warp_commit_entry::signal_hazard_detection_write_done(const commit_entry& cmt_entry)$/;"	f	class:warp_commit_entry
signal_stalled	shader.cc	/^void tx_log_walker::warp_commit_tx_t::signal_stalled() $/;"	f	class:tx_log_walker::warp_commit_tx_t
signal_validation_done	commit_unit.cc	/^void warp_commit_entry::signal_validation_done(const commit_entry& cmt_entry)$/;"	f	class:warp_commit_entry
simd_function_unit	shader.cc	/^simd_function_unit::simd_function_unit( const shader_core_config *config )$/;"	f	class:simd_function_unit
simd_function_unit	shader.h	/^class simd_function_unit {$/;"	c
simd_model	gpu-sim.cc	/^enum divergence_support_t gpgpu_sim::simd_model() const$/;"	f	class:gpgpu_sim
simplescoreboard	shader.h	/^    bool simplescoreboard; $/;"	m	struct:shader_core_config
simt_core_cluster	shader.cc	/^simt_core_cluster::simt_core_cluster( class gpgpu_sim *gpu, $/;"	f	class:simt_core_cluster
simt_core_cluster	shader.h	/^class simt_core_cluster {$/;"	c
simt_core_sim_order	shader.h	/^    int simt_core_sim_order; $/;"	m	struct:shader_core_config
size	commit_unit.h	/^       new_addr_type size;$/;"	m	class:commit_unit::cu_mem_acc
size	commit_unit.h	/^   int size() const { return m_active_entries; }$/;"	f	class:conflict_table_perfect
size	commit_unit.h	/^   int size() const { return m_conflict_table_perfect.size(); }$/;"	f	class:conflict_detector
size	gpu-cache.h	/^        unsigned size() const { return m_num; }$/;"	f	class:tex_cache::fifo
size	gpu-cache.h	/^    unsigned size() const { return m_config.get_num_lines(); }$/;"	f	class:tag_array
size	l2cache.h	/^    unsigned size(addr_t addr) {   $/;"	f	class:tm_req_stall_queue
size	mem_fetch.h	/^   unsigned size() const { return m_data_size+m_ctrl_size; }$/;"	f	class:mem_fetch
size_stack	stack.cc	/^int size_stack(Stack *S) {$/;"	f
skip_tx_log_walker	shader.h	/^    bool skip_tx_log_walker;$/;"	m	struct:shader_core_config
sm_next_mf_request_uid	mem_fetch.cc	/^unsigned mem_fetch::sm_next_mf_request_uid=1;$/;"	m	class:mem_fetch	file:
sm_next_mf_request_uid	mem_fetch.h	/^   static unsigned sm_next_mf_request_uid;$/;"	m	class:mem_fetch
snap_shot	stat-tool.cc	/^void linear_histogram_logger::snap_shot(unsigned long long  current_cycle) {$/;"	f	class:linear_histogram_logger
snap_shot	stat-tool.cc	/^void thread_CFlocality::snap_shot(unsigned long long  current_cycle) $/;"	f	class:thread_CFlocality
snap_shot_trigger	stat-tool.h	/^   snap_shot_trigger(unsigned long long  interval) : m_snap_shot_interval(interval) {}$/;"	f	class:snap_shot_trigger
snap_shot_trigger	stat-tool.h	/^class snap_shot_trigger {$/;"	c
snoop_mem_fetch_reply	commit_unit.cc	/^bool commit_unit::snoop_mem_fetch_reply(mem_fetch *mf)$/;"	f	class:commit_unit
sort_warps_by_oldest_dynamic_id	shader.cc	/^bool scheduler_unit::sort_warps_by_oldest_dynamic_id(shd_warp_t* lhs, shd_warp_t* rhs)$/;"	f	class:scheduler_unit
sp_unit	shader.cc	/^sp_unit::sp_unit( register_set* result_port, const shader_core_config *config,shader_core_ctx *core)$/;"	f	class:sp_unit
sp_unit	shader.h	/^class sp_unit : public pipelined_simd_unit$/;"	c
span_count_map	stat-tool.h	/^   typedef tr1_hash_map<address_type, int> span_count_map;$/;"	t	class:thread_insn_span
spill	stat-tool.cc	/^void linear_histogram_logger::spill(FILE *fout, bool final) $/;"	f	class:linear_histogram_logger
spill	stat-tool.cc	/^void thread_CFlocality::spill(FILE *fout, bool final) $/;"	f	class:thread_CFlocality
spill_interval	stat-tool.cc	/^static unsigned long long  spill_interval = 0;$/;"	v	file:
spill_log_interface	stat-tool.h	/^   spill_log_interface() {}$/;"	f	class:spill_log_interface
spill_log_interface	stat-tool.h	/^class spill_log_interface {$/;"	c
spill_log_to_file	stat-tool.cc	/^void spill_log_to_file (FILE *fout, int final, unsigned long long  current_cycle)$/;"	f
st_time_dist	visualizer.cc	/^   std::vector<double>  st_time_dist;$/;"	m	class:my_time_vector	file:
st_time_map	visualizer.cc	/^   std::map< unsigned int, std::vector<long int> > st_time_map;$/;"	m	class:my_time_vector	file:
st_vector_size	visualizer.cc	/^   unsigned st_vector_size;$/;"	m	class:my_time_vector	file:
stallable	shader.h	/^    virtual bool stallable() const { return false; }$/;"	f	class:pipelined_simd_unit
stallable	shader.h	/^    virtual bool stallable() const { return true; }$/;"	f	class:ldst_unit
stalled	mem_fetch.h	/^   bool stalled() const { return m_stalled_mask.any(); }$/;"	f	class:mem_fetch
stalled	mem_fetch.h	/^   bool stalled(int lane) const { return m_stalled_mask.test(lane); }$/;"	f	class:mem_fetch
stalled	shader.h	/^      bool stalled() const { return m_stalled; }$/;"	f	struct:tx_log_walker::warp_commit_tx_t
startTMCommit	scoreboard.cc	/^void Scoreboard::startTMCommit(unsigned warp_id) $/;"	f	class:Scoreboard
startTxCommit	scoreboard.cc	/^void Scoreboard::startTxCommit(unsigned warp_id)$/;"	f	class:Scoreboard
start_commit_state	commit_unit.cc	/^void commit_unit::start_commit_state(commit_entry &ce)$/;"	f	class:commit_unit
start_rollback	shader.h	/^   void start_rollback() $/;"	f	class:history_file_t
stat_idx	power_stat.h	/^}stat_idx;$/;"	t	typeref:enum:_stat_idx
stat_out	coherence_manager.h	/^    FILE *stat_out;         \/\/ File for dumping snapshot statistics$/;"	m	class:coherence_manager
state	dram.h	/^   unsigned char state; \/\/is the bank active or idle?$/;"	m	struct:bank_t
step	shader.h	/^   void step()$/;"	f	class:opndcoll_rfu_t
store_ack	shader.cc	/^void shader_core_ctx::store_ack( class mem_fetch *mf )$/;"	f	class:shader_core_ctx
store_write	commit_unit.cc	/^bool conflict_table_hash::store_write(new_addr_type addr, int cid, new_addr_type& evicted_addr, int& evicted_cid)$/;"	f	class:conflict_table_hash
store_write	commit_unit.cc	/^void conflict_detector::store_write(new_addr_type addr, int cid) $/;"	f	class:conflict_detector
store_write	commit_unit.cc	/^void conflict_table_perfect::store_write(new_addr_type addr, int cid) {$/;"	f	class:conflict_table_perfect
stores_done	shader.h	/^    bool stores_done() const { return m_stores_outstanding == 0; }$/;"	f	class:shd_warp_t
sub_partition	addrdec.h	/^   unsigned sub_partition; $/;"	m	struct:addrdec_t
sub_partition_id_mask	addrdec.h	/^   new_addr_type sub_partition_id_mask; $/;"	m	class:linear_to_raw_address_translation
subsample	stat-tool.h	/^   void subsample(int pos) {$/;"	f	class:linear_histogram_snapshot
sweep_test	addrdec.cc	/^void linear_to_raw_address_translation::sweep_test() const$/;"	f	class:linear_to_raw_address_translation
swl_scheduler	shader.cc	/^swl_scheduler::swl_scheduler ( shader_core_stats* stats, shader_core_ctx* shader,$/;"	f	class:swl_scheduler
swl_scheduler	shader.h	/^class swl_scheduler : public scheduler_unit {$/;"	c
tCCD	gpu-sim.h	/^   unsigned tCCD;   \/\/column to column delay$/;"	m	struct:memory_config
tCCDL	gpu-sim.h	/^   unsigned tCCDL;  \/\/column to column delay when bank groups are enabled$/;"	m	struct:memory_config
tCDLR	gpu-sim.h	/^   unsigned tCDLR;  \/\/Last data-in to Read command (switching from write to read)$/;"	m	struct:memory_config
tRAS	gpu-sim.h	/^   unsigned tRAS;   \/\/time needed to activate row$/;"	m	struct:memory_config
tRC	gpu-sim.h	/^   unsigned tRC;    \/\/row cycle time ie. precharge current, then activate different row$/;"	m	struct:memory_config
tRCD	gpu-sim.h	/^   unsigned tRCD;   \/\/row to column delay - time required to activate a row before a read$/;"	m	struct:memory_config
tRCDWR	gpu-sim.h	/^   unsigned tRCDWR; \/\/row to column delay for a write command$/;"	m	struct:memory_config
tRP	gpu-sim.h	/^   unsigned tRP;    \/\/row precharge ie. deactivate row$/;"	m	struct:memory_config
tRRD	gpu-sim.h	/^   unsigned tRRD;   \/\/minimal time required between activation of rows in different banks$/;"	m	struct:memory_config
tRTPL	gpu-sim.h	/^   unsigned tRTPL;  \/\/read to precharge delay when bank groups are enabled for GDDR5 this is identical to RTPS, if for other DRAM this is different, you will need to split them in two$/;"	m	struct:memory_config
tRTW	gpu-sim.h	/^   unsigned tRTW;   \/\/time to switch from read to write$/;"	m	struct:memory_config
tWR	gpu-sim.h	/^   unsigned tWR;    \/\/Last data-in to Row precharge $/;"	m	struct:memory_config
tWTP	gpu-sim.h	/^   unsigned tWTP;   \/\/time to switch from write to precharge in the same bank$/;"	m	struct:memory_config
tWTR	gpu-sim.h	/^   unsigned tWTR;   \/\/time to switch from write to read $/;"	m	struct:memory_config
table	gpu-cache.h	/^    typedef tr1_hash_map<new_addr_type,mshr_entry> table;$/;"	t	class:mshr_table
tag	gpu-cache.h	/^    new_addr_type tag( new_addr_type addr ) const$/;"	f	class:cache_config
tag_array	gpu-cache.cc	/^tag_array::tag_array( cache_config &config,$/;"	f	class:tag_array
tag_array	gpu-cache.h	/^class tag_array {$/;"	c
test_res_bus	shader.cc	/^int shader_core_ctx::test_res_bus(int latency){$/;"	f	class:shader_core_ctx
tex_cache	gpu-cache.h	/^    tex_cache( const char *name, cache_config &config, int core_id, int type_id, mem_fetch_interface *memport,$/;"	f	class:tex_cache
tex_cache	gpu-cache.h	/^class tex_cache : public cache_t {$/;"	c
texture_cycle	shader.cc	/^bool ldst_unit::texture_cycle( warp_inst_t &inst, mem_stage_stall_type &rc_fail, mem_stage_access_type &fail_type)$/;"	f	class:ldst_unit
thread_CFlocality	stat-tool.cc	/^thread_CFlocality::thread_CFlocality(std::string name, $/;"	f	class:thread_CFlocality
thread_CFlocality	stat-tool.h	/^class thread_CFlocality : public snap_shot_trigger, public spill_log_interface {$/;"	c
thread_CFlogger	stat-tool.cc	/^static thread_CFlocality** thread_CFlogger = NULL;$/;"	v	file:
thread_ctx_t	shader.h	/^   thread_ctx_t() :$/;"	f	class:thread_ctx_t
thread_ctx_t	shader.h	/^class thread_ctx_t {$/;"	c
thread_insn_span	stat-tool.cc	/^thread_insn_span::thread_insn_span(const thread_insn_span& other)$/;"	f	class:thread_insn_span
thread_insn_span	stat-tool.cc	/^thread_insn_span::thread_insn_span(unsigned long long  cycle)$/;"	f	class:thread_insn_span
thread_insn_span	stat-tool.h	/^class thread_insn_span {$/;"	c
thread_state	shader.h	/^enum thread_state {$/;"	g
thread_state_cas_lock	shader.h	/^    bool thread_state_cas_lock;$/;"	m	struct:shader_core_config
thread_state_cas_lock_free_value	shader.h	/^    int thread_state_cas_lock_free_value;$/;"	m	struct:shader_core_config
thread_state_profiling	shader.h	/^    bool thread_state_profiling;$/;"	m	struct:shader_core_config
thread_state_stat	shader.h	/^   thread_state_stat(const char * name) : m_name(name), m_state_cycles(N_THREAD_STATE) {}$/;"	f	struct:thread_state_stat
thread_state_stat	shader.h	/^struct thread_state_stat {$/;"	s
threads_per_core	gpu-sim.cc	/^unsigned gpgpu_sim::threads_per_core() const $/;"	f	class:gpgpu_sim
time_vector_create	visualizer.cc	/^void time_vector_create(int size) {$/;"	f
time_vector_print	visualizer.cc	/^void time_vector_print(void) {$/;"	f
time_vector_print_interval2gzfile	visualizer.cc	/^void time_vector_print_interval2gzfile(gzFile outfile) {$/;"	f
time_vector_update	visualizer.cc	/^void time_vector_update(unsigned int uid,int slot ,long int cycle,int type) {$/;"	f
timestamp	dram.h	/^   unsigned int timestamp;$/;"	m	class:dram_req_t
timing_mode_vb_commit	shader.h	/^    bool timing_mode_vb_commit; $/;"	m	struct:shader_core_config
tlb_request_status	stats.h	/^enum tlb_request_status {$/;"	g
tlw_coalesce_packets	shader.h	/^    bool tlw_coalesce_packets; \/\/ coalescing out-going packets $/;"	m	struct:shader_core_config
tlw_fast_log_read	shader.h	/^    bool tlw_fast_log_read; \/\/ assume cache hit for all log reads at commit $/;"	m	struct:shader_core_config
tlw_intra_warp_cd_concurrency	shader.h	/^    unsigned tlw_intra_warp_cd_concurrency; \/\/ number of concurrent intra warp conflict detection supported per core $/;"	m	struct:shader_core_config
tlw_intra_warp_cd_type	shader.h	/^    unsigned tlw_intra_warp_cd_type; \/\/ type of intra warp conflict detection $/;"	m	struct:shader_core_config
tlw_intra_warp_conflict_detection	shader.h	/^    bool tlw_intra_warp_conflict_detection; \/\/ intra warp conflict detection before log traversal $/;"	m	struct:shader_core_config
tlw_mark_check_ownership_size	shader.h	/^    unsigned tlw_mark_check_ownership_size; \/\/ size of ownership table used in mark and check $/;"	m	struct:shader_core_config
tlw_pre_commit_validation	shader.h	/^    bool tlw_pre_commit_validation; \/\/ ideal value based validation before log traversal$/;"	m	struct:shader_core_config
tlw_prioritize_ack	shader.h	/^    bool tlw_prioritize_ack; \/\/ prioritize the TX_PASS nad TX_FAIL acks$/;"	m	struct:shader_core_config
tlw_tcd_whitelist_only	shader.h	/^    bool tlw_tcd_whitelist_only; \/\/ validation before log traversal only pass and not abort tx $/;"	m	struct:shader_core_config
tlw_timing_model	shader.h	/^    unsigned tlw_timing_model; \/\/ timing model in use$/;"	m	struct:shader_core_config
tlw_use_logical_temporal_cd	shader.h	/^    bool tlw_use_logical_temporal_cd; \/\/ use logical temporal conflict detection in pre-commit validation $/;"	m	struct:shader_core_config
tlw_use_temporal_cd	shader.h	/^    bool tlw_use_temporal_cd; \/\/ use temporal conflict detection in pre-commit validation $/;"	m	struct:shader_core_config
tlw_watched	shader.cc	/^bool tlw_watched(int m_commit_id)$/;"	f
tm_aborted	coherence_manager.cc	/^void coherence_manager::tm_aborted(unsigned hwtid, ptx_thread_info* thread_state) {$/;"	f	class:coherence_manager
tm_commited	coherence_manager.cc	/^void coherence_manager::tm_commited(unsigned hwtid, unsigned hwwarpid, ptx_thread_info* thread_state) {$/;"	f	class:coherence_manager
tm_conflict_detector	tm_conflict_detector.h	/^    tm_conflict_detector( cache_config &config, mem_fetch_interface *port, const shader_core_config *shader_config, $/;"	f	class:tm_conflict_detector
tm_conflict_detector	tm_conflict_detector.h	/^class tm_conflict_detector {$/;"	c
tm_debug_printf	commit_unit.cc	2010;"	d	file:
tm_debug_printf	commit_unit.cc	2012;"	d	file:
tm_req_stall_queue	l2cache.h	/^    tm_req_stall_queue(unsigned long size) { m_size = size; }$/;"	f	class:tm_req_stall_queue
tm_req_stall_queue	l2cache.h	/^class tm_req_stall_queue {$/;"	c
tm_stall_queue	l2cache.h	/^typedef std::priority_queue<logical_mem_fetch, logical_mem_fetch_container, logical_mem_fetch_compare> tm_stall_queue;$/;"	t
tm_tid_vendor	tm_conflict_detector.h	/^    tm_tid_vendor( const shader_core_config *shader_config ) $/;"	f	class:tm_tid_vendor
tm_tid_vendor	tm_conflict_detector.h	/^class tm_tid_vendor {$/;"	c
tm_uarch_model	shader.h	/^    unsigned tm_uarch_model; \/\/ level of detail $/;"	m	struct:shader_core_config
tm_warp_commited	coherence_manager.cc	/^void coherence_manager::tm_warp_commited(unsigned hwwarpid) {$/;"	f	class:coherence_manager
tm_warp_level_gmem_view	shader.h	/^    bool tm_warp_level_gmem_view; \/\/ threads in transactional warp view the same global memory $/;"	m	struct:shader_core_config
tm_warp_scoreboard_token	shader.h	/^    bool tm_warp_scoreboard_token; $/;"	m	struct:shader_core_config
top	delayqueue.h	/^   T* top() const$/;"	f	class:fifo_pipeline
top	l2cache.cc	/^mem_fetch* memory_sub_partition::top(bool &internal) $/;"	f	class:memory_sub_partition
top	l2cache.h	/^    mem_fetch *top(addr_t addr) {$/;"	f	class:tm_req_stall_queue
top	stack.h	/^   int top;$/;"	m	struct:__anon5
top	tm_conflict_detector.h	/^    mem_fetch *top()$/;"	f	class:tm_tid_vendor
top_stack	stack.cc	/^address_type top_stack(Stack *S) {$/;"	f
tot_cycles	shader.h	/^   unsigned long long tot_cycles() {$/;"	f	struct:thread_state_stat
total_n_access	mem_latency_stat.h	/^   unsigned total_n_access;$/;"	m	class:memory_stats_t
total_n_reads	mem_latency_stat.h	/^   unsigned total_n_reads;$/;"	m	class:memory_stats_t
total_n_writes	mem_latency_stat.h	/^   unsigned total_n_writes;$/;"	m	class:memory_stats_t
totalbankaccesses	mem_latency_stat.h	/^   unsigned int **totalbankaccesses; \/\/bankaccesses[dram chip id][bank id]$/;"	m	class:memory_stats_t
totalbankreads	mem_latency_stat.h	/^   unsigned int **totalbankreads; \/\/bankreads[dram chip id][bank id]$/;"	m	class:memory_stats_t
totalbankwrites	mem_latency_stat.h	/^   unsigned int **totalbankwrites; \/\/bankwrites[dram chip id][bank id]$/;"	m	class:memory_stats_t
traffic_breakdown	traffic_breakdown.h	/^   traffic_breakdown(const std::string &network_name) $/;"	f	class:traffic_breakdown
traffic_breakdown	traffic_breakdown.h	/^class traffic_breakdown$/;"	c
traffic_class_t	traffic_breakdown.h	/^   typedef std::map < mf_packet_size, unsigned int > traffic_class_t; $/;"	t	class:traffic_breakdown
traffic_stat_t	traffic_breakdown.h	/^   typedef std::map < mf_packet_type, traffic_class_t > traffic_stat_t; $/;"	t	class:traffic_breakdown
transfer_ops_to_queue	commit_unit.cc	/^void commit_unit::transfer_ops_to_queue(enum cu_mem_op operation)$/;"	f	class:commit_unit
translate_local_memaddr	shader.cc	/^address_type shader_core_ctx::translate_local_memaddr(address_type localaddr, unsigned tid, unsigned data_size ) {$/;"	f	class:shader_core_ctx
translate_local_memaddr	shader.cc	/^unsigned shader_core_ctx::translate_local_memaddr( address_type localaddr, unsigned tid, unsigned num_shader, unsigned datasize, new_addr_type* translated_addrs )$/;"	f	class:shader_core_ctx
try_snap_shot	stat-tool.cc	/^void try_snap_shot (unsigned long long  current_cycle)$/;"	f
try_snap_shot	stat-tool.h	/^   void try_snap_shot(unsigned long long  current_cycle) {$/;"	f	class:snap_shot_trigger
two_level_active_scheduler	shader.h	/^	two_level_active_scheduler ( shader_core_stats* stats, shader_core_ctx* shader,$/;"	f	class:two_level_active_scheduler
two_level_active_scheduler	shader.h	/^class two_level_active_scheduler : public scheduler_unit {$/;"	c
tx_load_access	gpu-cache.cc	/^enum cache_request_status l1_cache::tx_load_access( new_addr_type addr, mem_fetch *mf, unsigned time, std::list<cache_event> &events )$/;"	f	class:l1_cache
tx_load_fill	gpu-cache.cc	/^void l1_cache::tx_load_fill( mem_fetch *mf, unsigned time )$/;"	f	class:l1_cache
tx_log_walker	shader.cc	/^tx_log_walker::tx_log_walker(shader_core_ctx *core, $/;"	f	class:tx_log_walker
tx_log_walker	shader.h	/^class tx_log_walker$/;"	c
tx_log_walker_stats	shader.cc	/^   tx_log_walker_stats() $/;"	f	class:tx_log_walker_stats
tx_log_walker_stats	shader.cc	/^class tx_log_walker_stats$/;"	c	file:
tx_log_walker_warpc	shader.cc	/^tx_log_walker_warpc::tx_log_walker_warpc(shader_core_ctx *core, $/;"	f	class:tx_log_walker_warpc
tx_log_walker_warpc	shader.h	/^class tx_log_walker_warpc : public tx_log_walker $/;"	c
tx_log_walker_warpc_logical	shader.cc	/^tx_log_walker_warpc_logical::tx_log_walker_warpc_logical(shader_core_ctx *core, $/;"	f	class:tx_log_walker_warpc_logical
tx_log_walker_warpc_logical	shader.h	/^class tx_log_walker_warpc_logical : public tx_log_walker_warpc {$/;"	c
txbytes	dram.h	/^   unsigned int txbytes;$/;"	m	class:dram_req_t
uarch_event	shader.h	/^         uarch_event(enum event_type evtype, unsigned metadata) $/;"	f	class:tx_log_walker::iwcd_uarch_info::uarch_event
uarch_event	shader.h	/^      class uarch_event {$/;"	c	class:tx_log_walker::iwcd_uarch_info
uint_vector_t	shader.h	/^   typedef std::vector<unsigned int> uint_vector_t;$/;"	t	class:opndcoll_rfu_t
unlog	stat-tool.h	/^   void unlog(int pos) { m_curr_lin_hist.subsample(pos); }$/;"	f	class:linear_histogram_logger
update_cache_parameters	gpu-cache.cc	/^void tag_array::update_cache_parameters(cache_config &config)$/;"	f	class:tag_array
update_cache_parameters	gpu-cache.h	/^	void update_cache_parameters(cache_config &config)$/;"	f	class:baseline_cache
update_ld	visualizer.cc	/^   void update_ld(unsigned int uid,unsigned int slot, long int time) { $/;"	f	class:my_time_vector
update_skip_vector	tm_conflict_detector.h	/^    void update_skip_vector( unsigned tid )$/;"	f	class:tm_conflict_detector
update_st	visualizer.cc	/^   void update_st(unsigned int uid,unsigned int slot, long int time) { $/;"	f	class:my_time_vector
update_stats	gpu-sim.cc	/^void gpgpu_sim::update_stats() {$/;"	f	class:gpgpu_sim
update_thread_pc	stat-tool.cc	/^void thread_CFlocality::update_thread_pc( int thread_id, address_type pc ) $/;"	f	class:thread_CFlocality
update_version	commit_unit.cc	/^void cu_access_set::update_version(new_addr_type addr, int version)$/;"	f	class:cu_access_set
update_youngest_conflicting_commit_id	commit_unit.cc	/^void commit_unit::update_youngest_conflicting_commit_id(int conflictor_id, commit_entry &reval_ce)$/;"	f	class:commit_unit
use_data_port	gpu-cache.cc	/^void baseline_cache::bandwidth_management::use_data_port(mem_fetch *mf, enum cache_request_status outcome, const std::list<cache_event> &events)$/;"	f	class:baseline_cache::bandwidth_management
use_fill_port	gpu-cache.cc	/^void baseline_cache::bandwidth_management::use_fill_port(mem_fetch *mf)$/;"	f	class:baseline_cache::bandwidth_management
v	stack.h	/^   address_type *v;$/;"	m	struct:__anon5
valid	commit_unit.h	/^      bool valid;$/;"	m	struct:conflict_table_hash::conflict_table_hash_entry
valid	shader.h	/^      bool valid() const { return m_valid; }$/;"	f	class:opndcoll_rfu_t::op_t
validate	shader.h	/^      void validate() {$/;"	f	struct:tx_log_walker::log_send_status_t
validation_pending	commit_unit.h	/^    bool validation_pending() const { return (m_n_validation_pending != 0); }$/;"	f	class:commit_entry
validation_return	commit_unit.cc	/^void commit_entry::validation_return(bool pass)$/;"	f	class:commit_entry
visualize	dram.cc	/^void dram_t::visualize() const$/;"	f	class:dram_t
visualize	l2cache.h	/^   void visualize() const { m_dram->visualize(); }$/;"	f	class:memory_partition_unit
visualizer_print	commit_unit.cc	/^void commit_unit::visualizer_print(gzFile visualizer_file)$/;"	f	class:commit_unit
visualizer_print	dram.cc	/^void dram_t::visualizer_print( gzFile visualizer_file )$/;"	f	class:dram_t
visualizer_print	l2cache.cc	/^void memory_partition_unit::visualizer_print( gzFile visualizer_file ) const $/;"	f	class:memory_partition_unit
visualizer_print	l2cache.cc	/^void memory_stats_t::visualizer_print( gzFile visualizer_file )$/;"	f	class:memory_stats_t
visualizer_print	l2cache.cc	/^void memory_sub_partition::visualizer_print( gzFile visualizer_file )$/;"	f	class:memory_sub_partition
visualizer_print	power_stat.cc	/^void power_core_stat_t::visualizer_print( gzFile visualizer_file )$/;"	f	class:power_core_stat_t
visualizer_print	power_stat.cc	/^void power_mem_stat_t::visualizer_print( gzFile power_visualizer_file ){$/;"	f	class:power_mem_stat_t
visualizer_print	power_stat.cc	/^void power_stat_t::visualizer_print( gzFile visualizer_file )$/;"	f	class:power_stat_t
visualizer_print	shader.cc	/^void shader_core_stats::visualizer_print( gzFile visualizer_file )$/;"	f	class:shader_core_stats
visualizer_printstat	visualizer.cc	/^void gpgpu_sim::visualizer_printstat()$/;"	f	class:gpgpu_sim
waiting	shader.cc	/^bool shd_warp_t::waiting() $/;"	f	class:shd_warp_t
waiting_for_fill	gpu-cache.cc	/^bool baseline_cache::waiting_for_fill( mem_fetch *mf ){$/;"	f	class:baseline_cache
warp	shader.cc	/^shd_warp_t& scheduler_unit::warp(int i){$/;"	f	class:scheduler_unit
warp_commit_entry	commit_unit.cc	/^warp_commit_entry::warp_commit_entry(int sid, int wid) $/;"	f	class:warp_commit_entry
warp_commit_entry	commit_unit.h	/^class warp_commit_entry$/;"	c
warp_commit_entry_table	commit_unit.h	/^    typedef std::map< std::pair<int, int>, warp_commit_entry> warp_commit_entry_table; $/;"	t	class:commit_unit
warp_commit_tx_t	shader.h	/^      warp_commit_tx_t() { reset(); }$/;"	f	struct:tx_log_walker::warp_commit_tx_t
warp_commit_tx_t	shader.h	/^   struct warp_commit_tx_t {$/;"	s	class:tx_log_walker
warp_exit	shader.cc	/^void barrier_set_t::warp_exit( unsigned warp_id )$/;"	f	class:barrier_set_t
warp_exit	shader.cc	/^void shader_core_ctx::warp_exit( unsigned warp_id )$/;"	f	class:shader_core_ctx
warp_inst_complete	shader.cc	/^void shader_core_ctx::warp_inst_complete(const warp_inst_t &inst)$/;"	f	class:shader_core_ctx
warp_reaches_barrier	shader.cc	/^void barrier_set_t::warp_reaches_barrier( unsigned cta_id, unsigned warp_id )$/;"	f	class:barrier_set_t
warp_set_t	shader.h	/^typedef std::bitset<WARP_PER_CTA_MAX> warp_set_t;$/;"	t
warp_waiting_at_barrier	shader.cc	/^bool barrier_set_t::warp_waiting_at_barrier( unsigned warp_id ) const$/;"	f	class:barrier_set_t
warp_waiting_at_barrier	shader.cc	/^bool shader_core_ctx::warp_waiting_at_barrier( unsigned warp_id ) const$/;"	f	class:shader_core_ctx
warp_waiting_at_mem_barrier	shader.cc	/^bool shader_core_ctx::warp_waiting_at_mem_barrier( unsigned warp_id ) $/;"	f	class:shader_core_ctx
warps_need_clean_num_writing	shader.cc	/^active_mask_t shader_core_ctx::warps_need_clean_num_writing(unsigned wid) {$/;"	f	class:shader_core_ctx
was_read_sent	gpu-cache.cc	/^bool was_read_sent( const std::list<cache_event> &events )$/;"	f
was_revalidate_set	commit_unit.h	/^    bool was_revalidate_set() const { return m_revalidate_set; }$/;"	f	class:commit_entry
was_skip	commit_unit.h	/^    bool was_skip() const { return m_skip_entry; }$/;"	f	class:commit_entry
was_write_sent	gpu-cache.cc	/^bool was_write_sent( const std::list<cache_event> &events )$/;"	f
was_writeback_sent	gpu-cache.cc	/^bool was_writeback_sent( const std::list<cache_event> &events )$/;"	f
wb_addr	l2cache.h	/^   unsigned long long int wb_addr;$/;"	m	class:memory_sub_partition
were_delayfcd_writes_stored	commit_unit.h	/^    bool were_delayfcd_writes_stored() const { return m_delayfcd_writes_stored > 0; }$/;"	f	class:commit_entry
wid_from_hw_tid	shader.h	/^inline unsigned wid_from_hw_tid(unsigned tid, unsigned warp_size){return tid\/warp_size;};$/;"	f
windowed_miss_rate	gpu-cache.cc	/^float tag_array::windowed_miss_rate( ) const$/;"	f	class:tag_array
word_size	commit_unit.h	/^       static const new_addr_type word_size = 4; $/;"	m	class:commit_unit::cu_mem_acc
wr_hit_global_we_local_wb	gpu-cache.cc	/^enum cache_request_status data_cache::wr_hit_global_we_local_wb(new_addr_type addr, unsigned cache_index, mem_fetch *mf, unsigned time, std::list<cache_event> &events, enum cache_request_status status ){$/;"	f	class:data_cache
wr_hit_wb	gpu-cache.cc	/^cache_request_status data_cache::wr_hit_wb(new_addr_type addr, unsigned cache_index, mem_fetch *mf, unsigned time, std::list<cache_event> &events, enum cache_request_status status ){$/;"	f	class:data_cache
wr_hit_we	gpu-cache.cc	/^cache_request_status data_cache::wr_hit_we(new_addr_type addr, unsigned cache_index, mem_fetch *mf, unsigned time, std::list<cache_event> &events, enum cache_request_status status ){$/;"	f	class:data_cache
wr_hit_wt	gpu-cache.cc	/^cache_request_status data_cache::wr_hit_wt(new_addr_type addr, unsigned cache_index, mem_fetch *mf, unsigned time, std::list<cache_event> &events, enum cache_request_status status ){$/;"	f	class:data_cache
wr_miss_be_wa	gpu-cache.cc	/^enum cache_request_status data_cache::wr_miss_be_wa(new_addr_type addr, unsigned cache_index, mem_fetch *mf, unsigned time, std::list<cache_event> &events, enum cache_request_status status ){$/;"	f	class:data_cache
wr_miss_no_wa	gpu-cache.cc	/^data_cache::wr_miss_no_wa( new_addr_type addr,$/;"	f	class:data_cache
wr_miss_wa	gpu-cache.cc	/^data_cache::wr_miss_wa( new_addr_type addr,$/;"	f	class:data_cache
write_allocate_policy_t	gpu-cache.h	/^enum write_allocate_policy_t {$/;"	g
write_log_front	shader.h	/^      log_send_status_t& write_log_front() { assert(not m_write_log_send_q.empty()); return m_write_log_send_q.front(); }$/;"	f	struct:tx_log_walker::commit_tx_t
write_log_sent	shader.cc	/^bool tx_log_walker::commit_tx_t::write_log_sent() { return m_write_log_send_q.empty(); }$/;"	f	class:tx_log_walker::commit_tx_t
write_policy_t	gpu-cache.h	/^enum write_policy_t {$/;"	g
write_set	commit_unit.h	/^    const cu_access_set& write_set() const { return m_write_set; }$/;"	f	class:commit_entry
write_set	commit_unit.h	/^    cu_access_set& write_set() { return m_write_set; }$/;"	f	class:commit_entry
writeback	shader.cc	/^bool opndcoll_rfu_t::writeback( const warp_inst_t &inst )$/;"	f	class:opndcoll_rfu_t
writeback	shader.cc	/^void ldst_unit::writeback()$/;"	f	class:ldst_unit
writeback	shader.cc	/^void shader_core_ctx::writeback()$/;"	f	class:shader_core_ctx
wrp_size	gpu-sim.cc	/^int gpgpu_sim::wrp_size() const$/;"	f	class:gpgpu_sim
~L2interface	l2cache.h	/^    virtual ~L2interface() {}$/;"	f	class:L2interface
~Scoreboard	scoreboard.h	/^    virtual ~Scoreboard() { }$/;"	f	class:Scoreboard
~baseline_cache	gpu-cache.h	/^    virtual ~baseline_cache()$/;"	f	class:baseline_cache
~binned_histogram	histogram.cc	/^binned_histogram::~binned_histogram () {$/;"	f	class:binned_histogram
~cache_t	gpu-cache.h	/^    virtual ~cache_t() {}$/;"	f	class:cache_t
~coherence_manager	coherence_manager.cc	/^coherence_manager::~coherence_manager()$/;"	f	class:coherence_manager
~coherence_tag_array	coherence_manager.cc	/^coherence_tag_array::~coherence_tag_array()$/;"	f	class:coherence_tag_array
~commit_unit	commit_unit.cc	/^commit_unit::~commit_unit()$/;"	f	class:commit_unit
~commit_unit_logical	commit_unit.h	/^    ~commit_unit_logical() {}; $/;"	f	class:commit_unit_logical
~conflict_detector	commit_unit.cc	/^conflict_detector::~conflict_detector()$/;"	f	class:conflict_detector
~conflict_table_hash	commit_unit.cc	/^conflict_table_hash::~conflict_table_hash()$/;"	f	class:conflict_table_hash
~cu_access_set	commit_unit.cc	/^cu_access_set::~cu_access_set()$/;"	f	class:cu_access_set
~data_cache	gpu-cache.h	/^    virtual ~data_cache() {}$/;"	f	class:data_cache
~fifo	gpu-cache.h	/^        ~fifo() $/;"	f	class:tex_cache::fifo
~fifo_pipeline	delayqueue.h	/^   ~fifo_pipeline() $/;"	f	class:fifo_pipeline
~gto_scheduler	shader.h	/^	virtual ~gto_scheduler () {}$/;"	f	class:gto_scheduler
~insn_warp_occ_logger	stat-tool.h	/^   ~insn_warp_occ_logger() {}$/;"	f	class:insn_warp_occ_logger
~l1_cache	gpu-cache.h	/^    virtual ~l1_cache(){}$/;"	f	class:l1_cache
~l2_cache	gpu-cache.h	/^    virtual ~l2_cache() {}$/;"	f	class:l2_cache
~linear_histogram	histogram.h	/^   ~linear_histogram() {}$/;"	f	class:linear_histogram
~linear_histogram_logger	stat-tool.cc	/^linear_histogram_logger::~linear_histogram_logger() $/;"	f	class:linear_histogram_logger
~linear_histogram_snapshot	stat-tool.h	/^   ~linear_histogram_snapshot() { }$/;"	f	class:linear_histogram_snapshot
~lrr_scheduler	shader.h	/^	virtual ~lrr_scheduler () {}$/;"	f	class:lrr_scheduler
~mem_fetch	mem_fetch.cc	/^mem_fetch::~mem_fetch()$/;"	f	class:mem_fetch
~memory_partition_unit	l2cache.cc	/^memory_partition_unit::~memory_partition_unit() $/;"	f	class:memory_partition_unit
~memory_sub_partition	l2cache.cc	/^memory_sub_partition::~memory_sub_partition()$/;"	f	class:memory_sub_partition
~pow2_histogram	histogram.h	/^   ~pow2_histogram() {}$/;"	f	class:pow2_histogram
~read_only_cache	gpu-cache.h	/^    virtual ~read_only_cache(){}$/;"	f	class:read_only_cache
~scheduler_unit	shader.h	/^    virtual ~scheduler_unit(){}$/;"	f	class:scheduler_unit
~shader_core_ctx	shader.cc	/^shader_core_ctx::~shader_core_ctx() {$/;"	f	class:shader_core_ctx
~shader_core_stats	shader.cc	/^shader_core_stats::~shader_core_stats()$/;"	f	class:shader_core_stats
~simd_function_unit	shader.h	/^    ~simd_function_unit() { delete m_dispatch_reg; }$/;"	f	class:simd_function_unit
~snap_shot_trigger	stat-tool.h	/^   virtual ~snap_shot_trigger() {}$/;"	f	class:snap_shot_trigger
~spill_log_interface	stat-tool.h	/^   virtual ~spill_log_interface() {}$/;"	f	class:spill_log_interface
~swl_scheduler	shader.h	/^	virtual ~swl_scheduler () {}$/;"	f	class:swl_scheduler
~tag_array	gpu-cache.cc	/^tag_array::~tag_array() $/;"	f	class:tag_array
~thread_CFlocality	stat-tool.cc	/^thread_CFlocality::~thread_CFlocality() $/;"	f	class:thread_CFlocality
~thread_insn_span	stat-tool.cc	/^thread_insn_span::~thread_insn_span() { }$/;"	f	class:thread_insn_span
~two_level_active_scheduler	shader.h	/^	virtual ~two_level_active_scheduler () {}$/;"	f	class:two_level_active_scheduler
~tx_log_walker	shader.cc	/^tx_log_walker::~tx_log_walker()$/;"	f	class:tx_log_walker
~tx_log_walker_warpc	shader.cc	/^tx_log_walker_warpc::~tx_log_walker_warpc()$/;"	f	class:tx_log_walker_warpc
~tx_log_walker_warpc_logical	shader.h	/^   virtual ~tx_log_walker_warpc_logical() {};$/;"	f	class:tx_log_walker_warpc_logical
