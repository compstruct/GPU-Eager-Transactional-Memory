!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
-name-prefix	Makefile	/^	bison --name-prefix=ptx_ -v -d ptx.y --file-prefix=$(OUTPUT_DIR)\/ptx$/;"	m
-name-prefix	Makefile	/^	bison --name-prefix=ptxinfo_ -v -d ptxinfo.y --file-prefix=$(OUTPUT_DIR)\/ptxinfo$/;"	m
-outfile	Makefile	/^	flex --outfile=$(OUTPUT_DIR)\/lex.ptx_.c ptx.l $/;"	m
-outfile	Makefile	/^	flex --outfile=$(OUTPUT_DIR)\/lex.ptxinfo_.c ptxinfo.l $/;"	m
ARRAY_IDENTIFIER	ptx_parser.h	99;"	d
ARRAY_IDENTIFIER_NO_DIM	ptx_parser.h	98;"	d
BLOOMFILTER_H	bloomfilter.h	4;"	d
CACHE_LINE_SIZE	tm_manager_internal.h	36;"	d
CC	Makefile	/^	CC = icc$/;"	m
CLOCK64_REG	opcodes.h	/^   CLOCK64_REG,$/;"	e	enum:special_regs
CLOCK_REG	opcodes.h	/^   CLOCK_REG,$/;"	e	enum:special_regs
COMPLETE	tm_manager_internal.h	/^   COMPLETE$/;"	e	enum:tm_ring::status_t
CPP	Makefile	/^	CPP = icpc$/;"	m
CPP	Makefile	/^CPP = g++ $(SNOW)$/;"	m
CTAID_REG	opcodes.h	/^   CTAID_REG,$/;"	e	enum:special_regs
CUDASIM_H_INCLUDED	cuda-sim.h	29;"	d
CUDA_DEVICE_PRINTF_INCLUDED	cuda_device_printf.h	29;"	d
CUDA_FLOAT_MATH_FUNCTIONS	cuda-math.h	101;"	d
CUDA_MATH	cuda-math.h	68;"	d
CXX_OPT	Makefile	/^CXX_OPT = $(OPT)$/;"	m
CmpOp	instructions.cc	/^bool CmpOp( int type, ptx_reg_t a, ptx_reg_t b, unsigned cmpop )$/;"	f
DEBUG	Makefile	/^DEBUG?=0$/;"	m
DEF	ptx_parser.cc	120;"	d	file:
DEF	ptx_parser.cc	122;"	d	file:
ENVREG_REG	opcodes.h	/^   ENVREG_REG,$/;"	e	enum:special_regs
GRIDID_REG	opcodes.h	/^   GRIDID_REG,$/;"	e	enum:special_regs
GSKEW_SET	bloomfilter.cc	/^   GSKEW_SET = 1, $/;"	e	enum:__anon2	file:
H3_SET	bloomfilter.cc	/^   H3_SET = 2$/;"	e	enum:__anon2	file:
HALFCLOCK_ID	opcodes.h	/^   HALFCLOCK_ID,$/;"	e	enum:special_regs
HASHFUNC_H	hashfunc.h	2;"	d
HASHTABLE_BITS	bloomfilter.cc	/^   HASHTABLE_BITS = 1,$/;"	e	enum:__anon1	file:
HASHTABLE_COUNTER	bloomfilter.cc	/^   HASHTABLE_COUNTER = 2$/;"	e	enum:__anon1	file:
INTEL	Makefile	/^INTEL=0$/;"	m
INT_MAX	cuda-math.h	75;"	d
INVALID	tm_manager_internal.h	/^   INVALID, $/;"	e	enum:tm_ring::status_t
LANEID_REG	opcodes.h	/^   LANEID_REG,$/;"	e	enum:special_regs
LANEMASK_EQ_REG	opcodes.h	/^   LANEMASK_EQ_REG,$/;"	e	enum:special_regs
LANEMASK_GE_REG	opcodes.h	/^   LANEMASK_GE_REG,$/;"	e	enum:special_regs
LANEMASK_GT_REG	opcodes.h	/^   LANEMASK_GT_REG,$/;"	e	enum:special_regs
LANEMASK_LE_REG	opcodes.h	/^   LANEMASK_LE_REG,$/;"	e	enum:special_regs
LANEMASK_LT_REG	opcodes.h	/^   LANEMASK_LT_REG,$/;"	e	enum:special_regs
MAX	cuda-sim.cc	1753;"	d	file:
MAX_CLASS_KER	cuda-sim.cc	1144;"	d	file:
MAX_INST_SIZE	cuda-sim.cc	181;"	d	file:
MEM_BLOCK_SIZE	memory.h	50;"	d
MEM_MAP_RESIZE	memory.h	36;"	d
MEM_MAP_RESIZE	memory.h	38;"	d
MY_CAS_I	instructions.cc	687;"	d	file:
MY_DEC_I	instructions.cc	685;"	d	file:
MY_EXCH	instructions.cc	689;"	d	file:
MY_INC_I	instructions.cc	684;"	d	file:
MY_MAX_F	instructions.cc	679;"	d	file:
MY_MAX_I	instructions.cc	678;"	d	file:
MY_MIN_F	instructions.cc	682;"	d	file:
MY_MIN_I	instructions.cc	681;"	d	file:
NCTAID_REG	opcodes.h	/^   NCTAID_REG,$/;"	e	enum:special_regs
NON_ARRAY_IDENTIFIER	ptx_parser.h	97;"	d
NO_BRANCH_DIVERGENCE	cuda-sim.h	132;"	d
NSMID_REG	opcodes.h	/^   NSMID_REG,$/;"	e	enum:special_regs
NTID_REG	opcodes.h	/^   NTID_REG,$/;"	e	enum:special_regs
NUM_OPCODES	opcodes.h	/^   NUM_OPCODES$/;"	e	enum:opcode_t
NWARPID_REG	opcodes.h	/^   NWARPID_REG,$/;"	e	enum:special_regs
OBJS	Makefile	/^OBJS	:= $(OUTPUT_DIR)\/ptx_parser.o $(OUTPUT_DIR)\/ptx_loader.o $(OUTPUT_DIR)\/cuda_device_printf.o $(OUTPUT_DIR)\/instructions.o $(OUTPUT_DIR)\/cuda-sim.o $(OUTPUT_DIR)\/ptx_ir.o $(OUTPUT_DIR)\/ptx_sim.o  $(OUTPUT_DIR)\/memory.o $(OUTPUT_DIR)\/ptx-stats.o $(OUTPUT_DIR)\/decuda_pred_table\/decuda_pred_table.o $(OUTPUT_DIR)\/ptx.tab.o $(OUTPUT_DIR)\/lex.ptx_.o $(OUTPUT_DIR)\/ptxinfo.tab.o $(OUTPUT_DIR)\/lex.ptxinfo_.o $(OUTPUT_DIR)\/tm_manager.o $(OUTPUT_DIR)\/bloomfilter.o $(OUTPUT_DIR)\/hashfunc.o$/;"	m
OPT	Makefile	/^	OPT := -g3 -Wall  -Wno-unused-function -Wno-sign-compare$/;"	m
OPT	Makefile	/^OPT	:=  -O3 -g3 -Wall -Wno-unused-function -Wno-sign-compare$/;"	m
OP_DEF	cuda-sim.cc	1228;"	d	file:
OP_DEF	cuda-sim.cc	1230;"	d	file:
OP_DEF	cuda-sim.cc	817;"	d	file:
OP_DEF	cuda-sim.cc	819;"	d	file:
OP_DEF	instructions.cc	50;"	d	file:
OP_DEF	instructions.cc	52;"	d	file:
OP_DEF	opcodes.h	32;"	d
OP_DEF	opcodes.h	35;"	d
OUTPUT_DIR	Makefile	/^OUTPUT_DIR=$(SIM_OBJ_FILES_DIR)\/cuda-sim$/;"	m
PM_REG	opcodes.h	/^   PM_REG,$/;"	e	enum:special_regs
PTX_LOADER_H_INCLUDED	ptx_loader.h	29;"	d
PTX_PARSE_DPRINTF	ptx_parser.cc	77;"	d	file:
RECONVERGE_RETURN_PC	cuda-sim.h	131;"	d
REGSTATE_NORMAL	ptx_sim.h	/^   REGSTATE_NORMAL = 0,$/;"	e	enum:tm_reg_state
REGSTATE_N_TM_REG_STATES	ptx_sim.h	/^   REGSTATE_N_TM_REG_STATES    \/\/ counting purposes only$/;"	e	enum:tm_reg_state
REGSTATE_TM_BUFFERED	ptx_sim.h	/^   REGSTATE_TM_BUFFERED,$/;"	e	enum:tm_reg_state
REGSTATE_TM_MODIFIED	ptx_sim.h	/^   REGSTATE_TM_MODIFIED, \/\/ modified before reading$/;"	e	enum:tm_reg_state
REGSTATE_TM_READ	ptx_sim.h	/^   REGSTATE_TM_READ,$/;"	e	enum:tm_reg_state
SAD	instructions.cc	3275;"	d	file:
SMID_REG	opcodes.h	/^   SMID_REG,$/;"	e	enum:special_regs
SRCS	Makefile	/^SRCS = $(shell ls *.cc)$/;"	m
STR_SIZE	cuda-sim.cc	458;"	d	file:
STR_SIZE	ptx_ir.cc	42;"	d	file:
TID_REG	opcodes.h	/^   TID_REG,$/;"	e	enum:special_regs
TM_MEM_BUCKET_SIZE	tm_manager_internal.h	35;"	d
TM_MSG_INV	tm_manager_internal.h	798;"	d
TOY_SET	bloomfilter.cc	/^   TOY_SET = 0,$/;"	e	enum:__anon2	file:
TRACE	Makefile	/^TRACE?=0$/;"	m
Tmp_ids	ptx_ir.h	/^   std::set<int> Tmp_ids;$/;"	m	struct:basic_block_t
Tx	ptx_ir.h	/^   unsigned int Tx,Ty; \/\/tiling factor dimensions of layout of texels per 64B cache block$/;"	m	struct:textureInfo
Tx_numbits	ptx_ir.h	/^   unsigned int Tx_numbits,Ty_numbits; \/\/log2(T)$/;"	m	struct:textureInfo
Ty	ptx_ir.h	/^   unsigned int Tx,Ty; \/\/tiling factor dimensions of layout of texels per 64B cache block$/;"	m	struct:textureInfo
Ty_numbits	ptx_ir.h	/^   unsigned int Tx_numbits,Ty_numbits; \/\/log2(T)$/;"	m	struct:textureInfo
UNITTEST	bloomfilter.cc	19;"	d	file:
UNITTEST	bloomfilter.cc	23;"	d	file:
UNITTEST	bloomfilter.cc	24;"	d	file:
WARPID_REG	opcodes.h	/^   WARPID_REG,$/;"	e	enum:special_regs
WARPSZ_REG	opcodes.h	/^   WARPSZ_REG$/;"	e	enum:special_regs
WRITING	tm_manager_internal.h	/^   WRITING, $/;"	e	enum:tm_ring::status_t
__CUDA_INTERNAL_COMPILATION__	cuda-math.h	103;"	d
__CUDA_INTERNAL_COMPILATION__	cuda-math.h	105;"	d
__TM_MANAGER_H	tm_manager.h	14;"	d
__TM_MANAGER_INTERNAL_H	tm_manager_internal.h	14;"	d
__attribute__	cuda-math.h	106;"	d
__attribute__	cuda-math.h	74;"	d
__ll2float_rd	cuda-math.h	/^float __ll2float_rd(long long int a) {$/;"	f	namespace:cuda_math
__ll2float_ru	cuda-math.h	/^float __ll2float_ru(long long int a) {$/;"	f	namespace:cuda_math
__ll2float_rz	cuda-math.h	/^float __ll2float_rz(long long int a) {$/;"	f	namespace:cuda_math
a	instructions.cc	/^   int a;$/;"	m	union:intfloat	file:
abort	tm_manager.cc	/^void tm_manager::abort()$/;"	f	class:tm_manager
abort_count	tm_manager.h	/^   unsigned abort_count() { return m_abort_count; }$/;"	f	class:tm_manager_inf
abort_tx_bf	tm_manager.cc	/^void tm_global_state::abort_tx_bf( unsigned tuid )$/;"	f	class:tm_global_state
abs_impl	instructions.cc	/^void abs_impl( const ptx_instruction *pI, ptx_thread_info *thread ) $/;"	f
access_record	tm_manager.cc	/^tm_manager::access_record::access_record( const access_record &another )$/;"	f	class:tm_manager::access_record
access_record	tm_manager.cc	/^tm_manager::access_record::access_record( tm_manager *parent, memory_space *mem, bool rd, addr_t addr, void *data, unsigned nbytes )$/;"	f	class:tm_manager::access_record
access_record	tm_manager_internal.h	/^   class access_record {$/;"	c	class:tm_manager
accessmode	tm_manager.cc	/^void tm_manager::accessmode( int readmode, int writemode )$/;"	f	class:tm_manager
add	bloomfilter.cc	/^bool bloomfilter::add(addr_t addr)$/;"	f	class:bloomfilter
add	bloomfilter.cc	/^bool bloomfilter::add(addr_t addr, std::vector<int>& mod_pos)$/;"	f	class:bloomfilter
add	bloomfilter.cc	/^bool bloomfilter_mt::add(addr_t addr)$/;"	f	class:bloomfilter_mt
add	bloomfilter.cc	/^int hashtable_bits<sig_limit>::add(addr_t addr)$/;"	f	class:hashtable_bits
add	bloomfilter.cc	/^int hashtable_bits_mt::add(addr_t addr)$/;"	f	class:hashtable_bits_mt
add	bloomfilter.cc	/^int hashtable_counter::add(addr_t addr)$/;"	f	class:hashtable_counter
add_1vector_operand	ptx_parser.cc	/^void add_1vector_operand( const char *d1 ) $/;"	f
add_2vector_operand	ptx_parser.cc	/^void add_2vector_operand( const char *d1, const char *d2 ) $/;"	f
add_3vector_operand	ptx_parser.cc	/^void add_3vector_operand( const char *d1, const char *d2, const char *d3 ) $/;"	f
add_4vector_operand	ptx_parser.cc	/^void add_4vector_operand( const char *d1, const char *d2, const char *d3, const char *d4 ) $/;"	f
add_address_operand	ptx_parser.cc	/^void add_address_operand( const char *identifier, int offset ) $/;"	f
add_address_operand2	ptx_parser.cc	/^void add_address_operand2( int offset )$/;"	f
add_alignment_spec	ptx_parser.cc	/^void add_alignment_spec( int spec )$/;"	f
add_arg	ptx_ir.h	/^   void add_arg( const symbol *arg )$/;"	f	class:function_info
add_array_initializer	ptx_parser.cc	/^void add_array_initializer()$/;"	f
add_builtin_operand	ptx_parser.cc	/^void add_builtin_operand( int builtin, int dim_modifier ) $/;"	f
add_committed_insn	tm_manager.cc	/^void tm_manager::add_committed_insn( unsigned insn_count )$/;"	f	class:tm_manager
add_constptr	ptx_parser.cc	/^void add_constptr(const char* identifier1, const char* identifier2, int offset)$/;"	f
add_count	ptx-stats.cc	/^    void add_count(const ptx_instruction * pInsn, int count = 1)$/;"	f	class:ptx_inflight_memory_insn_tracker
add_data	ptx_ir.h	/^   void add_data( param_t v ) { $/;"	f	class:param_info
add_directive	ptx_parser.cc	/^void add_directive() $/;"	f
add_double_operand	ptx_parser.cc	/^void add_double_operand( const char *d1, const char *d2 )$/;"	f
add_extern_spec	ptx_parser.cc	/^void add_extern_spec() $/;"	f
add_file	ptx_parser.cc	/^void add_file( unsigned num, const char *filename )$/;"	f
add_function	ptx_ir.cc	/^void symbol_table::add_function( function_info *func, const char *filename, unsigned linenumber )$/;"	f	class:symbol_table
add_function_arg	ptx_parser.cc	/^void add_function_arg()$/;"	f
add_function_decl	ptx_ir.cc	/^bool symbol_table::add_function_decl( const char *name, int entry_point, function_info **func_info, symbol_table **sym_table )$/;"	f	class:symbol_table
add_function_name	ptx_parser.cc	/^void add_function_name( const char *name ) $/;"	f
add_identifier	ptx_parser.cc	/^void add_identifier( const char *identifier, int array_dim, unsigned array_ident ) $/;"	f
add_impl	instructions.cc	/^void add_impl( const ptx_instruction *pI, ptx_thread_info *thread ) $/;"	f
add_initializer	ptx_ir.cc	/^void symbol::add_initializer( const std::list<operand_info> &init )$/;"	f	class:symbol
add_inst	ptx_ir.h	/^   void add_inst( const std::list<ptx_instruction*> &instructions )$/;"	f	class:function_info
add_instruction	ptx_parser.cc	/^void add_instruction() $/;"	f
add_label	ptx_parser.cc	/^void add_label( const char *identifier ) $/;"	f
add_literal_double	ptx_parser.cc	/^void add_literal_double( double value ) $/;"	f
add_literal_float	ptx_parser.cc	/^void add_literal_float( float value ) $/;"	f
add_literal_int	ptx_parser.cc	/^void add_literal_int( int value ) $/;"	f
add_memory_operand	ptx_parser.cc	/^void add_memory_operand() $/;"	f
add_neg_pred_operand	ptx_parser.cc	/^void add_neg_pred_operand( const char *identifier ) $/;"	f
add_offset	ptx_ir.h	/^   void add_offset( unsigned offset ) { m_offset = offset; }$/;"	f	class:param_info
add_opcode	ptx_parser.cc	/^void add_opcode( int opcode ) $/;"	f
add_option	ptx_parser.cc	/^void add_option( int option ) $/;"	f
add_param	ptx_ir.h	/^   void add_param( const char *name, struct param_t value )$/;"	f	class:function_info
add_param_data	cuda-sim.cc	/^void function_info::add_param_data( unsigned argn, struct gpgpu_ptx_sim_arg *args )$/;"	f	class:function_info
add_param_name_type_size	cuda-sim.cc	/^void function_info::add_param_name_type_size( unsigned index, std::string name, int type, size_t size, bool ptr, memory_space_t space )$/;"	f	class:function_info
add_pragma	ptx_parser.cc	/^void add_pragma( const char *str )$/;"	f
add_pred	ptx_parser.cc	/^void add_pred( const char *identifier, int neg, int predModifier ) $/;"	f
add_ptr_spec	ptx_parser.cc	/^void add_ptr_spec( enum _memory_space_t spec ) $/;"	f
add_return_var	ptx_ir.h	/^   void add_return_var( const symbol *rv )$/;"	f	class:function_info
add_rollback_insn	tm_manager.cc	/^void tm_manager::add_rollback_insn( unsigned insn_count )$/;"	f	class:tm_manager
add_scalar_operand	ptx_parser.cc	/^void add_scalar_operand( const char *identifier ) $/;"	f
add_scalar_type_spec	ptx_parser.cc	/^void add_scalar_type_spec( int type_spec ) $/;"	f
add_space_spec	ptx_parser.cc	/^void add_space_spec( enum _memory_space_t spec, int value ) $/;"	f
add_thread	ptx_sim.cc	/^void ptx_cta_info::add_thread( ptx_thread_info *thd )$/;"	f	class:ptx_cta_info
add_type	ptx_ir.cc	/^type_info *symbol_table::add_type( function_info *func )$/;"	f	class:symbol_table
add_type	ptx_ir.cc	/^type_info *symbol_table::add_type( memory_space_t space_spec, int scalar_type_spec, int vector_spec, int alignment_spec, int extern_spec )$/;"	f	class:symbol_table
add_variable	ptx_ir.cc	/^symbol *symbol_table::add_variable( const char *identifier, const type_info *type, unsigned size, const char *filename, unsigned line )$/;"	f	class:symbol_table
add_variables	ptx_parser.cc	/^void add_variables() $/;"	f
add_vector_spec	ptx_parser.cc	/^void add_vector_spec(int spec ) $/;"	f
add_version_info	ptx_parser.cc	/^void add_version_info( float ver, unsigned ext )$/;"	f
addc_impl	instructions.cc	/^void addc_impl( const ptx_instruction *pI, ptx_thread_info *thread ) { inst_not_implemented(pI); }$/;"	f
addp_impl	instructions.cc	/^void addp_impl( const ptx_instruction *pI, ptx_thread_info *thread )$/;"	f
addr_set_t	tm_manager_internal.h	/^typedef std::set<addr_t> addr_set_t;$/;"	t
addr_value_t	tm_manager_internal.h	/^   typedef tr1_hash_map<addr_t, unsigned int> addr_value_t;$/;"	t	class:value_based_tm_manager
addr_version_set_t	tm_manager_internal.h	/^typedef tr1_hash_map<addr_t, int> addr_version_set_t;$/;"	t
address_expression	ptx.y	/^address_expression: IDENTIFIER { add_address_operand($1,0); }$/;"	l
address_t	ptx_ir.h	/^   reg_t, vector_t, builtin_t, address_t, memory_t, float_op_t, double_op_t, int_t, $/;"	e	enum:operand_type
addressable_spec	ptx.y	/^addressable_spec: CONST_DIRECTIVE {  add_space_spec(const_space,$1); }$/;"	l
advance_warp_pts	tm_manager_internal.h	/^   void advance_warp_pts(unsigned index) { $/;"	f	class:logical_temporal_conflict_detector
alias_detection_test	bloomfilter.cc	/^bool alias_detection_test(unsigned int size, const std::vector<int>& funct_ids, bool counter_based)$/;"	f
alias_detection_test	bloomfilter.cc	/^bool alias_detection_test(unsigned int size, int funct_id)$/;"	f
align_spec	ptx.y	/^align_spec: ALIGN_DIRECTIVE INT_OPERAND { add_alignment_spec($2); }$/;"	l
alloc_global	ptx_ir.h	/^   void  alloc_global( unsigned num_bytes ) { m_global_next += num_bytes;}$/;"	f	class:symbol_table
alloc_local	ptx_ir.h	/^   void  alloc_local( unsigned num_bytes ) { m_local_next += num_bytes;}$/;"	f	class:symbol_table
alloc_shared	ptx_ir.h	/^   void  alloc_shared( unsigned num_bytes ) { m_shared_next += num_bytes;}$/;"	f	class:symbol_table
alloc_tex	ptx_ir.h	/^   void  alloc_tex( unsigned num_bytes ) { m_tex_next += num_bytes;}$/;"	f	class:symbol_table
and_impl	instructions.cc	/^void and_impl( const ptx_instruction *pI, ptx_thread_info *thread ) $/;"	f
andn_impl	instructions.cc	/^void andn_impl( const ptx_instruction *pI, ptx_thread_info *thread ) $/;"	f
arch_reg_num	ptx_ir.h	/^   int arch_reg_num() const { return m_value.m_symbolic->arch_reg_num(); }$/;"	f	class:operand_info
arch_reg_num	ptx_ir.h	/^   int arch_reg_num(unsigned n) const { return (m_value.m_vector_symbolic[n])? m_value.m_vector_symbolic[n]->arch_reg_num() : -1; }$/;"	f	class:operand_info
arch_reg_num	ptx_ir.h	/^   unsigned arch_reg_num() const$/;"	f	class:symbol
arg_buffer_list_t	ptx_ir.h	/^typedef std::list< arg_buffer_t > arg_buffer_list_t;$/;"	t
arg_buffer_t	ptx_ir.h	/^   arg_buffer_t( const arg_buffer_t &another )$/;"	f	class:arg_buffer_t
arg_buffer_t	ptx_ir.h	/^   arg_buffer_t( const symbol *dst_sym, const operand_info &src_op, ptx_reg_t source_value ) : m_src_op(src_op)$/;"	f	class:arg_buffer_t
arg_buffer_t	ptx_ir.h	/^   arg_buffer_t( const symbol *dst_sym, const operand_info &src_op, void *source_param_value_array, unsigned array_size ) : m_src_op(src_op)$/;"	f	class:arg_buffer_t
arg_buffer_t	ptx_ir.h	/^   arg_buffer_t()$/;"	f	class:arg_buffer_t
arg_buffer_t	ptx_ir.h	/^class arg_buffer_t {$/;"	c
assign_bb	ptx_ir.h	/^   void assign_bb(basic_block_t* basic_block) \/\/assign instruction to a basic block$/;"	f	class:ptx_instruction
at_abort	tm_manager.cc	/^void logical_timestamp_based_tm_manager::at_abort() {$/;"	f	class:logical_timestamp_based_tm_manager
at_abort	tm_manager.cc	/^void ring_tm_manager::at_abort()$/;"	f	class:ring_tm_manager
at_abort	tm_manager.cc	/^void tm_manager::at_abort()$/;"	f	class:tm_manager
at_abort	tm_manager.cc	/^void value_based_tm_manager::at_abort()$/;"	f	class:value_based_tm_manager
at_access	tm_manager.cc	/^bool logical_timestamp_based_tm_manager::at_access(memory_space *mem, bool potential_conflicting, $/;"	f	class:logical_timestamp_based_tm_manager
at_access	tm_manager.cc	/^bool ring_tm_manager::at_access( memory_space *mem, bool potential_conflicting, bool rd, addr_t addr, void *vp, int nbytes, mem_fetch *mf )$/;"	f	class:ring_tm_manager
at_access	tm_manager.cc	/^bool tm_manager::at_access( memory_space *mem, bool potential_conflicting, bool rd, addr_t addr, void *vp, int nbytes, mem_fetch *mf )$/;"	f	class:tm_manager
at_access	tm_manager.cc	/^bool value_based_tm_manager::at_access( memory_space *mem, bool potential_conflicting, bool rd, addr_t addr, void *vp, int nbytes, mem_fetch *mf )$/;"	f	class:value_based_tm_manager
at_commit_success	tm_manager.cc	/^void logical_timestamp_based_tm_manager::at_commit_success() { }$/;"	f	class:logical_timestamp_based_tm_manager
at_commit_success	tm_manager.cc	/^void ring_tm_manager::at_commit_success()$/;"	f	class:ring_tm_manager
at_commit_success	tm_manager.cc	/^void tm_manager::at_commit_success()$/;"	f	class:tm_manager
at_commit_success	tm_manager.cc	/^void value_based_tm_manager::at_commit_success()$/;"	f	class:value_based_tm_manager
at_commit_validation	tm_manager.cc	/^bool logical_timestamp_based_tm_manager::at_commit_validation() {$/;"	f	class:logical_timestamp_based_tm_manager
at_commit_validation	tm_manager.cc	/^bool ring_tm_manager::at_commit_validation()$/;"	f	class:ring_tm_manager
at_commit_validation	tm_manager.cc	/^bool tm_manager::at_commit_validation()$/;"	f	class:tm_manager
at_commit_validation	tm_manager.cc	/^bool value_based_tm_manager::at_commit_validation()$/;"	f	class:value_based_tm_manager
at_start	tm_manager.cc	/^void logical_timestamp_based_tm_manager::at_start() { };$/;"	f	class:logical_timestamp_based_tm_manager
at_start	tm_manager.cc	/^void ring_tm_manager::at_start()$/;"	f	class:ring_tm_manager
at_start	tm_manager.cc	/^void tm_manager::at_start() $/;"	f	class:tm_manager
at_start	tm_manager.cc	/^void value_based_tm_manager::at_start() $/;"	f	class:value_based_tm_manager
at_transaction_read	tm_manager.cc	/^tm_timestamp_t temporal_conflict_detector::at_transaction_read( addr_t addr ) $/;"	f	class:temporal_conflict_detector
atom_callback	instructions.cc	/^void atom_callback( const inst_t* inst, ptx_thread_info* thread )$/;"	f
atom_impl	instructions.cc	/^void atom_impl( const ptx_instruction *pI, ptx_thread_info *thread )$/;"	f
atomic_operation_spec	ptx.y	/^atomic_operation_spec: ATOMIC_AND { add_option(ATOMIC_AND); } $/;"	l
attribute_exposed_latency	ptx-stats.cc	/^    void attribute_exposed_latency(int count = 1)$/;"	f	class:ptx_inflight_memory_insn_tracker
b	instructions.cc	/^   float b;$/;"	m	union:intfloat	file:
bar_sync_impl	instructions.cc	/^void bar_sync_impl( const ptx_instruction *pI, ptx_thread_info *thread ) $/;"	f
basic_block_t	ptx_ir.h	/^   basic_block_t( unsigned ID, ptx_instruction *begin, ptx_instruction *end, bool entry, bool ex)$/;"	f	struct:basic_block_t
basic_block_t	ptx_ir.h	/^struct basic_block_t {$/;"	s
bb_id	ptx_ir.h	/^   unsigned bb_id;$/;"	m	struct:basic_block_t
begin_callback	cuda-sim.h	/^    virtual void begin_callback(unsigned thread_id, unsigned warp_id, address_type restart_pc) { }$/;"	f	class:functionalCoreSim
bfe_impl	instructions.cc	/^void bfe_impl( const ptx_instruction *pI, ptx_thread_info *thread ) { inst_not_implemented(pI); }$/;"	f
bfi_impl	instructions.cc	/^void bfi_impl( const ptx_instruction *pI, ptx_thread_info *thread ) { inst_not_implemented(pI); }$/;"	f
bfind_impl	instructions.cc	/^void bfind_impl( const ptx_instruction *pI, ptx_thread_info *thread ) { inst_not_implemented(pI); }$/;"	f
bits	ptx_sim.h	/^   } bits;$/;"	m	union:ptx_reg_t	typeref:struct:ptx_reg_t::__anon4
block_spec	ptx.y	/^block_spec: MAXNTID_DIRECTIVE INT_OPERAND COMMA INT_OPERAND COMMA INT_OPERAND {func_header_info_int(".maxntid", $2);$/;"	l
block_spec_list	ptx.y	/^block_spec_list: block_spec$/;"	l
bloomfilter	bloomfilter.cc	/^bloomfilter::bloomfilter(const bloomfilter& other)$/;"	f	class:bloomfilter
bloomfilter	bloomfilter.cc	/^bloomfilter::bloomfilter(unsigned int size, const std::vector<int>& funct_ids, unsigned int n_functs, bool counter_based)$/;"	f	class:bloomfilter
bloomfilter	bloomfilter.h	/^class bloomfilter$/;"	c
bloomfilter_access_set_t	tm_manager_internal.h	/^	typedef tr1_hash_map<unsigned,tm_bloomfilter_set> bloomfilter_access_set_t;$/;"	t	class:tm_global_state
bloomfilter_mt	bloomfilter.cc	/^bloomfilter_mt::bloomfilter_mt(const bloomfilter_mt& other)$/;"	f	class:bloomfilter_mt
bloomfilter_mt	bloomfilter.cc	/^bloomfilter_mt::bloomfilter_mt(unsigned int size, const std::vector<int>& funct_ids, unsigned int n_functs, unsigned int nthreads, unsigned int tid_hashsize)$/;"	f	class:bloomfilter_mt
bloomfilter_mt	bloomfilter.h	/^class bloomfilter_mt$/;"	c
bloomfilter_reg_options	bloomfilter.cc	/^void bloomfilter_reg_options(option_parser_t opp)$/;"	f
bra_impl	instructions.cc	/^void bra_impl( const ptx_instruction *pI, ptx_thread_info *thread ) $/;"	f
branch_taken	ptx_sim.h	/^   bool branch_taken() const$/;"	f	class:ptx_thread_info
break_impl	instructions.cc	/^void break_impl( const ptx_instruction *pI, ptx_thread_info *thread ) $/;"	f
breakaddr_impl	instructions.cc	/^void breakaddr_impl( const ptx_instruction *pI, ptx_thread_info *thread ) $/;"	f
brev_impl	instructions.cc	/^void brev_impl( const ptx_instruction *pI, ptx_thread_info *thread ) { inst_not_implemented(pI); }$/;"	f
brkpt_impl	instructions.cc	/^void brkpt_impl( const ptx_instruction *pI, ptx_thread_info *thread ) { inst_not_implemented(pI); }$/;"	f
brx_impl	instructions.cc	/^void brx_impl( const ptx_instruction *pI, ptx_thread_info *thread ) $/;"	f
builtin_operand	ptx.y	/^builtin_operand: SPECIAL_REGISTER DIMENSION_MODIFIER { add_builtin_operand($1,$2); }$/;"	l
builtin_t	ptx_ir.h	/^   reg_t, vector_t, builtin_t, address_t, memory_t, float_op_t, double_op_t, int_t, $/;"	e	enum:operand_type
cache_option	ptx_ir.h	/^   unsigned cache_option() const { return m_cache_option; }$/;"	f	class:ptx_instruction
call_impl	instructions.cc	/^void call_impl( const ptx_instruction *pI, ptx_thread_info *thread ) $/;"	f
callp_impl	instructions.cc	/^void callp_impl( const ptx_instruction *pI, ptx_thread_info *thread )$/;"	f
callstack_pop	ptx_sim.cc	/^bool ptx_thread_info::callstack_pop()$/;"	f	class:ptx_thread_info
callstack_pop_plus	ptx_sim.cc	/^bool ptx_thread_info::callstack_pop_plus()$/;"	f	class:ptx_thread_info
callstack_push	ptx_sim.cc	/^void ptx_thread_info::callstack_push( unsigned pc, unsigned rpc, const symbol *return_var_src, const symbol *return_var_dst, unsigned call_uid )$/;"	f	class:ptx_thread_info
callstack_push_plus	ptx_sim.cc	/^void ptx_thread_info::callstack_push_plus( unsigned pc, unsigned rpc, const symbol *return_var_src, const symbol *return_var_dst, unsigned call_uid )$/;"	f	class:ptx_thread_info
change_double_operand_type	ptx_parser.cc	/^void change_double_operand_type( int operand_type )$/;"	f
change_memory_addr_space	ptx_parser.cc	/^void change_memory_addr_space(const char *identifier) $/;"	f
change_operand_lohi	ptx_parser.cc	/^void change_operand_lohi( int lohi )$/;"	f
change_operand_neg	ptx_parser.cc	/^void change_operand_neg( )$/;"	f
checkExecutionStatusAndUpdate	cuda-sim.h	/^    virtual void checkExecutionStatusAndUpdate(warp_inst_t &inst, unsigned t, unsigned tid)$/;"	f	class:functionalCoreSim
check_conflict	tm_manager.cc	/^int tm_ring_global::check_conflict(const addr_version_set_t& other_tx_read_set, int start_time) const $/;"	f	class:tm_ring_global
check_cta_thread_status_and_reset	ptx_sim.cc	/^void ptx_cta_info::check_cta_thread_status_and_reset()$/;"	f	class:ptx_cta_info
check_for_duplicates	ptx_parser.cc	/^bool check_for_duplicates( const char *identifier )$/;"	f
check_n_derive	tm_manager.cc	/^void tm_options::check_n_derive()$/;"	f	class:tm_options
check_operands	ptx_ir.cc	/^static std::list<operand_info> check_operands( int opcode,$/;"	f	file:
check_owner	bloomfilter.cc	/^bool versioning_bloomfilter::check_owner(addr_t addr, unsigned int version, unsigned int shader_id, unsigned int warp_id) const $/;"	f	class:versioning_bloomfilter
check_owner	tm_manager.cc	/^bool logical_temporal_conflict_detector::check_owner(addr_t addr, tm_timestamp_t tx_pts, $/;"	f	class:logical_temporal_conflict_detector
check_target_extension	ptx_sim.h	/^      void check_target_extension( const char *ext ) $/;"	f	class:ptx_version
chop	instructions.cc	/^ptx_reg_t chop( ptx_reg_t x, unsigned from_width, unsigned to_width, int to_sign, int rounding_mode, int saturation_mode )$/;"	f
clamp	instructions.cc	/^unsigned clamp( unsigned x, unsigned y, unsigned mx, unsigned my, size_t elem_size )$/;"	f
clear	bloomfilter.cc	/^void bloomfilter::clear()$/;"	f	class:bloomfilter
clear	bloomfilter.cc	/^void bloomfilter_mt::clear()$/;"	f	class:bloomfilter_mt
clear	bloomfilter.cc	/^void hashtable_bits<sig_limit>::clear()$/;"	f	class:hashtable_bits
clear	bloomfilter.cc	/^void hashtable_bits_mt::clear()$/;"	f	class:hashtable_bits_mt
clear	bloomfilter.cc	/^void hashtable_counter::clear()$/;"	f	class:hashtable_counter
clear	bloomfilter.cc	/^void versioning_bloomfilter::clear()$/;"	f	class:versioning_bloomfilter
clear	bloomfilter.cc	/^void versioning_hashtable::clear()$/;"	f	class:versioning_hashtable
clear	tm_manager.cc	/^void tm_bloomfilter_hashed_core_set::clear(int hw_thread_id)$/;"	f	class:tm_bloomfilter_hashed_core_set
clear	tm_manager.cc	/^void tm_bloomfilter_set::clear()$/;"	f	class:tm_bloomfilter_set
clearRPC	ptx_sim.h	/^   void clearRPC()$/;"	f	class:ptx_thread_info
clear_all	bloomfilter.cc	/^void bloomfilter_mt::clear_all()$/;"	f	class:bloomfilter_mt
clear_all	bloomfilter.cc	/^void hashtable_bits_mt::clear_all()$/;"	f	class:hashtable_bits_mt
clear_all	tm_manager.cc	/^void tm_bloomfilter_hashed_core_set::clear_all()$/;"	f	class:tm_bloomfilter_hashed_core_set
clear_is_abort_need_clean	tm_manager.h	/^   virtual void clear_is_abort_need_clean() { m_is_abort_need_clean = false; }$/;"	f	class:tm_manager_inf
clear_modifiedregs	ptx_sim.h	/^   void clear_modifiedregs() { m_debug_trace_regs_modified.back().clear(); m_debug_trace_regs_read.back().clear(); }$/;"	f	class:ptx_thread_info
clear_ptxinfo	cuda-sim.cc	/^void clear_ptxinfo()$/;"	f
clear_write_data	tm_manager_internal.h	/^   virtual void clear_write_data() { assert(0); }$/;"	f	class:ring_tm_manager
clear_write_data	tm_manager_internal.h	/^   virtual void clear_write_data() { assert(0); }$/;"	f	class:tm_manager
clear_write_data	tm_manager_internal.h	/^   virtual void clear_write_data() { assert(0); }$/;"	f	class:value_based_tm_manager
clear_write_data	tm_manager_internal.h	/^   virtual void clear_write_data() { m_write_data.clear(); }$/;"	f	class:logical_timestamp_based_tm_manager
clz_impl	instructions.cc	/^void clz_impl( const ptx_instruction *pI, ptx_thread_info *thread )$/;"	f
cnot_impl	instructions.cc	/^void cnot_impl( const ptx_instruction *pI, ptx_thread_info *thread ) $/;"	f
commit	tm_manager.cc	/^bool tm_manager::commit(bool auto_self_abort)$/;"	f	class:tm_manager
commit	tm_manager.cc	/^void tm_manager::access_record::commit()$/;"	f	class:tm_manager::access_record
commit_addr	tm_manager.cc	/^void logical_timestamp_based_tm_manager::commit_addr( addr_t addr ) { $/;"	f	class:logical_timestamp_based_tm_manager
commit_addr	tm_manager.cc	/^void ring_tm_manager::commit_addr( addr_t addr ) { assert(0); }$/;"	f	class:ring_tm_manager
commit_addr	tm_manager.cc	/^void tm_manager::commit_addr( addr_t addr ) { assert(0); }$/;"	f	class:tm_manager
commit_addr	tm_manager.cc	/^void value_based_tm_manager::commit_addr( addr_t addr ) $/;"	f	class:value_based_tm_manager
commit_callback	cuda-sim.h	/^    virtual void commit_callback(unsigned thread_id, unsigned warp_id, address_type commit_pc) { }$/;"	f	class:functionalCoreSim
commit_core_side	tm_manager.cc	/^void logical_timestamp_based_tm_manager::commit_core_side() { $/;"	f	class:logical_timestamp_based_tm_manager
commit_core_side	tm_manager.cc	/^void ring_tm_manager::commit_core_side( ) { assert(0); }$/;"	f	class:ring_tm_manager
commit_core_side	tm_manager.cc	/^void tm_manager::commit_core_side( ) { assert(0); }$/;"	f	class:tm_manager
commit_core_side	tm_manager.cc	/^void value_based_tm_manager::commit_core_side( ) $/;"	f	class:value_based_tm_manager
commit_record	tm_manager.cc	/^void tm_ring_compressed_record::commit_record(const addr_set_t& write_set, int commit_time)$/;"	f	class:tm_ring_compressed_record
commit_time	tm_manager_internal.h	/^   int commit_time() const { return m_timestamp; }$/;"	f	class:tm_ring_commit_record
commit_tx	tm_manager.cc	/^void tm_ring_global::commit_tx(unsigned tuid, const addr_set_t& write_set) $/;"	f	class:tm_ring_global
commit_tx_bf	tm_manager.cc	/^void tm_global_state::commit_tx_bf( unsigned tuid, const addr_set_t& write_set, const tuid_set_t& true_conflict_set )$/;"	f	class:tm_global_state
commit_tx_single_record	tm_manager.cc	/^void tm_ring_global::commit_tx_single_record(unsigned tuid, const addr_set_t& write_set) $/;"	f	class:tm_ring_global
commit_word	tm_manager.cc	/^void tm_manager::access_record::commit_word( addr_t addr, unsigned nbytes )$/;"	f	class:tm_manager::access_record
committer_abortee_conflict_resolution	tm_manager.cc	/^bool ring_tm_manager::committer_abortee_conflict_resolution()$/;"	f	class:ring_tm_manager
committer_win_conflict_resolution	tm_manager.cc	/^void tm_manager::committer_win_conflict_resolution()$/;"	f	class:tm_manager
compare_spec	ptx.y	/^compare_spec:EQ_OPTION { add_option(EQ_OPTION); } $/;"	l
compressed_ring_t	tm_manager_internal.h	/^   typedef std::deque<tm_ring_compressed_record> compressed_ring_t; $/;"	t	class:tm_ring_global
conflict	tm_manager.cc	/^bool conflict_set::conflict() const $/;"	f	class:conflict_set
conflict_exist	tm_manager_internal.h	/^      bool conflict_exist() {$/;"	f	class:logical_timestamp_based_tm_manager::logical_temporal_cd_metadata
conflict_exist	tm_manager_internal.h	/^      bool conflict_exist() {$/;"	f	class:value_based_tm_manager::temporal_cd_metadata
conflict_footprint	tm_manager_internal.h	/^   int conflict_footprint() const { return m_conflict_footprint; }$/;"	f	class:tm_global_state
conflict_mem_t	tm_manager_internal.h	/^	typedef tr1_hash_map<unsigned,conflict_set> conflict_mem_t;$/;"	t	class:tm_global_state
conflict_set	tm_manager_internal.h	/^struct conflict_set {$/;"	s
conflict_test	bloomfilter.cc	/^bool conflict_test(unsigned int size, int hashset, const std::vector<int>& funct_ids, int n_hashes, int testset_size)$/;"	f
conflict_test	bloomfilter.cc	/^bool conflict_test(unsigned int size, int hashset, int funct_id)$/;"	f
connect_basic_blocks	ptx_ir.cc	/^void function_info::connect_basic_blocks( ) \/\/iterate across m_basic_blocks of function, connecting basic blocks together$/;"	f	class:function_info
connect_break_targets	ptx_ir.cc	/^bool function_info::connect_break_targets() \/\/connecting break instructions with proper targets$/;"	f	class:function_info
const_iterator	ptx_ir.h	/^   typedef std::vector<operand_info>::const_iterator const_iterator;$/;"	t	class:ptx_instruction
const_iterator_begin	ptx_ir.h	/^   iterator const_iterator_begin() { return m_consts.begin();}$/;"	f	class:symbol_table
const_iterator_end	ptx_ir.h	/^   iterator const_iterator_end() { return m_consts.end();}$/;"	f	class:symbol_table
contain_addr	tm_manager.cc	/^bool tm_manager::access_record::contain_addr( addr_t addr, unsigned nbytes )$/;"	f	class:tm_manager::access_record
copy_arg_to_buffer	ptx_ir.cc	/^arg_buffer_t copy_arg_to_buffer(ptx_thread_info * thread, operand_info actual_param_op, const symbol * formal_param)$/;"	f
copy_args_into_buffer_list	ptx_ir.cc	/^void copy_args_into_buffer_list( const ptx_instruction * pI, $/;"	f
copy_buffer_list_into_frame	ptx_ir.cc	/^void copy_buffer_list_into_frame(ptx_thread_info * thread, arg_buffer_list_t &arg_values) $/;"	f
copy_buffer_to_frame	ptx_ir.cc	/^void copy_buffer_to_frame(ptx_thread_info * thread, const arg_buffer_t &a) $/;"	f
core_bloomfilter_t	tm_manager_internal.h	/^   typedef tr1_hash_map<unsigned, tm_bloomfilter_core_set> core_bloomfilter_t; $/;"	t	class:tm_global_state
core_hash_bloomfilter_t	tm_manager_internal.h	/^   typedef tr1_hash_map<unsigned, tm_bloomfilter_hashed_core_set> core_hash_bloomfilter_t; $/;"	t	class:tm_global_state
cos_impl	instructions.cc	/^void cos_impl( const ptx_instruction *pI, ptx_thread_info *thread ) $/;"	f
countertable_t	bloomfilter.h	/^   typedef std::vector<int> countertable_t;$/;"	t	class:hashtable_counter
cpy_tid_to_reg	ptx_sim.cc	/^void ptx_thread_info::cpy_tid_to_reg( dim3 tid )$/;"	f	class:ptx_thread_info
createWarp	cuda-sim.cc	/^void  functionalCoreSim::createWarp(unsigned warpId)$/;"	f	class:functionalCoreSim
create_basic_blocks	ptx_ir.cc	/^void function_info::create_basic_blocks()$/;"	f	class:function_info
create_tm_manager	tm_manager.cc	/^tm_manager_inf* tm_manager_inf::create_tm_manager( ptx_thread_info *thread, bool timing_mode )$/;"	f	class:tm_manager_inf
cuda_math	cuda-math.h	/^namespace cuda_math {$/;"	n
cvt_impl	instructions.cc	/^void cvt_impl( const ptx_instruction *pI, ptx_thread_info *thread ) $/;"	f
cvta_impl	instructions.cc	/^void cvta_impl( const ptx_instruction *pI, ptx_thread_info *thread ) $/;"	f
d2d	instructions.cc	/^ptx_reg_t d2d( ptx_reg_t x, unsigned from_width, unsigned to_width, int to_sign, int rounding_mode, int saturation_mode )$/;"	f
d2x	instructions.cc	/^ptx_reg_t d2x( ptx_reg_t x, unsigned from_width, unsigned to_width, int to_sign, int rounding_mode, int saturation_mode )$/;"	f
datatype2size	cuda-sim.cc	/^static unsigned datatype2size( unsigned data_type )$/;"	f	file:
dec_concurrency	tm_manager_internal.h	/^    void dec_concurrency() {$/;"	f	class:tm_global_statistics
dec_counter	bloomfilter.cc	/^void hashtable_counter::dec_counter(unsigned pos)$/;"	f	class:hashtable_counter
dec_num_writing_threads	tm_manager.cc	/^void logical_temporal_conflict_detector::dec_num_writing_threads(addr_t addr, unsigned int num) {$/;"	f	class:logical_temporal_conflict_detector
dec_ref_count	tm_manager.cc	/^int tm_manager_inf::dec_ref_count() { m_ref_count--; assert(m_ref_count >= 0); return m_ref_count; }$/;"	f	class:tm_manager_inf
decl_location	ptx_ir.h	/^   const std::string &decl_location() const { return m_decl_location;} $/;"	f	class:symbol
decode_space	instructions.cc	/^void decode_space( memory_space_t &space, ptx_thread_info *thread, const operand_info &op, memory_space *&mem, addr_t &addr)$/;"	f
decode_token	ptx_parser.cc	/^const char *decode_token( int type )$/;"	f
dimension	ptx_ir.h	/^   unsigned dimension() const { return m_geom_spec;}$/;"	f	class:ptx_instruction
directive_statement	ptx.y	/^directive_statement: variable_declaration SEMI_COLON$/;"	l
distribution_test	bloomfilter.cc	/^bool distribution_test(unsigned int size, int hashset, int funct_id)$/;"	f
div_impl	instructions.cc	/^void div_impl( const ptx_instruction *pI, ptx_thread_info *thread ) $/;"	f
dom	ptx_ir.h	/^   bool dom(const basic_block_t *B) {$/;"	f	struct:basic_block_t
dominator_ids	ptx_ir.h	/^   std::set<int> dominator_ids;$/;"	m	struct:basic_block_t
donecycle	ptx_sim.h	/^   unsigned donecycle() const { return m_cycle_done; }$/;"	f	class:ptx_thread_info
double_op_t	ptx_ir.h	/^   reg_t, vector_t, builtin_t, address_t, memory_t, float_op_t, double_op_t, int_t, $/;"	e	enum:operand_type
dram_traffic	ptx-stats.cc	/^    unsigned long long dram_traffic;$/;"	m	class:ptx_file_line_stats	file:
dst	ptx_ir.h	/^   const operand_info &dst() const $/;"	f	class:ptx_instruction
dst	ptx_ir.h	/^   operand_info &dst() $/;"	f	class:ptx_instruction
dump	ptx_ir.cc	/^void symbol_table::dump()$/;"	f	class:symbol_table
dump	tm_manager.cc	/^void logical_temporal_conflict_detector::dump( FILE *fp )$/;"	f	class:logical_temporal_conflict_detector
dump	tm_manager.cc	/^void temporal_conflict_detector::dump( FILE *fp )$/;"	f	class:temporal_conflict_detector
dump_abort_profile	tm_manager.cc	/^void tm_global_statistics::dump_abort_profile(FILE *csv) $/;"	f	class:tm_global_statistics
dump_callstack	ptx_sim.cc	/^void ptx_thread_info::dump_callstack() const$/;"	f	class:ptx_thread_info
dump_committed_set	tm_manager.cc	/^void value_based_tm_manager::dump_committed_set()$/;"	f	class:value_based_tm_manager
dump_modifiedregs	ptx_sim.cc	/^void ptx_thread_info::dump_modifiedregs(FILE *fp)$/;"	f	class:ptx_thread_info
dump_read_set	tm_manager.cc	/^void value_based_tm_manager::dump_read_set()$/;"	f	class:value_based_tm_manager
dump_regs	ptx_sim.cc	/^void ptx_thread_info::dump_regs( FILE *fp )$/;"	f	class:ptx_thread_info
dump_write_data	tm_manager.cc	/^void logical_timestamp_based_tm_manager::dump_write_data() {$/;"	f	class:logical_timestamp_based_tm_manager
empty	tm_manager_internal.h	/^	bool empty() const { return m_tuids_have_read.empty() && m_tuids_have_written.empty(); }$/;"	f	struct:conflict_set
empty_test	bloomfilter.cc	/^bool empty_test(unsigned int size, int funct_id)$/;"	f
enable_debug_trace	ptx_sim.h	/^   void enable_debug_trace() { m_enable_debug_trace = true; }$/;"	f	class:ptx_thread_info
enable_ptx_file_line_stats	ptx-stats.cc	/^bool enable_ptx_file_line_stats;$/;"	v
end_function	ptx_parser.cc	/^void end_function() $/;"	f
end_transaction	ptx_sim.h	/^    void end_transaction() {$/;"	f	class:ptx_thread_info
estimate_coherence_traffic	tm_manager.cc	/^void tm_global_state::estimate_coherence_traffic(const addr_set_t& write_set, unsigned commit_tuid)$/;"	f	class:tm_global_state
ex2_impl	instructions.cc	/^void ex2_impl( const ptx_instruction *pI, ptx_thread_info *thread ) $/;"	f
exact_num_writing_threads	tm_manager_internal.h	/^   typedef std::unordered_map<addr_t, unsigned int> exact_num_writing_threads; $/;"	t	class:logical_temporal_conflict_detector
exec_count	ptx-stats.cc	/^    unsigned long exec_count;$/;"	m	class:ptx_file_line_stats	file:
execute	cuda-sim.cc	/^void functionalCoreSim::execute()$/;"	f	class:functionalCoreSim
executeWarp	cuda-sim.cc	/^void functionalCoreSim::executeWarp(unsigned i, bool &allAtBarrier, bool & someOneLive)$/;"	f	class:functionalCoreSim
exitCore	ptx_sim.h	/^   void exitCore()$/;"	f	class:ptx_thread_info
exit_impl	instructions.cc	/^void exit_impl( const ptx_instruction *pI, ptx_thread_info *thread ) $/;"	f
expand_hashed_sigbit	bloomfilter.cc	/^hashtable_bits_mt::tvec_t hashtable_bits_mt::expand_hashed_sigbit(const hashed_tvec_t& hashed_sig) const$/;"	f	class:hashtable_bits_mt
exposed_latency	ptx-stats.cc	/^    unsigned long long exposed_latency; \/\/ latency exposed as pipeline bubbles (attributed to this instruction)$/;"	m	class:ptx_file_line_stats	file:
extensions	ptx_sim.h	/^      unsigned extensions() const { assert(m_valid); return m_ptx_extensions; }$/;"	f	class:ptx_version
f16	ptx_sim.h	/^   float             f16; $/;"	m	union:ptx_reg_t
f2f	instructions.cc	/^ptx_reg_t f2f( ptx_reg_t x, unsigned from_width, unsigned to_width, int to_sign, int rounding_mode, int saturation_mode )$/;"	f
f2x	instructions.cc	/^ptx_reg_t f2x( ptx_reg_t x, unsigned from_width, unsigned to_width, int to_sign, int rounding_mode, int saturation_mode )$/;"	f
f32	ptx_sim.h	/^   float          f32;$/;"	m	union:ptx_reg_t
f64	ptx_sim.h	/^   double            f64;$/;"	m	union:ptx_reg_t
fast_set_match	tm_manager.cc	/^bool fast_set_match(addr_set_t &a, addr_set_t &b) $/;"	f
feature_not_implemented	ptx_sim.cc	/^void feature_not_implemented( const char *f ) $/;"	f
finalize	cuda-sim.cc	/^void function_info::finalize( memory_space *param_mem ) $/;"	f	class:function_info
find_break_target	ptx_ir.cc	/^operand_info* function_info::find_break_target( ptx_instruction * p_break_insn ) \/\/find the target of a break instruction $/;"	f	class:function_info
find_dominators	ptx_ir.cc	/^void function_info::find_dominators( )$/;"	f	class:function_info
find_idominators	ptx_ir.cc	/^void function_info::find_idominators( )$/;"	f	class:function_info
find_ipostdominators	ptx_ir.cc	/^void function_info::find_ipostdominators( )$/;"	f	class:function_info
find_next_real_instruction	ptx_ir.cc	/^std::list<ptx_instruction*>::iterator function_info::find_next_real_instruction( std::list<ptx_instruction*>::iterator i)$/;"	f	class:function_info
find_postdominators	ptx_ir.cc	/^void function_info::find_postdominators( )$/;"	f	class:function_info
find_reconvergence_points	cuda-sim.cc	/^struct rec_pts find_reconvergence_points( function_info *finfo )$/;"	f
float2	cuda-math.h	/^   struct float2 {$/;"	s	namespace:cuda_math
float2	cuda-math.h	/^   typedef struct float2 float2;$/;"	t	namespace:cuda_math	typeref:struct:cuda_math::float2
float2int	cuda-math.h	/^int float2int(float a, enum cudaRoundMode mode)$/;"	f	namespace:cuda_math
float2uint	cuda-math.h	/^unsigned int float2uint(float a, enum cudaRoundMode mode)$/;"	f	namespace:cuda_math
float4	cuda-math.h	/^   struct float4 {$/;"	s	namespace:cuda_math
float4	cuda-math.h	/^   typedef struct float4 float4;$/;"	t	namespace:cuda_math	typeref:struct:cuda_math::float4
float_op_t	ptx_ir.h	/^   reg_t, vector_t, builtin_t, address_t, memory_t, float_op_t, double_op_t, int_t, $/;"	e	enum:operand_type
floating_point_rounding_mode	ptx.y	/^floating_point_rounding_mode: RN_OPTION { add_option(RN_OPTION); } $/;"	l
fma_impl	instructions.cc	/^void fma_impl( const ptx_instruction *pI, ptx_thread_info *thread ) $/;"	f
func_addr	ptx_ir.h	/^   const operand_info &func_addr() const$/;"	f	class:ptx_instruction
func_header	ptx_parser.cc	/^void func_header(const char* a) {} \/\/intentional dummy function$/;"	f
func_header_info	ptx_parser.cc	/^void func_header_info(const char* a) {} \/\/intentional dummy function$/;"	f
func_header_info_int	ptx_parser.cc	/^void func_header_info_int(const char* a, int b) {} \/\/intentional dummy function$/;"	f
func_info	ptx_sim.h	/^   function_info *func_info()$/;"	f	class:ptx_thread_info
funct_id	bloomfilter.h	/^   unsigned int funct_id() const { return m_funct_id; } $/;"	f	class:hashtable
funct_id	bloomfilter.h	/^   unsigned int funct_id() const { return m_funct_id; } $/;"	f	class:versioning_hashtable
function_decl	ptx.y	/^function_decl: function_decl_header LEFT_PAREN { start_function($1); func_header_info("(");} param_entry RIGHT_PAREN {func_header_info(")");} function_ident_param { $$ = reset_symtab(); }$/;"	l
function_decl_header	ptx.y	/^function_decl_header: ENTRY_DIRECTIVE { $$ = 1; g_func_decl=1; func_header(".entry"); }$/;"	l
function_defn	ptx.y	/^function_defn: function_decl { set_symtab($1); func_header(".skip"); } statement_block { end_function(); }$/;"	l
function_ident_param	ptx.y	/^function_ident_param: IDENTIFIER { add_function_name($1); } LEFT_PAREN {func_header_info("(");} param_list RIGHT_PAREN { g_func_decl=0; func_header_info(")"); } $/;"	l
function_info	ptx_ir.cc	/^function_info::function_info(int entry_point ) $/;"	f	class:function_info
function_info	ptx_ir.h	/^class function_info {$/;"	c
function_info	ptxinfo.y	/^function_info: info$/;"	l
function_name	ptxinfo.y	/^function_name: FUNC QUOTE IDENTIFIER QUOTE { ptxinfo_function($3); }$/;"	l
functionalCoreSim	cuda-sim.h	/^    functionalCoreSim(kernel_info_t * kernel, gpgpu_sim *g, unsigned warp_size)$/;"	f	class:functionalCoreSim
functionalCoreSim	cuda-sim.h	/^class functionalCoreSim: public core_t$/;"	c
g_add_identifier_cached__array_dim	ptx_parser.cc	/^int g_add_identifier_cached__array_dim;$/;"	v
g_add_identifier_cached__array_ident	ptx_parser.cc	/^int g_add_identifier_cached__array_ident;$/;"	v
g_add_identifier_cached__identifier	ptx_parser.cc	/^char *g_add_identifier_cached__identifier = NULL;$/;"	v
g_alignment_spec	ptx_parser.cc	/^int g_alignment_spec = -1;$/;"	v
g_assemble_code_next_pc	cuda-sim.cc	/^unsigned g_assemble_code_next_pc=0; $/;"	v
g_const_alloc	ptx_parser.cc	/^unsigned g_const_alloc = 1;$/;"	v
g_const_name_lookup	cuda-sim.cc	/^std::map<const void*,std::string>   g_const_name_lookup; \/\/ indexed by hostVar$/;"	v
g_constants	cuda-sim.cc	/^std::set<std::string>   g_constants;$/;"	v
g_cuda_launch_blocking	cuda-sim.cc	/^bool g_cuda_launch_blocking = false;$/;"	v
g_current_symbol_table	ptx_parser.cc	/^static symbol_table *g_current_symbol_table = NULL;$/;"	v	file:
g_cvt_fn	instructions.cc	/^ptx_reg_t (*g_cvt_fn[11][11])( ptx_reg_t x, unsigned from_width, unsigned to_width, int to_sign, $/;"	v
g_debug_execution	cuda-sim.cc	/^int g_debug_execution = 0;$/;"	v
g_debug_ir_generation	ptx_parser.cc	/^static bool g_debug_ir_generation=false;$/;"	v	file:
g_debug_pc	cuda-sim.cc	/^addr_t g_debug_pc = 0xBEEF1518;$/;"	v
g_debug_thread_uid	cuda-sim.cc	/^int g_debug_thread_uid = 0;$/;"	v
g_entry_func_param_index	ptx_parser.cc	/^static unsigned g_entry_func_param_index=0;$/;"	v	file:
g_entry_point	ptx_parser.cc	/^static int g_entry_point;$/;"	v	file:
g_error_detected	ptx_parser.cc	/^int g_error_detected = 0;$/;"	v
g_extern_spec	ptx_parser.cc	/^int g_extern_spec = 0;$/;"	v
g_filename	ptx_parser.cc	/^const char *g_filename;$/;"	v
g_func_cta_info	cuda-sim.cc	/^ptx_cta_info *g_func_cta_info = NULL;$/;"	v
g_func_decl	ptx_parser.cc	/^int g_func_decl = 0;$/;"	v
g_func_info	ptx_parser.cc	/^static function_info *g_func_info = NULL;$/;"	v	file:
g_global_allfiles_symbol_table	ptx_parser.cc	/^static symbol_table *g_global_allfiles_symbol_table = NULL;$/;"	v	file:
g_global_mem	ptx_loader.cc	/^memory_space *g_global_mem;$/;"	v
g_global_name_lookup	cuda-sim.cc	/^std::map<const void*,std::string>   g_global_name_lookup; \/\/ indexed by hostVar$/;"	v
g_global_symbol_table	ptx_parser.cc	/^static symbol_table *g_global_symbol_table = NULL;$/;"	v	file:
g_globals	cuda-sim.cc	/^std::set<std::string>   g_globals;$/;"	v
g_gskew	hashfunc.h	/^static hasht_funct::gskew_hash *g_gskew = NULL;$/;"	v
g_h3_1	hashfunc.cc	/^static std::map<unsigned int, hasht_funct::h3_hash *> g_h3_1;$/;"	v	file:
g_h3_2	hashfunc.cc	/^static std::map<unsigned int, hasht_funct::h3_hash *> g_h3_2;$/;"	v	file:
g_h3_3	hashfunc.cc	/^static std::map<unsigned int, hasht_funct::h3_hash *> g_h3_3;$/;"	v	file:
g_h3_4	hashfunc.cc	/^static std::map<unsigned int, hasht_funct::h3_hash *> g_h3_4;$/;"	v	file:
g_hash_function_set	bloomfilter.cc	/^int g_hash_function_set = TOY_SET; $/;"	v
g_ident_add_uid	ptx_parser.cc	/^int g_ident_add_uid = 0;$/;"	v
g_inst_classification_stat	cuda-sim.cc	/^void ** g_inst_classification_stat = NULL;$/;"	v
g_inst_lookup	ptx_parser.cc	/^std::map<std::string,std::map<unsigned,const ptx_instruction*> > g_inst_lookup;$/;"	v
g_inst_op_classification_stat	cuda-sim.cc	/^void ** g_inst_op_classification_stat= NULL;$/;"	v
g_instructions	ptx_parser.cc	/^static std::list<ptx_instruction*> g_instructions;$/;"	v	file:
g_keep_intermediate_files	ptx_loader.cc	/^bool g_keep_intermediate_files;$/;"	v
g_label	ptx_parser.cc	/^symbol *g_label;$/;"	v
g_last_symbol	ptx_parser.cc	/^static symbol *g_last_symbol = NULL;$/;"	v	file:
g_last_writer	tm_manager.cc	/^tr1_hash_map<addr_t, last_writer_info> g_last_writer; $/;"	v
g_max_regs_per_thread	ptx_parser.cc	/^unsigned g_max_regs_per_thread = 0;$/;"	v
g_mf_stalled_uid	tm_manager.cc	/^int g_mf_stalled_uid = 0;$/;"	v
g_neg_pred	ptx_parser.cc	/^int g_neg_pred;$/;"	v
g_num_ptx_inst_uid	instructions.cc	/^unsigned ptx_instruction::g_num_ptx_inst_uid=0;$/;"	m	class:ptx_instruction	file:
g_num_ptx_inst_uid	ptx_ir.h	/^   static unsigned g_num_ptx_inst_uid;$/;"	m	class:ptx_instruction
g_opcode	ptx_parser.cc	/^int g_opcode = -1;$/;"	v
g_opcode_string	instructions.cc	/^const char *g_opcode_string[NUM_OPCODES] = {$/;"	v
g_operands	ptx_parser.cc	/^std::list<operand_info> g_operands;$/;"	v
g_options	ptx_parser.cc	/^std::list<int> g_options;$/;"	v
g_override_embedded_ptx	ptx_loader.cc	/^bool g_override_embedded_ptx = false;$/;"	v
g_param_mem	ptx_loader.cc	/^memory_space *g_param_mem;$/;"	v
g_pc_to_finfo	cuda-sim.cc	/^std::map<unsigned,function_info*> g_pc_to_finfo;$/;"	v
g_pred	ptx_parser.cc	/^const symbol *g_pred;$/;"	v
g_pred_mod	ptx_parser.cc	/^int g_pred_mod;$/;"	v
g_print_memory_space	memory.cc	/^void g_print_memory_space(memory_space *mem, const char *format = "%08x", FILE *fout = stdout) $/;"	f
g_ptr_spec	ptx_parser.cc	/^memory_space_t g_ptr_spec = undefined_space;$/;"	v
g_ptx_cta_info_sm_idx_used	ptx_sim.cc	/^std::set<unsigned long long> g_ptx_cta_info_sm_idx_used;$/;"	v
g_ptx_cta_info_uid	ptx_sim.cc	/^unsigned long long g_ptx_cta_info_uid = 1;$/;"	v
g_ptx_kernel_count	cuda-sim.cc	/^int g_ptx_kernel_count = -1; \/\/ used for classification stat collection purposes $/;"	v
g_ptx_sim_mode	cuda-sim.cc	/^int g_ptx_sim_mode; \/\/ if non-zero run functional simulation only (i.e., no notion of a clock cycle)$/;"	v
g_ptx_sim_num_insn	cuda-sim.cc	/^unsigned g_ptx_sim_num_insn = 0;$/;"	v
g_ptx_thread_info_delete_count	ptx_sim.cc	/^unsigned g_ptx_thread_info_delete_count=0;$/;"	v
g_ptx_thread_info_uid_next	ptx_sim.cc	/^unsigned g_ptx_thread_info_uid_next=1;$/;"	v
g_ptx_token_decode	ptx_parser.cc	/^static std::map<unsigned,std::string> g_ptx_token_decode;$/;"	v	file:
g_ptxinfo_error_detected	cuda-sim.cc	/^int g_ptxinfo_error_detected;$/;"	v
g_ptxinfo_filename	ptx_loader.cc	/^const char *g_ptxinfo_filename;$/;"	v
g_ptxinfo_kinfo	cuda-sim.cc	/^static struct gpgpu_ptx_sim_kernel_info g_ptxinfo_kinfo;$/;"	v	typeref:struct:gpgpu_ptx_sim_kernel_info	file:
g_ptxinfo_kname	cuda-sim.cc	/^static char *g_ptxinfo_kname = NULL;$/;"	v	file:
g_return_var	ptx_parser.cc	/^static operand_info g_return_var;$/;"	v	file:
g_rpts	cuda-sim.cc	/^struct std::map<function_info*,rec_pts> g_rpts;$/;"	v	typeref:struct:map
g_save_embedded_ptx	ptx_loader.cc	/^static bool g_save_embedded_ptx;$/;"	v	file:
g_scalar_type	ptx_parser.cc	/^std::list<int> g_scalar_type;$/;"	v
g_scalar_type_spec	ptx_parser.cc	/^int g_scalar_type_spec = -1;$/;"	v
g_shader_core_config	ptx_parser.cc	/^static const struct core_config *g_shader_core_config;$/;"	v	typeref:struct:core_config	file:
g_space_spec	ptx_parser.cc	/^memory_space_t g_space_spec = undefined_space;$/;"	v
g_surf_mem	ptx_loader.cc	/^memory_space *g_surf_mem;$/;"	v
g_sym_name_to_symbol_table	ptx_parser.cc	/^std::map<std::string,symbol_table*> g_sym_name_to_symbol_table;$/;"	v
g_tex_mem	ptx_loader.cc	/^memory_space *g_tex_mem;$/;"	v
g_tm_bloomfilter_options	tm_manager.cc	/^tm_bloomfilter_options g_tm_bloomfilter_options; $/;"	v
g_tm_global_state	tm_manager.cc	/^tm_global_state g_tm_global_state;$/;"	v
g_tm_global_statistics	tm_manager.cc	/^tm_global_statistics g_tm_global_statistics; $/;"	v
g_tm_manager_next_uid	tm_manager.cc	/^unsigned g_tm_manager_next_uid = 0;$/;"	v
g_tm_options	tm_manager.cc	/^tm_options g_tm_options; $/;"	v
g_tm_ring_global	tm_manager.cc	/^tm_ring_global g_tm_ring_global; $/;"	v
g_tm_ring_stats	tm_manager.cc	/^tm_ring_stats g_tm_ring_stats; $/;"	v
g_var_type	ptx_parser.cc	/^type_info *g_var_type = NULL;$/;"	v
g_vector_spec	ptx_parser.cc	/^int g_vector_spec = -1;$/;"	v
g_watched_thread_a	tm_manager.cc	/^static const unsigned g_watched_thread_a = 13752; \/\/ 668 + 46080 + 1; $/;"	v	file:
g_watched_thread_b	tm_manager.cc	/^static const unsigned g_watched_thread_b = -1; \/\/ 1469 + 46080 + 1; $/;"	v	file:
g_watched_thread_c	tm_manager.cc	/^static const unsigned g_watched_thread_c = -1; \/\/ 967 + 46080 + 1; $/;"	v	file:
generic_to_global	cuda-sim.cc	/^addr_t generic_to_global( addr_t addr )$/;"	f
generic_to_local	cuda-sim.cc	/^addr_t generic_to_local( unsigned smid, unsigned hwtid, addr_t addr )$/;"	f
generic_to_shared	cuda-sim.cc	/^addr_t generic_to_shared( unsigned smid, addr_t addr )$/;"	f
get_BF	tm_manager.cc	/^const tm_bloomfilter_set& tm_global_state::get_BF(unsigned tuid) const$/;"	f	class:tm_global_state
get_PC	ptx_ir.h	/^   addr_t get_PC() const$/;"	f	class:ptx_instruction
get_access_size	tm_manager_internal.h	/^   size_t get_access_size() const { return (m_read_word_set.size() + m_write_word_set.size()); }$/;"	f	class:tm_manager
get_addr_offset	ptx_ir.h	/^   int get_addr_offset() const { return m_addr_offset;}$/;"	f	class:operand_info
get_addr_space	ptx_ir.h	/^   enum _memory_space_t get_addr_space() const { return m_addr_space; }$/;"	f	class:operand_info
get_address	ptx_ir.h	/^   addr_t get_address() const $/;"	f	class:symbol
get_arg	ptx_ir.h	/^   const symbol* get_arg( unsigned n ) const$/;"	f	class:function_info
get_array_dim	ptx_ir.h	/^   int get_array_dim() const { assert(m_init); return m_array_dim; }$/;"	f	class:type_info_key
get_array_type	ptx_ir.cc	/^type_info *symbol_table::get_array_type( type_info *base_type, unsigned array_dim ) $/;"	f	class:symbol_table
get_atomic	ptx_ir.h	/^   unsigned get_atomic() const { return m_atomic_spec;}$/;"	f	class:ptx_instruction
get_bb	ptx_ir.h	/^   basic_block_t* get_bb() { return m_basic_block;}$/;"	f	class:ptx_instruction
get_bit	ptx_sim.h	/^   int get_bit( unsigned bit )$/;"	f	union:ptx_reg_t
get_builtin	ptx_sim.cc	/^unsigned ptx_thread_info::get_builtin( int builtin_id, unsigned dim_mod ) $/;"	f	class:ptx_thread_info
get_chunk_address	tm_manager.cc	/^addr_t logical_temporal_conflict_detector::get_chunk_address( addr_t input_addr ) $/;"	f	class:logical_temporal_conflict_detector
get_chunk_address	tm_manager.cc	/^addr_t temporal_conflict_detector::get_chunk_address( addr_t input_addr ) $/;"	f	class:temporal_conflict_detector
get_cmpop	ptx_ir.h	/^   unsigned get_cmpop() const { return m_compare_op;}$/;"	f	class:ptx_instruction
get_config	ptx_sim.h	/^   const gpgpu_functional_sim_config &get_config() const { return m_gpu->get_config(); }$/;"	f	class:ptx_thread_info
get_const_mem_offset	ptx_ir.h	/^   addr_t get_const_mem_offset() const { return m_const_mem_offset; }$/;"	f	class:operand_info
get_converge_point	cuda-sim.cc	/^address_type get_converge_point( address_type pc ) $/;"	f
get_core	ptx_sim.h	/^   core_t *get_core() { return m_core; }$/;"	f	class:ptx_thread_info
get_cta_uid	ptx_sim.h	/^   unsigned long long get_cta_uid() { return m_cta_info->get_sm_idx();}$/;"	f	class:ptx_thread_info
get_ctaid	ptx_sim.h	/^   dim3 get_ctaid() const { return m_ctaid; }$/;"	f	class:ptx_thread_info
get_double_operand_type	ptx_ir.h	/^   int get_double_operand_type() const { return  m_double_operand_type; }$/;"	f	class:operand_info
get_dst	ptx_ir.h	/^   const symbol *get_dst() const { return m_dst; }$/;"	f	class:arg_buffer_t
get_expanded_hashed_sigbit	bloomfilter.h	/^   tvec_t get_expanded_hashed_sigbit(addr_t addr) const {$/;"	f	class:hashtable_bits_mt
get_finfo	ptx_sim.h	/^   const function_info *get_finfo() const { return m_func_info;   }$/;"	f	class:ptx_thread_info
get_finfo	ptx_sim.h	/^   function_info *get_finfo() { return m_func_info;   }$/;"	f	class:ptx_thread_info
get_function_name	cuda-sim.cc	/^std::string get_function_name( class function_info *entry )$/;"	f
get_function_size	ptx_ir.h	/^   unsigned get_function_size() { return m_instructions.size();}$/;"	f	class:function_info
get_global_memory	ptx_sim.h	/^   memory_space *get_global_memory() { return m_gpu->get_global_memory(); }$/;"	f	class:ptx_thread_info
get_global_next	ptx_ir.h	/^   addr_t get_global_next() { return m_global_next;}$/;"	f	class:symbol_table
get_gpu	ptx_sim.h	/^   class gpgpu_sim *get_gpu() { return (gpgpu_sim*)m_gpu;}$/;"	f	class:ptx_thread_info
get_hashed_sigbit	bloomfilter.h	/^   const hashed_tvec_t& get_hashed_sigbit(addr_t addr) const {$/;"	f	class:hashtable_bits_mt
get_hw_ctaid	ptx_sim.h	/^   unsigned get_hw_ctaid() const { return m_hw_ctaid;}$/;"	f	class:ptx_thread_info
get_hw_sid	ptx_sim.h	/^   unsigned get_hw_sid() const { return m_hw_sid;}$/;"	f	class:ptx_thread_info
get_hw_tid	ptx_sim.h	/^   unsigned get_hw_tid() const { return m_hw_tid;}$/;"	f	class:ptx_thread_info
get_hw_wid	ptx_sim.h	/^   unsigned get_hw_wid() const { return m_hw_wid;}$/;"	f	class:ptx_thread_info
get_icount	ptx_sim.h	/^   unsigned get_icount() const { return m_icount;}$/;"	f	class:ptx_thread_info
get_initial_pts	tm_manager_internal.h	/^   tm_timestamp_t get_initial_pts(unsigned index) {$/;"	f	class:logical_temporal_conflict_detector
get_initializer	ptx_ir.h	/^   std::list<operand_info> get_initializer() const$/;"	f	class:symbol
get_insn_str	ptx_ir.cc	/^std::string function_info::get_insn_str( unsigned pc ) const$/;"	f	class:function_info
get_inst	ptx_sim.cc	/^const ptx_instruction *ptx_thread_info::get_inst( addr_t pc ) const$/;"	f	class:ptx_thread_info
get_inst	ptx_sim.cc	/^const ptx_instruction *ptx_thread_info::get_inst() const$/;"	f	class:ptx_thread_info
get_instruction	ptx_ir.h	/^   const ptx_instruction *get_instruction( unsigned PC ) const$/;"	f	class:function_info
get_int	ptx_ir.h	/^   int get_int() const { return m_value.m_int;}$/;"	f	class:operand_info
get_is_abort_need_clean	tm_manager.h	/^   virtual bool get_is_abort_need_clean() { return m_is_abort_need_clean; }$/;"	f	class:tm_manager_inf
get_is_warp_level	tm_manager.h	/^   virtual bool get_is_warp_level() { return m_is_warp_level; }$/;"	f	class:tm_manager_inf
get_kernel_code_size	cuda-sim.cc	/^size_t get_kernel_code_size( class function_info *entry )$/;"	f
get_kernel_info	ptx_ir.h	/^   const struct gpgpu_ptx_sim_kernel_info* get_kernel_info () const$/;"	f	class:function_info
get_key	ptx_ir.h	/^   const type_info_key &get_key() const { return m_type_info;}$/;"	f	class:type_info
get_label	ptx_ir.h	/^   const symbol *get_label() const { return m_label;}$/;"	f	class:ptx_instruction
get_literal_value	ptx_ir.h	/^   ptx_reg_t get_literal_value() const$/;"	f	class:operand_info
get_local_mem_stack_pointer	ptx_sim.h	/^   unsigned get_local_mem_stack_pointer() const { return m_local_mem_stack_pointer; }$/;"	f	class:ptx_thread_info
get_local_next	ptx_ir.h	/^   addr_t get_local_next( unsigned param_size )$/;"	f	class:symbol_table
get_local_next	ptx_ir.h	/^   addr_t get_local_next() { return m_local_next;}$/;"	f	class:symbol_table
get_location	ptx_sim.cc	/^std::string ptx_thread_info::get_location() const$/;"	f	class:ptx_thread_info
get_logical_version	bloomfilter.cc	/^void versioning_hashtable::get_logical_version(addr_t addr, unsigned int &version, unsigned int &shader_id, unsigned int &warp_id) const$/;"	f	class:versioning_hashtable
get_m_instr_mem_index	ptx_ir.h	/^   unsigned get_m_instr_mem_index() { return m_instr_mem_index;}$/;"	f	class:ptx_instruction
get_memory_space	ptx_ir.h	/^   memory_space_t get_memory_space() const { return m_space_spec; }$/;"	f	class:type_info_key
get_memory_space	tm_manager_internal.h	/^        memory_space* get_memory_space() const { return m_mem; } $/;"	f	class:tm_manager::access_record
get_n_read	tm_manager_internal.h	/^   virtual unsigned get_n_read() const { return m_n_read; }$/;"	f	class:tm_manager
get_n_write	tm_manager_internal.h	/^   virtual unsigned get_n_write() const { return m_n_write; }$/;"	f	class:tm_manager
get_name	ptx_ir.h	/^   std::string get_name() const { assert(m_valid); return m_name; }$/;"	f	class:param_info
get_name	ptx_ir.h	/^   std::string get_name() const$/;"	f	class:function_info
get_num_operands	ptx_ir.h	/^   unsigned get_num_operands() const { return m_operands.size();}$/;"	f	class:ptx_instruction
get_num_reconvergence_pairs	ptx_ir.cc	/^unsigned function_info::get_num_reconvergence_pairs()$/;"	f	class:function_info
get_num_writing_threads	tm_manager.cc	/^unsigned int logical_temporal_conflict_detector::get_num_writing_threads(addr_t addr) {$/;"	f	class:logical_temporal_conflict_detector
get_offset	ptx_ir.h	/^   unsigned get_offset() { assert(m_valid); return m_offset; }$/;"	f	class:param_info
get_opcode	ptx_ir.h	/^   int get_opcode() const { return m_opcode;}$/;"	f	class:ptx_instruction
get_opcode_cstr	ptx_ir.h	/^   const char *get_opcode_cstr() const $/;"	f	class:ptx_instruction
get_operand_lohi	ptx_ir.h	/^   int get_operand_lohi() const { return m_operand_lohi; }$/;"	f	class:operand_info
get_operand_nbits	instructions.cc	/^unsigned get_operand_nbits( const operand_info &op )$/;"	f
get_operand_neg	ptx_ir.h	/^   bool get_operand_neg() const { return m_operand_neg; }$/;"	f	class:operand_info
get_operand_value	instructions.cc	/^ptx_reg_t ptx_thread_info::get_operand_value( const operand_info &op, operand_info dstInfo, unsigned opType, ptx_thread_info *thread, int derefFlag )$/;"	f	class:ptx_thread_info
get_owner	tm_manager.cc	/^warp_logical_id logical_temporal_conflict_detector::get_owner(addr_t addr) {$/;"	f	class:logical_temporal_conflict_detector
get_param_buffer	ptx_ir.h	/^   const void *get_param_buffer() const$/;"	f	class:arg_buffer_t
get_param_buffer_size	ptx_ir.h	/^   size_t get_param_buffer_size() const$/;"	f	class:arg_buffer_t
get_param_memory	ptx_sim.h	/^   memory_space *get_param_memory() { return m_kernel.get_param_memory(); }$/;"	f	class:ptx_thread_info
get_pc	ptx_ir.h	/^   function_info *get_pc() const$/;"	f	class:symbol
get_pc	ptx_sim.h	/^   unsigned get_pc() const$/;"	f	class:ptx_thread_info
get_pred	ptx_ir.h	/^   operand_info get_pred() const { return operand_info( m_pred );}$/;"	f	class:ptx_instruction
get_pred_mod	ptx_ir.h	/^   int get_pred_mod() const { return m_pred_mod;}$/;"	f	class:ptx_instruction
get_pred_neg	ptx_ir.h	/^   bool get_pred_neg() const { return m_neg_pred;}$/;"	f	class:ptx_instruction
get_ptx_thread	tm_manager.h	/^   ptx_thread_info *get_ptx_thread() { return m_thread; }$/;"	f	class:tm_manager_inf
get_ptx_version	ptx_ir.cc	/^const ptx_version &symbol_table::get_ptx_version() const $/;"	f	class:symbol_table
get_ptx_version	ptx_ir.h	/^   const ptx_version &get_ptx_version() const { return m_symtab->get_ptx_version(); }$/;"	f	class:function_info
get_ptx_version	ptx_sim.cc	/^const ptx_version &ptx_thread_info::get_ptx_version() const $/;"	f	class:ptx_thread_info
get_ptxinfo_kinfo	cuda-sim.cc	/^struct gpgpu_ptx_sim_kernel_info get_ptxinfo_kinfo()$/;"	f
get_ptxinfo_kname	cuda-sim.cc	/^const char *get_ptxinfo_kname() $/;"	f
get_read_conflict_detection	tm_manager_internal.h	/^   bool get_read_conflict_detection() { return m_read_conflict_detection; }$/;"	f	class:tm_manager
get_read_conflict_detection	tm_manager_internal.h	/^   virtual bool get_read_conflict_detection() const { return m_read_conflict_detection; }$/;"	f	class:tm_manager
get_reconvergence_pairs	ptx_ir.cc	/^void function_info::get_reconvergence_pairs(gpgpu_recon_t* recon_points)$/;"	f	class:function_info
get_ref_count	tm_manager.cc	/^int tm_manager_inf::get_ref_count() { return m_ref_count; }$/;"	f	class:tm_manager_inf
get_reg	instructions.cc	/^ptx_reg_t ptx_thread_info::get_reg( const symbol *reg )$/;"	f	class:ptx_thread_info
get_reg	ptx_ir.h	/^   ptx_reg_t get_reg() const $/;"	f	class:arg_buffer_t
get_return_PC	ptx_sim.h	/^   unsigned get_return_PC()$/;"	f	class:ptx_thread_info
get_return_pc	cuda-sim.cc	/^address_type get_return_pc( void *thd )$/;"	f
get_return_var	ptx_ir.h	/^   const symbol *get_return_var() const$/;"	f	class:function_info
get_rpc	ptx_sim.h	/^   unsigned get_rpc() const { return m_RPC; }$/;"	f	class:ptx_thread_info
get_rts	tm_manager.cc	/^tm_timestamp_t logical_temporal_conflict_detector::get_rts( addr_t addr) $/;"	f	class:logical_temporal_conflict_detector
get_scope_name	ptx_ir.h	/^   std::string get_scope_name() const { return m_scope_name; }$/;"	f	class:symbol_table
get_shared_next	ptx_ir.h	/^   addr_t get_shared_next() { return m_shared_next;}$/;"	f	class:symbol_table
get_sigbit	bloomfilter.h	/^   const tvec_t& get_sigbit(addr_t addr) const {$/;"	f	class:hashtable_bits_mt
get_singleton	tm_manager.cc	/^logical_temporal_conflict_detector& logical_temporal_conflict_detector::get_singleton() $/;"	f	class:logical_temporal_conflict_detector
get_singleton	tm_manager.cc	/^temporal_conflict_detector& temporal_conflict_detector::get_singleton() $/;"	f	class:temporal_conflict_detector
get_size	ptx_ir.h	/^   size_t get_size() const { assert(m_valid); return m_size; }$/;"	f	class:param_info
get_size_in_bytes	ptx_ir.h	/^   unsigned get_size_in_bytes() const$/;"	f	class:symbol
get_sm_idx	ptx_sim.cc	/^unsigned ptx_cta_info::get_sm_idx() const$/;"	f	class:ptx_cta_info
get_sm_target	ptx_ir.cc	/^unsigned symbol_table::get_sm_target() const $/;"	f	class:symbol_table
get_sm_target	ptx_ir.h	/^   unsigned get_sm_target() const { return m_symtab->get_sm_target(); }$/;"	f	class:function_info
get_source	ptx_ir.h	/^   const char *get_source() const { return m_source.c_str();}$/;"	f	class:ptx_instruction
get_space	ptx_ir.h	/^   memory_space_t get_space() const { return m_space_spec;}$/;"	f	class:ptx_instruction
get_start_PC	ptx_ir.h	/^   addr_t get_start_PC() const$/;"	f	class:function_info
get_surf_memory	ptx_sim.h	/^   memory_space *get_surf_memory() { return m_gpu->get_surf_memory(); }$/;"	f	class:ptx_thread_info
get_symbol	ptx_ir.h	/^   const symbol *get_symbol() const { return m_value.m_symbolic;}$/;"	f	class:operand_info
get_symtab	ptx_ir.h	/^   symbol_table *get_symtab()$/;"	f	class:function_info
get_tex_datasize	cuda-sim.cc	/^static unsigned get_tex_datasize( const ptx_instruction *pI, ptx_thread_info *thread )$/;"	f	file:
get_tex_memory	ptx_sim.h	/^   memory_space *get_tex_memory() { return m_gpu->get_tex_memory(); }$/;"	f	class:ptx_thread_info
get_tex_next	ptx_ir.h	/^   addr_t get_tex_next() { return m_tex_next;}$/;"	f	class:symbol_table
get_tid	ptx_sim.h	/^   dim3 get_tid() const { return m_tid; }$/;"	f	class:ptx_thread_info
get_tm_manager	ptx_sim.h	/^    tm_manager_inf * get_tm_manager() { return m_tm_manager; }$/;"	f	class:ptx_thread_info
get_type	ptx_ir.h	/^   enum operand_type get_type() const {$/;"	f	class:operand_info
get_type	ptx_ir.h	/^   int get_type() const $/;"	f	class:ptx_instruction
get_type	ptx_ir.h	/^   int get_type() const { assert(m_valid);  return m_type; }$/;"	f	class:param_info
get_type2	ptx_ir.h	/^   int get_type2() const $/;"	f	class:ptx_instruction
get_uid	ptx_ir.cc	/^unsigned operand_info::get_uid()$/;"	f	class:operand_info
get_uid	ptx_ir.cc	/^unsigned symbol::get_uid()$/;"	f	class:symbol
get_uid	ptx_sim.h	/^   unsigned get_uid() const$/;"	f	class:ptx_thread_info
get_value	ptx_ir.h	/^   param_t get_value() const { assert(m_value_set); return m_value; }$/;"	f	class:param_info
get_vect_nelem	ptx_ir.h	/^   unsigned get_vect_nelem() const$/;"	f	class:operand_info
get_vector	ptx_ir.h	/^   unsigned get_vector() const { return m_vector_spec;}$/;"	f	class:ptx_instruction
get_vector_operand_values	instructions.cc	/^void ptx_thread_info::get_vector_operand_values( const operand_info &op, ptx_reg_t* ptx_regs, unsigned num_elements )$/;"	f	class:ptx_thread_info
get_version	bloomfilter.cc	/^unsigned int versioning_bloomfilter::get_version(addr_t addr) const$/;"	f	class:versioning_bloomfilter
get_version	bloomfilter.cc	/^unsigned int versioning_hashtable::get_version(addr_t addr) const $/;"	f	class:versioning_hashtable
get_version_management	tm_manager_internal.h	/^   virtual bool get_version_management() const { return m_version_management; }$/;"	f	class:tm_manager
get_warp_pts_current	tm_manager_internal.h	/^   tm_timestamp_t get_warp_pts_current(unsigned index) { return m_warp_pts_current[index]; }$/;"	f	class:logical_temporal_conflict_detector
get_warp_pts_start	tm_manager_internal.h	/^   tm_timestamp_t get_warp_pts_start(unsigned index) { return m_warp_pts_start[index]; }$/;"	f	class:logical_temporal_conflict_detector
get_write_conflict_detection	tm_manager_internal.h	/^   bool get_write_conflict_detection() { return m_write_conflict_detection; }$/;"	f	class:tm_manager
get_write_conflict_detection	tm_manager_internal.h	/^   virtual bool get_write_conflict_detection() const { return m_write_conflict_detection; }$/;"	f	class:tm_manager
get_wts	tm_manager.cc	/^tm_timestamp_t logical_temporal_conflict_detector::get_wts( addr_t addr) $/;"	f	class:logical_temporal_conflict_detector
getaddr	tm_manager_internal.h	/^   	addr_t getaddr(){return m_addr;}$/;"	f	class:tm_manager::access_record
getsize	tm_manager_internal.h	/^   	unsigned getsize (){return m_nbytes;}$/;"	f	class:tm_manager::access_record
getvalue	tm_manager_internal.h	/^   	void* getvalue(){return m_bytes;}$/;"	f	class:tm_manager::access_record
global_iterator_begin	ptx_ir.h	/^   iterator global_iterator_begin() { return m_globals.begin();}$/;"	f	class:symbol_table
global_iterator_end	ptx_ir.h	/^   iterator global_iterator_end() { return m_globals.end();}$/;"	f	class:symbol_table
global_to_generic	cuda-sim.cc	/^addr_t global_to_generic( addr_t addr )$/;"	f
gmem_n_access_total	ptx-stats.cc	/^    unsigned long long gmem_n_access_total; \/\/ number of uncoalesced access in total from this instruction$/;"	m	class:ptx_file_line_stats	file:
gmem_warp_count	ptx-stats.cc	/^    unsigned long gmem_warp_count;          \/\/ number of warps causing these uncoalesced access$/;"	m	class:ptx_file_line_stats	file:
gpgpu_cuda_ptx_sim_main_func	cuda-sim.cc	/^void gpgpu_cuda_ptx_sim_main_func( kernel_info_t &kernel, bool openCL )$/;"	f
gpgpu_opencl_ptx_sim_init_grid	cuda-sim.cc	/^kernel_info_t *gpgpu_opencl_ptx_sim_init_grid(class function_info *entry,$/;"	f
gpgpu_param_num_shaders	cuda-sim.cc	/^unsigned gpgpu_param_num_shaders = 0;$/;"	v
gpgpu_ptx_assemble	ptx_ir.cc	/^void gpgpu_ptx_assemble( std::string kname, void *kinfo )$/;"	f
gpgpu_ptx_instruction_classification	cuda-sim.cc	/^int gpgpu_ptx_instruction_classification;$/;"	v
gpgpu_ptx_sim_bindNameToTexture	cuda-sim.cc	/^void gpgpu_t::gpgpu_ptx_sim_bindNameToTexture(const char* name, const struct textureReference* texref, int dim, int readmode, int ext)$/;"	f	class:gpgpu_t
gpgpu_ptx_sim_bindTextureToArray	cuda-sim.cc	/^void gpgpu_t::gpgpu_ptx_sim_bindTextureToArray(const struct textureReference* texref, const struct cudaArray* array)$/;"	f	class:gpgpu_t
gpgpu_ptx_sim_convert_ptx_and_sass_to_ptxplus	ptx_loader.cc	/^char* gpgpu_ptx_sim_convert_ptx_and_sass_to_ptxplus(const std::string ptxfilename, const std::string elffilename, const std::string sassfilename)$/;"	f
gpgpu_ptx_sim_findNamefromTexture	cuda-sim.cc	/^const char* gpgpu_t::gpgpu_ptx_sim_findNamefromTexture(const struct textureReference* texref)$/;"	f	class:gpgpu_t
gpgpu_ptx_sim_load_ptx_from_string	ptx_loader.cc	/^symbol_table *gpgpu_ptx_sim_load_ptx_from_string( const char *p, unsigned source_num )$/;"	f
gpgpu_ptx_sim_memcpy_symbol	cuda-sim.cc	/^void gpgpu_ptx_sim_memcpy_symbol(const char *hostVar, const void *src, size_t count, size_t offset, int to, gpgpu_t *gpu )$/;"	f
gpgpu_ptx_sim_register_const_variable	cuda-sim.cc	/^void gpgpu_ptx_sim_register_const_variable(void *hostVar, const char *deviceName, size_t size )$/;"	f
gpgpu_ptx_sim_register_global_variable	cuda-sim.cc	/^void gpgpu_ptx_sim_register_global_variable(void *hostVar, const char *deviceName, size_t size )$/;"	f
gpgpu_ptxinfo_load_from_string	ptx_loader.cc	/^void gpgpu_ptxinfo_load_from_string( const char *p_for_info, unsigned source_num )$/;"	f
gpgpu_recon_t	ptx_ir.h	/^struct gpgpu_recon_t {$/;"	s
gpgpusim_cuda_vprintf	cuda_device_printf.cc	/^void gpgpusim_cuda_vprintf(const ptx_instruction * pI, ptx_thread_info * thread, const function_info * target_func ) $/;"	f
gpu_malloc	cuda-sim.cc	/^void* gpgpu_t::gpu_malloc( size_t size )$/;"	f	class:gpgpu_t
gpu_mallocarray	cuda-sim.cc	/^void* gpgpu_t::gpu_mallocarray( size_t size )$/;"	f	class:gpgpu_t
gpu_memset	cuda-sim.cc	/^void gpgpu_t::gpu_memset( size_t dst_start_addr, int c, size_t count )$/;"	f	class:gpgpu_t
gskew_hash	hashfunc.h	/^   gskew_hash(unsigned int size)$/;"	f	class:hasht_funct::gskew_hash
gskew_hash	hashfunc.h	/^class gskew_hash$/;"	c	namespace:hasht_funct
gskew_hash1	hashfunc.h	/^inline unsigned int gskew_hash1(unsigned int size, addr_t addr)$/;"	f
gskew_hash2	hashfunc.h	/^inline unsigned int gskew_hash2(unsigned int size, addr_t addr)$/;"	f
gskew_hash3	hashfunc.h	/^inline unsigned int gskew_hash3(unsigned int size, addr_t addr)$/;"	f
gskew_hash4	hashfunc.h	/^inline unsigned int gskew_hash4(unsigned int size, addr_t addr)$/;"	f
h3_hash	hashfunc.h	/^   h3_hash(unsigned int size, unsigned int seed)$/;"	f	class:hasht_funct::h3_hash
h3_hash	hashfunc.h	/^class h3_hash$/;"	c	namespace:hasht_funct
h3_hash1	hashfunc.cc	/^unsigned int h3_hash1(unsigned int size, addr_t addr) { return g_h3_1[size]->hash(size, addr); }$/;"	f
h3_hash2	hashfunc.cc	/^unsigned int h3_hash2(unsigned int size, addr_t addr) { return g_h3_2[size]->hash(size, addr); }$/;"	f
h3_hash3	hashfunc.cc	/^unsigned int h3_hash3(unsigned int size, addr_t addr) { return g_h3_3[size]->hash(size, addr); }$/;"	f
h3_hash4	hashfunc.cc	/^unsigned int h3_hash4(unsigned int size, addr_t addr) { return g_h3_4[size]->hash(size, addr); }$/;"	f
has_conflict_with	tm_manager.cc	/^bool logical_timestamp_based_tm_manager::has_conflict_with( tm_manager_inf * other_tx ) $/;"	f	class:logical_timestamp_based_tm_manager
has_conflict_with	tm_manager.cc	/^bool value_based_tm_manager::has_conflict_with( tm_manager_inf * other_tx ) $/;"	f	class:value_based_tm_manager
has_conflict_with	tm_manager_internal.h	/^   virtual bool has_conflict_with( tm_manager_inf * other_tx ) {$/;"	f	class:tm_manager
has_initializer	ptx_ir.h	/^   bool has_initializer() const $/;"	f	class:symbol
has_logical_tm_callback	ptx_sim.h	/^   bool has_logical_tm_callback() const { return m_last_logical_tm_dram_callback.function != NULL; }$/;"	f	class:ptx_thread_info
has_memory_read	ptx_ir.h	/^   bool has_memory_read() const {$/;"	f	class:ptx_instruction
has_memory_write	ptx_ir.h	/^   bool has_memory_write() const {$/;"	f	class:ptx_instruction
has_pred	ptx_ir.h	/^   bool has_pred() const { return m_pred != NULL;}$/;"	f	class:ptx_instruction
has_return	ptx_ir.h	/^   bool has_return() const$/;"	f	class:function_info
has_return	ptx_ir.h	/^   bool has_return() const$/;"	f	class:ptx_instruction
hash	bloomfilter.h	/^   unsigned int hash(addr_t addr) const { return m_hash_funct_ptr(m_size, addr); } $/;"	f	class:hashtable
hash	bloomfilter.h	/^   unsigned int hash(addr_t addr) const { return m_hash_funct_ptr(m_size, addr); } $/;"	f	class:versioning_hashtable
hash	hashfunc.h	/^   unsigned int hash(unsigned int size, addr_t addr)$/;"	f	class:hasht_funct::gskew_hash
hash	hashfunc.h	/^   unsigned int hash(unsigned int size, addr_t addr)$/;"	f	class:hasht_funct::h3_hash
hash_funct_ptr	bloomfilter.h	/^typedef unsigned int (*hash_funct_ptr)(unsigned int size, addr_t addr); $/;"	t
hash_ptx_file_line	ptx-stats.cc	/^struct hash_ptx_file_line$/;"	s	file:
hashed_threadsig_populated	bloomfilter.cc	/^bool hashtable_bits_mt::hashed_threadsig_populated(const hashed_tvec_t& combined_sig) const$/;"	f	class:hashtable_bits_mt
hashed_tvec_t	bloomfilter.h	/^   typedef std::bitset<s_tid_hash_limit> hashed_tvec_t; $/;"	t	class:hashtable_bits_mt
hasht_funct	hashfunc.h	/^namespace hasht_funct {$/;"	n
hashtable	bloomfilter.cc	/^hashtable::hashtable(unsigned int size, int funct_id)$/;"	f	class:hashtable
hashtable	bloomfilter.h	/^class hashtable$/;"	c
hashtable_bits	bloomfilter.cc	/^hashtable_bits<sig_limit>::hashtable_bits(unsigned int size, int funct_id)$/;"	f	class:hashtable_bits
hashtable_bits	bloomfilter.h	/^class hashtable_bits : public hashtable$/;"	c
hashtable_bits_mt	bloomfilter.cc	/^hashtable_bits_mt::hashtable_bits_mt(unsigned int size, int funct_id, unsigned int nthreads, unsigned int tid_hashsize)$/;"	f	class:hashtable_bits_mt
hashtable_bits_mt	bloomfilter.h	/^class hashtable_bits_mt : public hashtable$/;"	c
hashtable_counter	bloomfilter.cc	/^hashtable_counter::hashtable_counter(unsigned int size, int funct_id)$/;"	f	class:hashtable_counter
hashtable_counter	bloomfilter.h	/^class hashtable_counter : public hashtable_bits<htctr_sig_limit>$/;"	c
hashtables_array	bloomfilter.h	/^   typedef std::vector<hashtable*> hashtables_array; $/;"	t	class:bloomfilter
hashtables_array	bloomfilter.h	/^   typedef std::vector<hashtable_bits_mt*> hashtables_array; $/;"	t	class:bloomfilter_mt
hashtables_array	bloomfilter.h	/^   typedef std::vector<versioning_hashtable*> hashtables_array; $/;"	t	class:versioning_bloomfilter
high	ptx_sim.h	/^       unsigned int high;$/;"	m	struct:ptx_reg_t::__anon5
highest	ptx_sim.h	/^       unsigned int highest;$/;"	m	struct:ptx_reg_t::__anon5
htctr_sig_limit	bloomfilter.h	98;"	d
identifier_list	ptx.y	/^identifier_list: identifier_spec$/;"	l
identifier_spec	ptx.y	/^identifier_spec: IDENTIFIER { add_identifier($1,0,NON_ARRAY_IDENTIFIER); func_header_info($1);}$/;"	l
immediatedominator_id	ptx_ir.h	/^   int immediatedominator_id;$/;"	m	struct:basic_block_t
immediatepostdominator_id	ptx_ir.h	/^   int immediatepostdominator_id;$/;"	m	struct:basic_block_t
inc_concurrency	tm_manager_internal.h	/^    void inc_concurrency() {$/;"	f	class:tm_global_statistics
inc_num_writing_threads	tm_manager.cc	/^void logical_temporal_conflict_detector::inc_num_writing_threads(addr_t addr, unsigned int num) {$/;"	f	class:logical_temporal_conflict_detector
inc_ref_count	tm_manager.cc	/^int tm_manager_inf::inc_ref_count() { m_ref_count++; return m_ref_count; }$/;"	f	class:tm_manager_inf
inc_warp_pts	tm_manager_internal.h	/^   void inc_warp_pts(unsigned index) {$/;"	f	class:logical_temporal_conflict_detector
index	tm_manager_internal.h	/^      unsigned index;$/;"	m	class:logical_timestamp_based_tm_manager::logical_temporal_cd_metadata
inflight_mem_tracker	ptx-stats.cc	/^static ptx_inflight_memory_insn_tracker *inflight_mem_tracker = NULL;$/;"	v	file:
info	ptxinfo.y	/^info: 	  USED INT_OPERAND REGS { ptxinfo_regs($2); }$/;"	l
init	ptx_ir.h	/^   void init()$/;"	f	class:operand_info
init	ptx_sim.h	/^   void init(gpgpu_t *gpu, core_t *core, unsigned sid, unsigned cta_id, unsigned wid, unsigned tid, bool fsim) $/;"	f	class:ptx_thread_info
init	tm_manager.cc	/^void tm_bloomfilter_options::init()$/;"	f	class:tm_bloomfilter_options
init	tm_manager_internal.h	/^      void init() {$/;"	f	class:logical_timestamp_based_tm_manager::logical_temporal_cd_metadata
init_aborted_tx_pts	tm_manager_internal.h	/^   virtual void init_aborted_tx_pts() { assert(0); }$/;"	f	class:ring_tm_manager
init_aborted_tx_pts	tm_manager_internal.h	/^   virtual void init_aborted_tx_pts() { assert(0); }$/;"	f	class:tm_manager
init_aborted_tx_pts	tm_manager_internal.h	/^   virtual void init_aborted_tx_pts() { assert(0); }$/;"	f	class:value_based_tm_manager
init_aborted_tx_pts	tm_manager_internal.h	/^   virtual void init_aborted_tx_pts() { m_logical_temporal_cd_metadata.init(); }$/;"	f	class:logical_timestamp_based_tm_manager
init_directive_state	ptx_parser.cc	/^void init_directive_state()$/;"	f
init_h3_hash	hashfunc.cc	/^void init_h3_hash(unsigned int size)$/;"	f
init_inst_classification_stat	cuda-sim.cc	/^void init_inst_classification_stat() $/;"	f
init_instruction_state	ptx_parser.cc	/^void init_instruction_state()$/;"	f
init_parser	ptx_parser.cc	/^symbol_table *init_parser( const char *ptx_filename )$/;"	f
initializeCTA	cuda-sim.cc	/^void functionalCoreSim::initializeCTA()$/;"	f	class:functionalCoreSim
initializer_list	ptx.y	/^initializer_list: LEFT_BRACE literal_list RIGHT_BRACE { add_array_initializer(); } $/;"	l
input	ptx.y	/^input:	\/* empty *\/$/;"	l
input	ptxinfo.y	/^input:	\/* empty *\/$/;"	l
insert_match_clear_test	bloomfilter.cc	/^bool insert_match_clear_test(unsigned int size, const std::vector<int>& funct_ids, bool counter_based)$/;"	f
insert_match_clear_test	bloomfilter.cc	/^bool insert_match_clear_test(unsigned int size, int funct_id)$/;"	f
insn_count_map	ptx-stats.cc	/^    typedef std::map<const ptx_instruction *, int> insn_count_map;$/;"	t	class:ptx_inflight_memory_insn_tracker	file:
inst_not_implemented	instructions.cc	/^void inst_not_implemented( const ptx_instruction * pI ) $/;"	f
inst_size	ptx_ir.h	/^   unsigned inst_size() const { return m_inst_size; }$/;"	f	class:ptx_instruction
instruction	ptx.y	/^instruction: opcode_spec LEFT_PAREN operand RIGHT_PAREN { set_return(); } COMMA operand COMMA LEFT_PAREN operand_list RIGHT_PAREN$/;"	l
instruction_statement	ptx.y	/^instruction_statement:  instruction SEMI_COLON$/;"	l
int4	cuda-math.h	/^   struct int4 {$/;"	s	namespace:cuda_math
int4	cuda-math.h	/^   typedef struct int4 int4;$/;"	t	namespace:cuda_math	typeref:struct:cuda_math::int4
intLOGB2	cuda-sim.cc	/^unsigned int intLOGB2( unsigned int v ) {$/;"	f
int_t	ptx_ir.h	/^   reg_t, vector_t, builtin_t, address_t, memory_t, float_op_t, double_op_t, int_t, $/;"	e	enum:operand_type
integer_rounding_mode	ptx.y	/^integer_rounding_mode: RNI_OPTION { add_option(RNI_OPTION); } $/;"	l
intersect	ptx_ir.cc	/^void intersect( std::set<int> &A, const std::set<int> &B )$/;"	f
intfloat	instructions.cc	/^union intfloat {$/;"	u	file:
isFloat	instructions.cc	/^bool isFloat(int type) $/;"	f
isInFunctionalSimulationMode	ptx_sim.h	/^   bool isInFunctionalSimulationMode(){ return m_functionalSimulationMode;}$/;"	f	class:ptx_thread_info
isNaN	instructions.cc	/^bool isNaN(double x)$/;"	f
isNaN	instructions.cc	/^bool isNaN(float x)$/;"	f
is_abs	ptx_ir.h	/^   bool is_abs() const { return m_abs;}$/;"	f	class:ptx_instruction
is_builtin	ptx_ir.h	/^   bool is_builtin() const { return m_type == builtin_t;}$/;"	f	class:operand_info
is_const	ptx_ir.h	/^   bool is_const() const { return m_is_const;}$/;"	f	class:symbol
is_const	ptx_ir.h	/^   bool is_const() const { return m_space_spec.get_type() == const_space;}$/;"	f	class:type_info_key
is_const	ptx_ir.h	/^   bool is_const() const { return m_value.m_symbolic->is_const();}$/;"	f	class:operand_info
is_done	ptx_sim.h	/^   bool is_done() { return m_thread_done;}$/;"	f	class:ptx_thread_info
is_entry	ptx_ir.h	/^   bool is_entry;$/;"	m	struct:basic_block_t
is_entry_point	ptx_ir.h	/^   bool is_entry_point() const { return m_entry_point; }$/;"	f	class:function_info
is_equal	ptx_ir.cc	/^bool is_equal( const std::set<int> &A, const std::set<int> &B )$/;"	f
is_exit	ptx_ir.h	/^   bool is_exit() const { return m_exit;}$/;"	f	class:ptx_instruction
is_exit	ptx_ir.h	/^   bool is_exit;$/;"	m	struct:basic_block_t
is_extern	ptx_ir.h	/^   bool is_extern() const { return m_extern; }$/;"	f	class:function_info
is_func_addr	ptx_ir.h	/^   bool is_func_addr() const { return m_is_func_addr; }$/;"	f	class:symbol
is_func_addr	ptx_ir.h	/^   bool is_func_addr() const { return m_is_function?true:false; }$/;"	f	class:type_info_key
is_function_address	ptx_ir.h	/^   bool is_function_address() const$/;"	f	class:operand_info
is_global	ptx_ir.h	/^   bool is_global() const { return m_is_global;}$/;"	f	class:symbol
is_global	ptx_ir.h	/^   bool is_global() const { return m_space_spec == global_space;}$/;"	f	class:type_info_key
is_global	ptx_ir.h	/^   bool is_global() const { return m_value.m_symbolic->is_global();}$/;"	f	class:operand_info
is_hi	ptx_ir.h	/^   bool is_hi() const { return m_hi;}$/;"	f	class:ptx_instruction
is_immediate_address	ptx_ir.h	/^   bool is_immediate_address() const {$/;"	f	class:operand_info
is_in_transaction	ptx_sim.h	/^    tm_manager_inf* is_in_transaction() { return m_tm_manager; }$/;"	f	class:ptx_thread_info
is_label	ptx_ir.h	/^   bool is_label() const { if(m_label){ assert(m_opcode==-1);return true;} return false;}$/;"	f	class:ptx_instruction
is_label	ptx_ir.h	/^   bool is_label() const { return m_is_label;}$/;"	f	class:symbol
is_label	ptx_ir.h	/^   bool is_label() const { return m_type == label_t;}$/;"	f	class:operand_info
is_literal	ptx_ir.h	/^   bool is_literal() const { return m_type == int_t ||$/;"	f	class:operand_info
is_lo	ptx_ir.h	/^   bool is_lo() const { return m_lo;}$/;"	f	class:ptx_instruction
is_local	ptx_ir.h	/^   bool is_local() const { return m_is_local;}$/;"	f	class:symbol
is_local	ptx_ir.h	/^   bool is_local() const { return m_space_spec == local_space;}$/;"	f	class:type_info_key
is_local	ptx_ir.h	/^   bool is_local() const { return m_value.m_symbolic->is_local();}$/;"	f	class:operand_info
is_local_memory_space	ptx_sim.h	/^   bool is_local_memory_space(const memory_space *mem_space) const { return (mem_space == m_local_mem); }$/;"	f	class:ptx_thread_info
is_memory_operand	ptx_ir.h	/^   bool is_memory_operand() const { return m_type == memory_t;}$/;"	f	class:operand_info
is_memory_operand2	ptx_ir.h	/^   bool is_memory_operand2() const { $/;"	f	class:operand_info
is_neg	ptx_ir.h	/^   bool is_neg() const { return m_neg;}$/;"	f	class:ptx_instruction
is_neg_pred	ptx_ir.h	/^   bool is_neg_pred() const { return m_neg_pred; }$/;"	f	class:operand_info
is_non_arch_reg	ptx_ir.h	/^   bool is_non_arch_reg() const { return m_is_non_arch_reg; }$/;"	f	class:operand_info
is_non_arch_reg	ptx_ir.h	/^   bool is_non_arch_reg() const { return m_is_non_arch_reg; }$/;"	f	class:type_info_key
is_non_arch_reg	ptx_ir.h	/^   bool is_non_arch_reg() const$/;"	f	class:symbol
is_param	ptx_ir.h	/^   bool is_param() const { return m_is_param; }$/;"	f	class:arg_buffer_t
is_param_kernel	ptx_ir.h	/^   bool is_param_kernel() const { return m_space_spec == param_space_kernel;}$/;"	f	class:type_info_key
is_param_local	ptx_ir.h	/^   bool is_param_local() const { return m_is_param_local; }$/;"	f	class:symbol
is_param_local	ptx_ir.h	/^   bool is_param_local() const { return m_space_spec == param_space_local; }$/;"	f	class:type_info_key
is_param_local	ptx_ir.h	/^   bool is_param_local() const$/;"	f	class:operand_info
is_param_unclassified	ptx_ir.h	/^   bool is_param_unclassified() const { return m_space_spec == param_space_unclassified; }$/;"	f	class:type_info_key
is_ptr_shared	ptx_ir.h	/^   bool is_ptr_shared() const { assert(m_valid); return (m_is_ptr and m_ptr_space == shared_space); }$/;"	f	class:param_info
is_reg	ptx_ir.h	/^   bool is_reg() const { return m_is_reg; }$/;"	f	class:arg_buffer_t
is_reg	ptx_ir.h	/^   bool is_reg() const { return m_space_spec == reg_space;} $/;"	f	class:type_info_key
is_reg	ptx_ir.h	/^   bool is_reg() const$/;"	f	class:operand_info
is_reg	ptx_ir.h	/^   bool is_reg() const$/;"	f	class:symbol
is_return_var	ptx_ir.h	/^   bool is_return_var() const { return m_is_return_var; }$/;"	f	class:operand_info
is_shared	ptx_ir.h	/^   bool is_shared() const { return m_is_shared;}$/;"	f	class:symbol
is_shared	ptx_ir.h	/^   bool is_shared() const { return m_space_spec == shared_space;}$/;"	f	class:type_info_key
is_shared	ptx_ir.h	/^   bool is_shared() const {$/;"	f	class:operand_info
is_shared_memory_space	ptx_sim.h	/^   bool is_shared_memory_space(const memory_space *mem_space) const { return (mem_space == m_shared_mem); }$/;"	f	class:ptx_thread_info
is_tex	ptx_ir.h	/^   bool is_tex() const { return m_is_tex;}$/;"	f	class:symbol
is_tex	ptx_ir.h	/^   bool is_tex() const { return m_space_spec == tex_space;}$/;"	f	class:type_info_key
is_tex	ptx_ir.h	/^   bool is_tex() const { return m_value.m_symbolic->is_tex();}$/;"	f	class:operand_info
is_to	ptx_ir.h	/^   bool is_to() const { return m_to_option; }$/;"	f	class:ptx_instruction
is_underscore	ptx_ir.h	/^   bool is_underscore() const { return (m_name == "_"); } \/\/ for a null dst reg in call return $/;"	f	class:symbol
is_uni	ptx_ir.h	/^   bool is_uni() const { return m_uni;}$/;"	f	class:ptx_instruction
is_valid	ptx_ir.h	/^   bool is_valid() const { return m_valid; }$/;"	f	class:operand_info
is_vector	ptx_ir.h	/^   bool is_vector() const$/;"	f	class:operand_info
is_wide	ptx_ir.h	/^   bool is_wide() const { return m_wide;}$/;"	f	class:ptx_instruction
isnanf	cuda-math.h	/^int isnanf(float a) $/;"	f
isspace_global	cuda-sim.cc	/^bool isspace_global( addr_t addr )$/;"	f
isspace_local	cuda-sim.cc	/^bool isspace_local( unsigned smid, unsigned hwtid, addr_t addr )$/;"	f
isspace_shared	cuda-sim.cc	/^bool isspace_shared( unsigned smid, addr_t addr )$/;"	f
isspacep_impl	instructions.cc	/^void isspacep_impl( const ptx_instruction *pI, ptx_thread_info *thread ) $/;"	f
iterator	ptx_ir.h	/^   typedef std::list<symbol*>::iterator iterator;$/;"	t	class:symbol_table
keep_intermediate_files	ptx_loader.cc	/^bool keep_intermediate_files() {return g_keep_intermediate_files;}$/;"	f
label_t	ptx_ir.h	/^   unsigned_t, symbolic_t, label_t, v_reg_t, v_float_op_t, v_double_op_t,$/;"	e	enum:operand_type
labels	ptx_ir.h	/^   std::map<std::string,unsigned> labels;$/;"	m	class:function_info
largest_pts	tm_manager_internal.h	/^   tm_timestamp_t largest_pts;$/;"	m	class:logical_temporal_conflict_detector
last_callback	ptx_sim.h	/^   dram_callback_t last_callback() const { return m_last_dram_callback;}$/;"	f	class:ptx_thread_info
last_eaddr	ptx_sim.h	/^   addr_t last_eaddr() const { return m_last_effective_address;}$/;"	f	class:ptx_thread_info
last_logical_tm_callback	ptx_sim.h	/^   logical_tm_dram_callback_t last_logical_tm_callback() const { return m_last_logical_tm_dram_callback;}$/;"	f	class:ptx_thread_info
last_space	ptx_sim.h	/^   memory_space_t last_space() const { return m_last_memory_space;}$/;"	f	class:ptx_thread_info
last_was_call	ptx_sim.h	/^   bool last_was_call() const { return m_last_was_call; }$/;"	f	class:ptx_thread_info
last_writer_info	tm_manager.cc	/^   last_writer_info() $/;"	f	struct:last_writer_info
last_writer_info	tm_manager.cc	/^   last_writer_info(unsigned thread_uid, unsigned sc, unsigned hwtid, unsigned long long time) $/;"	f	struct:last_writer_info
last_writer_info	tm_manager.cc	/^struct last_writer_info {$/;"	s	file:
last_written_time_t	tm_manager_internal.h	/^   typedef std::unordered_map<addr_t, tm_timestamp_t> last_written_time_t; $/;"	t	class:temporal_conflict_detector
latency	ptx-stats.cc	/^    unsigned long long latency;$/;"	m	class:ptx_file_line_stats	file:
latest_read_logical_time_t	tm_manager_internal.h	/^   typedef std::unordered_map<addr_t, tm_logical_timestamp_t> latest_read_logical_time_t; $/;"	t	class:logical_temporal_conflict_detector
latest_written_logical_time_t	tm_manager_internal.h	/^   typedef std::unordered_map<addr_t, tm_logical_timestamp_t> latest_written_logical_time_t; $/;"	t	class:logical_temporal_conflict_detector
lazy_conflict_detection	tm_manager.cc	/^tuid_set_t tm_global_state::lazy_conflict_detection( const addr_set_t& write_set )$/;"	f	class:tm_global_state
ld_exec	instructions.cc	/^void ld_exec( const ptx_instruction *pI, ptx_thread_info *thread ) $/;"	f
ld_impl	instructions.cc	/^void ld_impl( const ptx_instruction *pI, ptx_thread_info *thread ) $/;"	f
ldu_impl	instructions.cc	/^void ldu_impl( const ptx_instruction *pI, ptx_thread_info *thread ) $/;"	f
lg2_impl	instructions.cc	/^void lg2_impl( const ptx_instruction *pI, ptx_thread_info *thread ) $/;"	f
line	ptx-stats.cc	/^    unsigned line;$/;"	m	class:ptx_file_line	file:
line	ptxinfo.y	/^line: 	HEADER INFO COLON line_info$/;"	l
line_info	ptxinfo.y	/^line_info: function_name$/;"	l
list_param	cuda-sim.cc	/^void function_info::list_param( FILE *fout ) const$/;"	f	class:function_info
literal_list	ptx.y	/^literal_list: literal_operand$/;"	l
literal_operand	ptx.y	/^literal_operand : INT_OPERAND { add_literal_int($1); }$/;"	l
local_mem_framesize	ptx_ir.h	/^   unsigned local_mem_framesize() const $/;"	f	class:function_info
local_to_generic	cuda-sim.cc	/^addr_t local_to_generic( unsigned smid, unsigned hwtid, addr_t addr )$/;"	f
logical_temporal_cd_metadata	tm_manager_internal.h	/^      logical_temporal_cd_metadata() { }$/;"	f	class:logical_timestamp_based_tm_manager::logical_temporal_cd_metadata
logical_temporal_cd_metadata	tm_manager_internal.h	/^   class logical_temporal_cd_metadata {$/;"	c	class:logical_timestamp_based_tm_manager
logical_temporal_conflict_detector	tm_manager.cc	/^logical_temporal_conflict_detector::logical_temporal_conflict_detector() $/;"	f	class:logical_temporal_conflict_detector
logical_temporal_conflict_detector	tm_manager_internal.h	/^class logical_temporal_conflict_detector$/;"	c
logical_timestamp_based_tm_manager	tm_manager.cc	/^logical_timestamp_based_tm_manager::logical_timestamp_based_tm_manager( ptx_thread_info *thread, bool timing_mode )$/;"	f	class:logical_timestamp_based_tm_manager
logical_timestamp_based_tm_manager	tm_manager_internal.h	/^class logical_timestamp_based_tm_manager : public tm_manager {$/;"	c
logical_tx_aborted	tm_manager_internal.h	/^   virtual bool logical_tx_aborted() { return false; }$/;"	f	class:ring_tm_manager
logical_tx_aborted	tm_manager_internal.h	/^   virtual bool logical_tx_aborted() { return false; }$/;"	f	class:tm_manager
logical_tx_aborted	tm_manager_internal.h	/^   virtual bool logical_tx_aborted() { return false; }$/;"	f	class:value_based_tm_manager
logical_tx_aborted	tm_manager_internal.h	/^   virtual bool logical_tx_aborted() { return m_logical_temporal_cd_metadata.conflict_exist(); }$/;"	f	class:logical_timestamp_based_tm_manager
lookup	ptx_ir.cc	/^symbol *symbol_table::lookup( const char *identifier ) $/;"	f	class:symbol_table
lookup_tuid	tm_manager.cc	/^ptx_thread_info *tm_global_state::lookup_tuid(unsigned tuid)$/;"	f	class:tm_global_state
low	ptx_sim.h	/^       unsigned int low;$/;"	m	struct:ptx_reg_t::__anon5
lowest	ptx_sim.h	/^       unsigned int lowest;$/;"	m	struct:ptx_reg_t::__anon5
ls	ptx_sim.h	/^      unsigned ls;$/;"	m	struct:ptx_reg_t::__anon4
m_NPC	ptx_sim.h	/^   unsigned m_NPC;$/;"	m	class:ptx_thread_info
m_PC	ptx_ir.h	/^   addr_t            m_PC;$/;"	m	class:ptx_instruction
m_PC	ptx_sim.h	/^   unsigned       m_PC;$/;"	m	struct:stack_entry
m_PC	ptx_sim.h	/^   unsigned m_PC;$/;"	m	class:ptx_thread_info
m_RPC	ptx_sim.h	/^   unsigned       m_RPC;$/;"	m	struct:stack_entry
m_RPC	ptx_sim.h	/^   unsigned m_RPC;$/;"	m	class:ptx_thread_info
m_RPC_updated	ptx_sim.h	/^   bool m_RPC_updated;$/;"	m	class:ptx_thread_info
m_abort	tm_manager_internal.h	/^   	int m_abort; \/\/ 1 = transaction was aborted$/;"	m	class:tm_manager::trans_stats
m_abort_count	tm_manager.h	/^   unsigned m_abort_count; $/;"	m	class:tm_manager_inf
m_abort_profile	tm_manager_internal.h	/^    tr1_hash_map<addr_t, unsigned int> m_abort_profile; $/;"	m	class:tm_global_statistics
m_abort_profile	tm_manager_internal.h	/^   bool m_abort_profile; $/;"	m	class:tm_options
m_aborts_per_transaction	tm_manager_internal.h	/^    pow2_histogram m_aborts_per_transaction; $/;"	m	class:tm_global_statistics
m_abs	ptx_ir.h	/^   bool                m_abs;$/;"	m	class:ptx_instruction
m_access_block_set	tm_manager_internal.h	/^   addr_set_t m_access_block_set; \/\/ both read and write $/;"	m	class:tm_manager
m_access_block_size	tm_manager_internal.h	/^   unsigned m_access_block_size; $/;"	m	class:tm_options
m_access_block_size_log2	tm_manager_internal.h	/^   unsigned m_access_block_size_log2; $/;"	m	class:tm_options
m_access_log	tm_manager_internal.h	/^   std::list<access_record> m_access_log;$/;"	m	class:tm_manager
m_access_log_name	tm_manager_internal.h	/^   char *m_access_log_name; \/\/ name of the access log file $/;"	m	class:tm_options
m_access_set	tm_manager_internal.h	/^   bloomfilter m_access_set; \/\/ read + write $/;"	m	class:tm_bloomfilter_set
m_access_set_mt	tm_manager_internal.h	/^   bloomfilter_mt m_access_set_mt; \/\/ read + write $/;"	m	class:tm_bloomfilter_hashed_core_set
m_access_word_set	tm_manager_internal.h	/^   addr_set_t m_access_word_set; \/\/ both read and write $/;"	m	class:tm_manager
m_addr	tm_manager_internal.h	/^	addr_t 		m_addr;$/;"	m	class:tm_manager::access_record
m_addr_offset	ptx_ir.h	/^   int m_addr_offset;$/;"	m	class:operand_info
m_addr_space	ptx_ir.h	/^   enum _memory_space_t m_addr_space;$/;"	m	class:operand_info	typeref:enum:operand_info::_memory_space_t
m_address	ptx_ir.h	/^   unsigned m_address;$/;"	m	class:symbol
m_address_valid	ptx_ir.h	/^   bool m_address_valid;$/;"	m	class:symbol
m_alignment_spec	ptx_ir.h	/^   int m_alignment_spec;$/;"	m	class:type_info_key
m_arch_reg_num	ptx_ir.h	/^   unsigned m_arch_reg_num; $/;"	m	class:symbol
m_args	ptx_ir.h	/^   std::vector<const symbol*> m_args;$/;"	m	class:function_info
m_array_dim	ptx_ir.h	/^   int m_array_dim;$/;"	m	class:type_info_key
m_assembled	ptx_ir.h	/^   bool m_assembled;$/;"	m	class:function_info
m_at_barrier	ptx_sim.h	/^   bool m_at_barrier;$/;"	m	class:ptx_thread_info
m_atomic_spec	ptx_ir.h	/^   int m_atomic_spec;$/;"	m	class:ptx_instruction
m_back_edges	ptx_ir.h	/^   std::list<std::pair<unsigned, unsigned> > m_back_edges;$/;"	m	class:function_info
m_barrier_num	ptx_sim.h	/^   int m_barrier_num;$/;"	m	class:ptx_thread_info
m_base_index	tm_manager_internal.h	/^   int m_base_index; $/;"	m	class:tm_ring_compressed_record
m_basic_block	ptx_ir.h	/^   basic_block_t        *m_basic_block;$/;"	m	class:ptx_instruction
m_basic_blocks	ptx_ir.h	/^   std::vector<basic_block_t*> m_basic_blocks;$/;"	m	class:function_info
m_bfaccess	tm_manager_internal.h	/^	bloomfilter_access_set_t m_bfaccess;$/;"	m	class:tm_global_state
m_bfcore	tm_manager_internal.h	/^   core_bloomfilter_t m_bfcore; $/;"	m	class:tm_global_state
m_bfcorehash	tm_manager_internal.h	/^   core_hash_bloomfilter_t m_bfcorehash; $/;"	m	class:tm_global_state
m_branch_taken	ptx_sim.h	/^   bool        m_branch_taken;$/;"	m	class:ptx_thread_info
m_breakaddrs	ptx_sim.h	/^   std::stack<class operand_info> m_breakaddrs;$/;"	m	class:ptx_thread_info
m_buffered_write_word_set	tm_manager_internal.h	/^   addr_set_t m_buffered_write_word_set; $/;"	m	class:tm_manager
m_bytes	tm_manager_internal.h	/^	void *		m_bytes;$/;"	m	class:tm_manager::access_record
m_cache_lines_accessed	tm_manager_internal.h	/^   	tm_stats_set m_cache_lines_accessed;$/;"	m	class:tm_manager::trans_stats
m_cache_option	ptx_ir.h	/^   unsigned            m_cache_option;$/;"	m	class:ptx_instruction
m_call_uid	ptx_sim.h	/^   unsigned       m_call_uid;$/;"	m	struct:stack_entry
m_callstack	ptx_sim.h	/^   std::vector<stack_entry> m_callstack;$/;"	m	class:ptx_thread_info
m_check_bloomfilter_correctness	tm_manager_internal.h	/^   bool m_check_bloomfilter_correctness; $/;"	m	class:tm_options
m_cleared_set	tm_manager_internal.h	/^   addr_set_t m_cleared_set;$/;"	m	class:logical_timestamp_based_tm_manager
m_commit_rec_actual_conflict_distance	tm_manager_internal.h	/^   pow2_histogram m_commit_rec_actual_conflict_distance; \/\/ the actual commit record that hit (in distance from ring_index)$/;"	m	class:tm_ring_stats
m_commit_rec_dist_conflict	tm_manager_internal.h	/^   pow2_histogram m_commit_rec_dist_conflict; \/\/ #record checked with a conflict hit $/;"	m	class:tm_ring_stats
m_commit_rec_dist_no_conflict	tm_manager_internal.h	/^   pow2_histogram m_commit_rec_dist_no_conflict; \/\/ #record checked with a conflict miss$/;"	m	class:tm_ring_stats
m_commit_rec_distance	tm_manager_internal.h	/^   pow2_histogram m_commit_rec_distance; \/\/ #record checked at each conflict checking $/;"	m	class:tm_ring_stats
m_committed_set	tm_manager_internal.h	/^   addr_set_t m_committed_set;$/;"	m	class:logical_timestamp_based_tm_manager
m_committed_set	tm_manager_internal.h	/^   addr_set_t m_committed_set;$/;"	m	class:value_based_tm_manager
m_compare_op	ptx_ir.h	/^   unsigned            m_compare_op;$/;"	m	class:ptx_instruction
m_compressed_ring	tm_manager_internal.h	/^   compressed_ring_t m_compressed_ring; $/;"	m	class:tm_ring_global
m_compressed_ring_capacity	tm_manager_internal.h	/^   int m_compressed_ring_capacity; \/\/ what each compressed ring structure appears to hold $/;"	m	class:tm_options
m_compressed_ring_size	tm_manager_internal.h	/^   int m_compressed_ring_size; \/\/ what it is really storing $/;"	m	class:tm_options
m_compressed_size	tm_manager_internal.h	/^   unsigned int m_compressed_size; $/;"	m	class:tm_ring_compressed_record
m_concurrency	tm_manager_internal.h	/^    unsigned m_concurrency;$/;"	m	class:tm_global_statistics
m_conflict_footprint	tm_manager_internal.h	/^    pow2_histogram m_conflict_footprint; $/;"	m	class:tm_global_statistics
m_conflict_footprint	tm_manager_internal.h	/^   int m_conflict_footprint; $/;"	m	class:tm_global_state
m_conflict_tuids	tm_manager_internal.h	/^   tuid_set_t m_conflict_tuids;$/;"	m	class:tm_manager
m_const_mem_offset	ptx_ir.h	/^   addr_t m_const_mem_offset;$/;"	m	class:operand_info
m_const_next	ptx_ir.h	/^   unsigned m_const_next;$/;"	m	class:symbol_table
m_consts	ptx_ir.h	/^   std::list<symbol*> m_consts;$/;"	m	class:symbol_table
m_core	ptx_sim.h	/^   core_t *m_core;$/;"	m	class:ptx_thread_info
m_core_bf	tm_manager_internal.h	/^   tm_bloomfilter_core_set* m_core_bf; $/;"	m	class:tm_bloomfilter_set
m_core_id	tm_manager_internal.h	/^   int m_core_id; $/;"	m	class:tm_bloomfilter_hashed_core_set
m_core_id	tm_manager_internal.h	/^   int m_core_id; $/;"	m	class:tm_bloomfilter_set
m_counter_based	bloomfilter.h	/^   bool m_counter_based; $/;"	m	class:bloomfilter
m_countertable	bloomfilter.h	/^   countertable_t m_countertable; \/\/ array of counters tracking the set $/;"	m	class:hashtable_counter
m_cta_info	ptx_sim.h	/^   ptx_cta_info   *m_cta_info;$/;"	m	class:ptx_thread_info
m_ctaid	ptx_sim.h	/^   dim3   m_ctaid;$/;"	m	class:ptx_thread_info
m_current_pts	tm_manager_internal.h	/^      tm_timestamp_t m_current_pts;          \/\/ the lastest pts, some memory requests may advance Tx pts$/;"	m	class:logical_timestamp_based_tm_manager::logical_temporal_cd_metadata
m_cycle_done	ptx_sim.h	/^   unsigned m_cycle_done;$/;"	m	class:ptx_thread_info
m_dangling_pointers	ptx_sim.h	/^   std::set<ptx_thread_info*>  m_dangling_pointers;$/;"	m	class:ptx_cta_info
m_data	memory.h	/^   map_t m_data;$/;"	m	class:memory_space_impl
m_data	memory.h	/^   unsigned char *m_data;$/;"	m	class:mem_storage
m_data	tm_manager_internal.h	/^      std::vector<unsigned char> m_data;$/;"	m	struct:tm_manager::tm_mem_bucket
m_debug_trace_regs_modified	ptx_sim.h	/^   std::list<reg_map_t> m_debug_trace_regs_modified;$/;"	m	class:ptx_thread_info
m_debug_trace_regs_read	ptx_sim.h	/^   std::list<reg_map_t> m_debug_trace_regs_read;$/;"	m	class:ptx_thread_info
m_decl_location	ptx_ir.h	/^   std::string m_decl_location;$/;"	m	class:symbol
m_derive_done	tm_manager_internal.h	/^   bool m_derive_done; $/;"	m	class:tm_options
m_double	ptx_ir.h	/^      double          m_double;$/;"	m	union:operand_info::__anon3
m_double_operand_type	ptx_ir.h	/^   int m_double_operand_type;$/;"	m	class:operand_info
m_dst	ptx_ir.h	/^   const symbol *m_dst;$/;"	m	class:arg_buffer_t
m_duration	tm_manager_internal.h	/^    pow2_histogram m_duration; \/\/ how long did the transaction run $/;"	m	class:tm_global_statistics
m_duration_first_rd	tm_manager_internal.h	/^    pow2_histogram m_duration_first_rd; $/;"	m	class:tm_global_statistics
m_enable_access_mode	tm_manager_internal.h	/^   bool m_enable_access_mode; \/\/ recognize intrinsics that specify if a access can potentially be conflicting $/;"	m	class:tm_options
m_enable_debug_trace	ptx_sim.h	/^   bool m_enable_debug_trace;$/;"	m	class:ptx_thread_info
m_entry_point	ptx_ir.h	/^   bool m_entry_point;$/;"	m	class:function_info
m_exact_logical_temporal_conflict_detection	tm_manager_internal.h	/^   bool m_exact_logical_temporal_conflict_detection;$/;"	m	class:tm_options
m_exact_num_writing_threads	tm_manager_internal.h	/^   exact_num_writing_threads m_exact_num_writing_threads;     \/\/ the number of pending Tx which ever wrote this address$/;"	m	class:logical_temporal_conflict_detector
m_exact_temporal_conflict_detection	tm_manager_internal.h	/^   bool m_exact_temporal_conflict_detection; $/;"	m	class:tm_options
m_exit	ptx_ir.h	/^   bool                m_exit;$/;"	m	class:ptx_instruction
m_extern	ptx_ir.h	/^   bool m_extern;$/;"	m	class:function_info
m_extern_spec	ptx_ir.h	/^   int m_extern_spec;$/;"	m	class:type_info_key
m_false_abortee_size	tm_manager_internal.h	/^    pow2_histogram m_false_abortee_size; $/;"	m	class:tm_global_statistics
m_false_aborter_size	tm_manager_internal.h	/^    pow2_histogram m_false_aborter_size; $/;"	m	class:tm_global_statistics
m_first_read_cycle	tm_manager_internal.h	/^   unsigned long long m_first_read_cycle; \/\/ when the transaction first load from memory $/;"	m	class:tm_manager
m_first_read_done	tm_manager_internal.h	/^      bool m_first_read_done; $/;"	m	class:value_based_tm_manager::temporal_cd_metadata
m_first_read_time	tm_manager_internal.h	/^      tm_timestamp_t m_first_read_time; $/;"	m	class:value_based_tm_manager::temporal_cd_metadata
m_float	ptx_ir.h	/^      float           m_float;$/;"	m	union:operand_info::__anon3
m_func_info	ptx_sim.h	/^   function_info *m_func_info;$/;"	m	class:ptx_thread_info
m_func_info	ptx_sim.h	/^   function_info *m_func_info;$/;"	m	struct:stack_entry
m_funct_id	bloomfilter.h	/^   int m_funct_id; $/;"	m	class:hashtable
m_funct_id	bloomfilter.h	/^   int m_funct_id; $/;"	m	class:versioning_hashtable
m_funct_ids	tm_manager_internal.h	/^   std::vector<int> m_funct_ids; $/;"	m	class:tm_bloomfilter_options
m_function	ptx_ir.h	/^   function_info *m_function; \/\/ used for function symbols$/;"	m	class:symbol
m_function_info_lookup	ptx_ir.h	/^   std::map<std::string,function_info*> m_function_info_lookup;$/;"	m	class:symbol_table
m_function_symtab_lookup	ptx_ir.h	/^   std::map<std::string,symbol_table*> m_function_symtab_lookup;$/;"	m	class:symbol_table
m_functionalSimulationMode	ptx_sim.h	/^   bool m_functionalSimulationMode; $/;"	m	class:ptx_thread_info
m_geom_spec	ptx_ir.h	/^   int m_geom_spec;$/;"	m	class:ptx_instruction
m_global_next	ptx_ir.h	/^   unsigned m_global_next;$/;"	m	class:symbol_table
m_globals	ptx_ir.h	/^   std::list<symbol*> m_globals;$/;"	m	class:symbol_table
m_gmem	tm_manager_internal.h	/^   memory_space *m_gmem; \/\/ assume this is global memory $/;"	m	class:logical_timestamp_based_tm_manager
m_gmem	tm_manager_internal.h	/^   memory_space *m_gmem; \/\/ assume this is global memory $/;"	m	class:value_based_tm_manager
m_gmem_view_tx	tm_manager_internal.h	/^   tm_manager * m_gmem_view_tx; $/;"	m	class:tm_manager
m_gpu	ptx_sim.h	/^   gpgpu_t *m_gpu;$/;"	m	class:ptx_thread_info
m_gridid	ptx_sim.h	/^   unsigned m_gridid;$/;"	m	class:ptx_thread_info
m_hash_funct_ptr	bloomfilter.h	/^   hash_funct_ptr m_hash_funct_ptr; $/;"	m	class:hashtable
m_hash_funct_ptr	bloomfilter.h	/^   hash_funct_ptr m_hash_funct_ptr; $/;"	m	class:versioning_hashtable
m_hash_gen_mask	bloomfilter.h	/^   std::vector<tvec_t> m_hash_gen_mask; \/\/ mask that helps accelerate hash generation $/;"	m	class:hashtable_bits_mt
m_hashed_sig	bloomfilter.h	/^   std::vector<hashed_tvec_t> m_hashed_sig; $/;"	m	class:hashtable_bits_mt
m_hashtables	bloomfilter.h	/^   hashtables_array m_hashtables; $/;"	m	class:bloomfilter
m_hashtables	bloomfilter.h	/^   hashtables_array m_hashtables; $/;"	m	class:bloomfilter_mt
m_hashtables	bloomfilter.h	/^   hashtables_array m_hashtables; $/;"	m	class:versioning_bloomfilter
m_hi	ptx_ir.h	/^   bool                m_hi;$/;"	m	class:ptx_instruction
m_hw_ctaid	ptx_sim.h	/^   unsigned m_hw_ctaid;$/;"	m	class:ptx_thread_info
m_hw_sid	ptx_sim.h	/^   unsigned m_hw_sid;$/;"	m	class:ptx_thread_info
m_hw_tid	ptx_sim.h	/^   unsigned m_hw_tid;$/;"	m	class:ptx_thread_info
m_hw_wid	ptx_sim.h	/^   unsigned m_hw_wid;$/;"	m	class:ptx_thread_info
m_icount	ptx_sim.h	/^   unsigned m_icount;$/;"	m	class:ptx_thread_info
m_immediate_address	ptx_ir.h	/^   bool m_immediate_address;$/;"	m	class:operand_info
m_init	ptx_ir.h	/^   bool m_init;$/;"	m	class:type_info_key
m_init	tm_manager_internal.h	/^   bool m_init; $/;"	m	class:tm_bloomfilter_options
m_initializer	ptx_ir.h	/^   std::list<operand_info> m_initializer;$/;"	m	class:symbol
m_inst_size	ptx_ir.h	/^   unsigned m_inst_size; \/\/ bytes$/;"	m	class:ptx_instruction
m_instr_mem	ptx_ir.h	/^   ptx_instruction **m_instr_mem;$/;"	m	class:function_info
m_instr_mem_index	ptx_ir.h	/^   int m_instr_mem_index; \/\/index into m_instr_mem array$/;"	m	class:ptx_instruction
m_instr_mem_size	ptx_ir.h	/^   unsigned m_instr_mem_size;$/;"	m	class:function_info
m_instructions	ptx_ir.h	/^   std::list<ptx_instruction*> m_instructions;$/;"	m	class:function_info
m_int	ptx_ir.h	/^      int             m_int;$/;"	m	union:operand_info::__anon3
m_is_abort_need_clean	tm_manager.h	/^   bool m_is_abort_need_clean; \/\/ in logical timestamp besed tm manager, aborted TX need to clean number of writing$/;"	m	class:tm_manager_inf
m_is_const	ptx_ir.h	/^   bool m_is_const;$/;"	m	class:symbol
m_is_func_addr	ptx_ir.h	/^   bool m_is_func_addr;$/;"	m	class:symbol
m_is_function	ptx_ir.h	/^   int m_is_function;$/;"	m	class:type_info_key
m_is_global	ptx_ir.h	/^   bool m_is_global;$/;"	m	class:symbol
m_is_label	ptx_ir.h	/^   bool m_is_label;$/;"	m	class:symbol
m_is_local	ptx_ir.h	/^   bool m_is_local;$/;"	m	class:symbol
m_is_non_arch_reg	ptx_ir.h	/^   bool m_is_non_arch_reg;$/;"	m	class:operand_info
m_is_non_arch_reg	ptx_ir.h	/^   bool m_is_non_arch_reg;$/;"	m	class:type_info_key
m_is_param	ptx_ir.h	/^   bool m_is_param;$/;"	m	class:arg_buffer_t
m_is_param_local	ptx_ir.h	/^   bool m_is_param_local;$/;"	m	class:symbol
m_is_ptr	ptx_ir.h	/^   bool m_is_ptr; $/;"	m	class:param_info
m_is_reg	ptx_ir.h	/^   bool m_is_reg;$/;"	m	class:arg_buffer_t
m_is_return_var	ptx_ir.h	/^   bool m_is_return_var;$/;"	m	class:operand_info
m_is_shared	ptx_ir.h	/^   bool m_is_shared;$/;"	m	class:symbol
m_is_tex	ptx_ir.h	/^   bool m_is_tex;$/;"	m	class:symbol
m_is_tm	ptx_sim.h	/^   bool m_is_tm;$/;"	m	struct:stack_entry
m_is_warp_level	tm_manager.h	/^   bool m_is_warp_level; \/\/ true if this transaction is part of a warp-level transaction$/;"	m	class:tm_manager_inf
m_kernel	ptx_sim.h	/^   kernel_info_t &m_kernel;$/;"	m	class:ptx_thread_info
m_kernel_info	ptx_ir.h	/^   struct gpgpu_ptx_sim_kernel_info m_kernel_info;$/;"	m	class:function_info	typeref:struct:function_info::gpgpu_ptx_sim_kernel_info
m_kernel_params	ptx_ir.h	/^   std::map<std::string,param_t> m_kernel_params;$/;"	m	class:function_info
m_label	ptx_ir.h	/^   const symbol           *m_label;$/;"	m	class:ptx_instruction
m_last_atomic_callback_value	ptx_sim.h	/^   long long m_last_atomic_callback_value;$/;"	m	class:ptx_thread_info
m_last_atomic_callback_value_set	ptx_sim.h	/^   bool m_last_atomic_callback_value_set;$/;"	m	class:ptx_thread_info
m_last_dram_callback	ptx_sim.h	/^   dram_callback_t   m_last_dram_callback; $/;"	m	class:ptx_thread_info
m_last_effective_address	ptx_sim.h	/^   addr_t         m_last_effective_address;$/;"	m	class:ptx_thread_info
m_last_logical_tm_dram_callback	ptx_sim.h	/^   logical_tm_dram_callback_t   m_last_logical_tm_dram_callback; $/;"	m	class:ptx_thread_info
m_last_memory_space	ptx_sim.h	/^   memory_space_t m_last_memory_space;$/;"	m	class:ptx_thread_info
m_last_set_operand_value	ptx_sim.h	/^   ptx_reg_t m_last_set_operand_value;$/;"	m	class:ptx_thread_info
m_last_validation	tm_manager_internal.h	/^   unsigned long long m_last_validation; \/\/ when was this transaction last validated $/;"	m	class:value_based_tm_manager
m_last_was_call	ptx_sim.h	/^   bool m_last_was_call;$/;"	m	class:ptx_thread_info
m_last_writer_time	tm_manager_internal.h	/^      tm_timestamp_t m_last_writer_time; \/\/ the last time when any word in the read-set is written $/;"	m	class:value_based_tm_manager::temporal_cd_metadata
m_last_written_timetable	tm_manager_internal.h	/^   last_written_time_t m_last_written_timetable; \/\/ a perfect record of when a word is last written $/;"	m	class:temporal_conflict_detector
m_latest_read_timetable	tm_manager_internal.h	/^   latest_read_logical_time_t m_latest_read_timetable;        \/\/ a perfect record of when a word is read with largest pts$/;"	m	class:logical_temporal_conflict_detector
m_latest_written_timetable	tm_manager_internal.h	/^   latest_written_logical_time_t m_latest_written_timetable;  \/\/ a perfect record of when a word is written with largest pts$/;"	m	class:logical_temporal_conflict_detector
m_lazy_coherence_traffic	tm_manager_internal.h	/^    pow2_histogram m_lazy_coherence_traffic; $/;"	m	class:tm_global_statistics
m_lazy_coherence_traffic_core_level	tm_manager_internal.h	/^    unsigned long long m_lazy_coherence_traffic_core_level; $/;"	m	class:tm_global_statistics
m_lazy_coherence_traffic_thread_level	tm_manager_internal.h	/^    unsigned long long m_lazy_coherence_traffic_thread_level; $/;"	m	class:tm_global_statistics
m_lazy_conflict_detection	tm_manager_internal.h	/^   bool m_lazy_conflict_detection; $/;"	m	class:tm_options
m_liveThreadCount	cuda-sim.h	/^    unsigned * m_liveThreadCount;$/;"	m	class:functionalCoreSim
m_lo	ptx_ir.h	/^   bool                m_lo;$/;"	m	class:ptx_instruction
m_local_mem	ptx_sim.h	/^   memory_space   *m_local_mem;$/;"	m	class:ptx_thread_info
m_local_mem_framesize	ptx_ir.h	/^   unsigned m_local_mem_framesize;$/;"	m	class:function_info
m_local_mem_stack_pointer	ptx_sim.h	/^   unsigned m_local_mem_stack_pointer;$/;"	m	class:ptx_thread_info
m_local_next	ptx_ir.h	/^   unsigned m_local_next;$/;"	m	class:symbol_table
m_log2_block_size	memory.h	/^   unsigned m_log2_block_size;$/;"	m	class:memory_space_impl
m_logical_temporal_cd_addr_granularity	tm_manager_internal.h	/^   unsigned m_logical_temporal_cd_addr_granularity; $/;"	m	class:tm_options
m_logical_temporal_cd_addr_granularity_log2	tm_manager_internal.h	/^   unsigned m_logical_temporal_cd_addr_granularity_log2;$/;"	m	class:tm_options
m_logical_temporal_cd_metadata	tm_manager_internal.h	/^   logical_temporal_cd_metadata m_logical_temporal_cd_metadata; $/;"	m	class:logical_timestamp_based_tm_manager
m_logical_temporal_num_writing_bloomfilter_n_hash	tm_manager_internal.h	/^   unsigned m_logical_temporal_num_writing_bloomfilter_n_hash;  $/;"	m	class:tm_options
m_logical_temporal_num_writing_bloomfilter_size	tm_manager_internal.h	/^   unsigned m_logical_temporal_num_writing_bloomfilter_size;  $/;"	m	class:tm_options
m_logical_temporal_timestamp_bloomfilter_n_hash	tm_manager_internal.h	/^   unsigned m_logical_temporal_timestamp_bloomfilter_n_hash;  $/;"	m	class:tm_options
m_logical_temporal_timestamp_bloomfilter_size	tm_manager_internal.h	/^   unsigned m_logical_temporal_timestamp_bloomfilter_size;  $/;"	m	class:tm_options
m_map_f64_to_f32	ptx_sim.h	/^      bool     m_map_f64_to_f32; $/;"	m	class:ptx_version
m_max_concurrency	tm_manager_internal.h	/^    unsigned m_max_concurrency; $/;"	m	class:tm_global_statistics
m_max_conflict_footprint	tm_manager_internal.h	/^    int m_max_conflict_footprint; $/;"	m	class:tm_global_statistics
m_max_readonly_footprint	tm_manager_internal.h	/^    int m_max_readonly_footprint; $/;"	m	class:tm_global_statistics
m_max_transaction_footprint	tm_manager_internal.h	/^    size_t m_max_transaction_footprint; $/;"	m	class:tm_global_statistics
m_max_writeonly_footprint	tm_manager_internal.h	/^    int m_max_writeonly_footprint; $/;"	m	class:tm_global_statistics
m_mem	tm_manager_internal.h	/^	conflict_mem_t m_mem;$/;"	m	class:tm_global_state
m_mem	tm_manager_internal.h	/^	memory_space *m_mem;$/;"	m	class:tm_manager::access_record
m_membar_level	ptx_ir.h	/^   int m_membar_level;$/;"	m	class:ptx_instruction
m_modified	tm_manager_internal.h	/^      unsigned long long m_modified;$/;"	m	struct:tm_manager::tm_mem_bucket
m_n_aborts	tm_manager_internal.h	/^    unsigned long long m_n_aborts; $/;"	m	class:tm_global_statistics
m_n_bfxaddrstrm_detected_conflicts	tm_manager_internal.h	/^    unsigned long long m_n_bfxaddrstrm_detected_conflicts; $/;"	m	class:tm_global_statistics
m_n_bfxaddrstrm_false_conflicts	tm_manager_internal.h	/^    unsigned long long m_n_bfxaddrstrm_false_conflicts; $/;"	m	class:tm_global_statistics
m_n_bfxaddrstrm_hashed_detected_conflicts	tm_manager_internal.h	/^    unsigned long long m_n_bfxaddrstrm_hashed_detected_conflicts; $/;"	m	class:tm_global_statistics
m_n_bfxaddrstrm_hashed_false_conflicts	tm_manager_internal.h	/^    unsigned long long m_n_bfxaddrstrm_hashed_false_conflicts; $/;"	m	class:tm_global_statistics
m_n_bloomfilter_detected_conflicts	tm_manager_internal.h	/^    unsigned long long m_n_bloomfilter_detected_conflicts; $/;"	m	class:tm_global_statistics
m_n_bloomfilter_false_conflicts	tm_manager_internal.h	/^    unsigned long long m_n_bloomfilter_false_conflicts; $/;"	m	class:tm_global_statistics
m_n_commits	tm_manager_internal.h	/^    unsigned long long m_n_commits; $/;"	m	class:tm_global_statistics
m_n_hashes	bloomfilter.h	/^   size_t m_n_hashes; $/;"	m	class:bloomfilter
m_n_hashes	bloomfilter.h	/^   size_t m_n_hashes; $/;"	m	class:bloomfilter_mt
m_n_hashes	bloomfilter.h	/^   size_t m_n_hashes; $/;"	m	class:versioning_bloomfilter
m_n_hashes	tm_manager_internal.h	/^   unsigned int m_n_hashes; $/;"	m	class:tm_bloomfilter_options
m_n_insn_per_aborted_txn	tm_manager_internal.h	/^    pow2_histogram m_n_insn_per_aborted_txn;$/;"	m	class:tm_global_statistics
m_n_insn_per_committed_txn	tm_manager_internal.h	/^    pow2_histogram m_n_insn_per_committed_txn;$/;"	m	class:tm_global_statistics
m_n_insn_txn	tm_manager_internal.h	/^    unsigned long long m_n_insn_txn;$/;"	m	class:tm_global_statistics
m_n_intra_block_aborts	tm_manager_internal.h	/^    unsigned long long m_n_intra_block_aborts; $/;"	m	class:tm_global_statistics
m_n_intra_core_aborts	tm_manager_internal.h	/^    unsigned long long m_n_intra_core_aborts; $/;"	m	class:tm_global_statistics
m_n_intra_warp_aborts	tm_manager_internal.h	/^    unsigned long long m_n_intra_warp_aborts; $/;"	m	class:tm_global_statistics
m_n_intra_warp_detected_conflicts	tm_manager_internal.h	/^    unsigned long long m_n_intra_warp_detected_conflicts; $/;"	m	class:tm_global_statistics
m_n_read	tm_manager_internal.h	/^    pow2_histogram m_n_read; $/;"	m	class:tm_global_statistics
m_n_read	tm_manager_internal.h	/^   unsigned m_n_read;  \/\/ count reads the require conflict detection $/;"	m	class:tm_manager
m_n_records	tm_manager_internal.h	/^   unsigned int m_n_records; $/;"	m	class:tm_ring_compressed_record
m_n_reread	tm_manager_internal.h	/^    pow2_histogram m_n_reread;$/;"	m	class:tm_global_statistics
m_n_reread	tm_manager_internal.h	/^   unsigned m_n_reread; $/;"	m	class:value_based_tm_manager
m_n_reread_violation	tm_manager_internal.h	/^    unsigned m_n_reread_violation; $/;"	m	class:tm_global_statistics
m_n_reread_violation	tm_manager_internal.h	/^   unsigned m_n_reread_violation; $/;"	m	class:value_based_tm_manager
m_n_rewrite	tm_manager_internal.h	/^    pow2_histogram m_n_rewrite; $/;"	m	class:tm_global_statistics
m_n_rewrite	tm_manager_internal.h	/^   unsigned m_n_rewrite; $/;"	m	class:tm_manager
m_n_rollback_insn	tm_manager_internal.h	/^    unsigned long long m_n_rollback_insn; $/;"	m	class:tm_global_statistics
m_n_timeout	tm_manager_internal.h	/^   unsigned m_n_timeout; $/;"	m	class:value_based_tm_manager
m_n_timeout_validation	tm_manager_internal.h	/^    pow2_histogram m_n_timeout_validation;$/;"	m	class:tm_global_statistics
m_n_transactions	tm_manager_internal.h	/^    unsigned long long m_n_transactions; $/;"	m	class:tm_global_statistics
m_n_vcd_tcd_mismatch	tm_manager_internal.h	/^    unsigned long long m_n_vcd_tcd_mismatch; $/;"	m	class:tm_global_statistics
m_n_warp_level_raw	tm_manager_internal.h	/^    pow2_histogram m_n_warp_level_raw;$/;"	m	class:tm_global_statistics
m_n_write	tm_manager_internal.h	/^    pow2_histogram m_n_write; $/;"	m	class:tm_global_statistics
m_n_write	tm_manager_internal.h	/^   unsigned m_n_write; \/\/ count writes that require buffering $/;"	m	class:tm_manager
m_n_writing_commits	tm_manager_internal.h	/^    unsigned long long m_n_writing_commits; $/;"	m	class:tm_global_statistics
m_name	memory.h	/^   std::string m_name;$/;"	m	class:memory_space_impl
m_name	ptx_ir.h	/^   std::string m_name;$/;"	m	class:function_info
m_name	ptx_ir.h	/^   std::string m_name;$/;"	m	class:param_info
m_name	ptx_ir.h	/^   std::string m_name;$/;"	m	class:symbol
m_nbank	tm_manager_internal.h	/^   unsigned m_nbank; \/\/ how many banks of memory\/conflict tables are there$/;"	m	class:tm_options
m_nbytes	memory.h	/^   unsigned m_nbytes;$/;"	m	class:mem_storage
m_nbytes	tm_manager_internal.h	/^	unsigned 	m_nbytes;$/;"	m	class:tm_manager::access_record
m_nctaid	ptx_sim.h	/^   dim3   m_nctaid;$/;"	m	class:ptx_thread_info
m_neg	ptx_ir.h	/^   bool                m_neg;$/;"	m	class:ptx_instruction
m_neg_pred	ptx_ir.h	/^   bool                    m_neg_pred;$/;"	m	class:ptx_instruction
m_neg_pred	ptx_ir.h	/^   bool m_neg_pred;$/;"	m	class:operand_info
m_nesting_level	tm_manager.h	/^   unsigned m_nesting_level;$/;"	m	class:tm_manager_inf
m_next_rec_index	tm_manager_internal.h	/^   int m_next_rec_index; $/;"	m	class:tm_ring_compressed_record
m_nthreads	bloomfilter.h	/^   unsigned int m_nthreads; \/\/ # threads tracked in this filter $/;"	m	class:hashtable_bits_mt
m_nthreads	bloomfilter.h	/^   unsigned int m_nthreads;$/;"	m	class:bloomfilter_mt
m_ntid	ptx_sim.h	/^   dim3   m_ntid;$/;"	m	class:ptx_thread_info
m_num_core_bfhash_per_commit	tm_manager_internal.h	/^    linear_histogram m_num_core_bfhash_per_commit; $/;"	m	class:tm_global_statistics
m_num_core_bfsum_extra_per_commit	tm_manager_internal.h	/^    linear_histogram m_num_core_bfsum_extra_per_commit; $/;"	m	class:tm_global_statistics
m_num_core_bfsum_per_commit	tm_manager_internal.h	/^    linear_histogram m_num_core_bfsum_per_commit; $/;"	m	class:tm_global_statistics
m_num_core_bfxaddrstrm_per_commit	tm_manager_internal.h	/^    linear_histogram m_num_core_bfxaddrstrm_per_commit; $/;"	m	class:tm_global_statistics
m_num_core_conflict_per_commit	tm_manager_internal.h	/^    linear_histogram m_num_core_conflict_per_commit; $/;"	m	class:tm_global_statistics
m_num_thread_conflict_per_commit	tm_manager_internal.h	/^    pow2_histogram m_num_thread_conflict_per_commit; $/;"	m	class:tm_global_statistics
m_num_thread_match_per_bfhash_match	tm_manager_internal.h	/^    pow2_histogram m_num_thread_match_per_bfhash_match; $/;"	m	class:tm_global_statistics
m_num_wr_rbloomfilter	tm_manager_internal.h	/^   versioning_bloomfilter * m_num_wr_rbloomfilter;$/;"	m	class:logical_temporal_conflict_detector
m_obj_type	bloomfilter.h	/^   int m_obj_type; \/\/ safety check to ensure that we do not cast pointer to hashtable_bits into hashtable_counter $/;"	m	class:hashtable_bits
m_obj_type	bloomfilter.h	/^   int m_obj_type; \/\/ safety check to ensure that we do not cast pointer to hashtable_bits into hashtable_counter $/;"	m	class:hashtable_bits_mt
m_offset	ptx_ir.h	/^   unsigned m_offset;$/;"	m	class:param_info
m_opcode	ptx_ir.h	/^   int                     m_opcode;$/;"	m	class:ptx_instruction
m_operand_lohi	ptx_ir.h	/^   int m_operand_lohi;$/;"	m	class:operand_info
m_operand_neg	ptx_ir.h	/^   bool m_operand_neg;$/;"	m	class:operand_info
m_operands	ptx_ir.h	/^   std::vector<operand_info> m_operands;$/;"	m	class:ptx_instruction
m_opp	tm_manager_internal.h	/^   option_parser_t m_opp; \/\/ retaining a handle of the option parser for option checking later $/;"	m	class:tm_options
m_options	ptx_ir.h	/^   std::list<int>          m_options;$/;"	m	class:ptx_instruction
m_overflow	tm_manager_internal.h	/^   	int m_overflow;$/;"	m	class:tm_manager::trans_stats
m_param_bytes	ptx_ir.h	/^   unsigned  m_param_bytes;$/;"	m	class:arg_buffer_t
m_param_value	ptx_ir.h	/^   void     *m_param_value;$/;"	m	class:arg_buffer_t
m_parent	ptx_ir.h	/^   symbol_table *m_parent;$/;"	m	class:symbol_table
m_parent	tm_manager_internal.h	/^	tm_manager *m_parent;$/;"	m	class:tm_manager::access_record
m_pred	ptx_ir.h	/^   const symbol           *m_pred;$/;"	m	class:ptx_instruction
m_pred_mod	ptx_ir.h	/^   int                    m_pred_mod;$/;"	m	class:ptx_instruction
m_priority	tm_manager_internal.h	/^   int m_priority; $/;"	m	class:tm_ring_commit_record
m_ptr_space	ptx_ir.h	/^   memory_space_t m_ptr_space; $/;"	m	class:param_info
m_ptx_extensions	ptx_sim.h	/^      unsigned m_ptx_extensions;$/;"	m	class:ptx_version
m_ptx_kernel_param_info	ptx_ir.h	/^   std::map<unsigned,param_info> m_ptx_kernel_param_info;$/;"	m	class:function_info
m_ptx_save_converted_ptxplus	ptx_loader.cc	/^bool m_ptx_save_converted_ptxplus;$/;"	v
m_ptx_version	ptx_ir.h	/^   ptx_version m_ptx_version;$/;"	m	class:symbol_table
m_ptx_version	ptx_sim.h	/^      float    m_ptx_version;$/;"	m	class:ptx_version
m_qstring	hashfunc.h	/^   std::vector<addr_t> m_qstring; $/;"	m	class:hasht_funct::h3_hash
m_raw_access	tm_manager_internal.h	/^    pow2_histogram m_raw_access; $/;"	m	class:tm_global_statistics
m_raw_access	tm_manager_internal.h	/^   unsigned m_raw_access; \/\/ bandwidth $/;"	m	class:tm_manager
m_raw_footprint	tm_manager_internal.h	/^    pow2_histogram m_raw_footprint; $/;"	m	class:tm_global_statistics
m_raw_set	tm_manager_internal.h	/^   addr_set_t m_raw_set; \/\/ footprint $/;"	m	class:tm_manager
m_rbloomfilter	tm_manager_internal.h	/^   versioning_bloomfilter * m_rbloomfilter; $/;"	m	class:temporal_conflict_detector
m_rd	tm_manager_internal.h	/^	bool 		m_rd; \/\/ true = read, false = write$/;"	m	class:tm_manager::access_record
m_read_block_set	tm_manager_internal.h	/^   addr_set_t m_read_block_set; $/;"	m	class:tm_manager
m_read_conflict_detection	tm_manager_internal.h	/^   bool m_read_conflict_detection; $/;"	m	class:tm_manager
m_read_nblock	tm_manager_internal.h	/^    pow2_histogram m_read_nblock; $/;"	m	class:tm_global_statistics
m_read_set	tm_manager_internal.h	/^   addr_set_t m_read_set;$/;"	m	class:tm_manager
m_read_set_value	tm_manager_internal.h	/^   addr_value_t m_read_set_value; $/;"	m	class:value_based_tm_manager
m_read_size	tm_manager_internal.h	/^    pow2_histogram m_read_size; $/;"	m	class:tm_global_statistics
m_read_sz_all	tm_manager_internal.h	/^    pow2_histogram m_read_sz_all; $/;"	m	class:tm_global_statistics
m_read_word_set	tm_manager_internal.h	/^   addr_set_t m_read_word_set; $/;"	m	class:tm_manager
m_read_word_version	tm_manager_internal.h	/^   addr_version_set_t m_read_word_version; $/;"	m	class:ring_tm_manager
m_readonly_footprint	tm_manager_internal.h	/^    pow2_histogram m_readonly_footprint; $/;"	m	class:tm_global_statistics
m_readonly_footprint	tm_manager_internal.h	/^   int m_readonly_footprint; $/;"	m	class:tm_global_state
m_ref_count	tm_manager.h	/^   int m_ref_count; $/;"	m	class:tm_manager_inf
m_reg_allocator	ptx_ir.h	/^   unsigned m_reg_allocator;$/;"	m	class:symbol_table
m_reg_num	ptx_ir.h	/^   unsigned m_reg_num; $/;"	m	class:symbol
m_reg_num_valid	ptx_ir.h	/^   bool m_reg_num_valid; $/;"	m	class:symbol
m_reg_value	ptx_ir.h	/^   ptx_reg_t m_reg_value;$/;"	m	class:arg_buffer_t
m_regs	ptx_sim.h	/^   std::list<reg_map_t> m_regs;$/;"	m	class:ptx_thread_info
m_regs_buffered_max	tm_manager_internal.h	/^    linear_histogram m_regs_buffered_max;$/;"	m	class:tm_global_statistics
m_regs_modified_max	tm_manager_internal.h	/^    linear_histogram m_regs_modified_max;$/;"	m	class:tm_global_statistics
m_regs_read_max	tm_manager_internal.h	/^    linear_histogram m_regs_read_max;$/;"	m	class:tm_global_statistics
m_return_var	ptx_ir.h	/^   operand_info m_return_var;$/;"	m	class:ptx_instruction
m_return_var_dst	ptx_sim.h	/^   const symbol  *m_return_var_dst;$/;"	m	struct:stack_entry
m_return_var_src	ptx_sim.h	/^   const symbol  *m_return_var_src;$/;"	m	struct:stack_entry
m_return_var_sym	ptx_ir.h	/^   const symbol *m_return_var_sym;$/;"	m	class:function_info
m_ring	tm_manager_internal.h	/^   ring_t m_ring; $/;"	m	class:tm_ring_global
m_ring_bloomfilter_false_conflicts	tm_manager_internal.h	/^   unsigned int m_ring_bloomfilter_false_conflicts; $/;"	m	class:tm_ring_stats
m_ring_dump_record	tm_manager_internal.h	/^   bool m_ring_dump_record; $/;"	m	class:tm_options
m_ring_index	tm_manager_internal.h	/^   int m_ring_index; \/\/ the newest ring entry$/;"	m	class:tm_ring_global
m_ring_priority	tm_manager_internal.h	/^   int m_ring_priority; \/\/ not used for now $/;"	m	class:ring_tm_manager
m_ring_starttime	tm_manager_internal.h	/^   int m_ring_starttime; $/;"	m	class:ring_tm_manager
m_ring_tm_bloomfilter	tm_manager_internal.h	/^   bool m_ring_tm_bloomfilter; $/;"	m	class:tm_options
m_ring_tm_eager_cd	tm_manager_internal.h	/^   bool m_ring_tm_eager_cd; $/;"	m	class:tm_options
m_ring_tm_record_capacity	tm_manager_internal.h	/^   int m_ring_tm_record_capacity; $/;"	m	class:tm_options
m_ring_tm_size_limit	tm_manager_internal.h	/^   int m_ring_tm_size_limit; $/;"	m	class:tm_options
m_ring_tm_version_read	tm_manager_internal.h	/^   bool m_ring_tm_version_read;$/;"	m	class:tm_options
m_rounding_mode	ptx_ir.h	/^   unsigned            m_rounding_mode;$/;"	m	class:ptx_instruction
m_rts_rbloomfilter	tm_manager_internal.h	/^   versioning_bloomfilter * m_rts_rbloomfilter;$/;"	m	class:logical_temporal_conflict_detector
m_saturation_mode	ptx_ir.h	/^   unsigned            m_saturation_mode;$/;"	m	class:ptx_instruction
m_scalar_type	ptx_ir.h	/^   std::list<int>          m_scalar_type;$/;"	m	class:ptx_instruction
m_scalar_type_spec	ptx_ir.h	/^   int m_scalar_type_spec;$/;"	m	class:type_info_key
m_scope	ptx_ir.h	/^   symbol_table *m_scope;$/;"	m	class:type_info
m_scope_name	ptx_ir.h	/^   std::string m_scope_name;$/;"	m	class:symbol_table
m_seed	hashfunc.h	/^   unsigned int m_seed; $/;"	m	class:hasht_funct::h3_hash
m_selected_thread	bloomfilter.h	/^   int m_selected_thread; \/\/ thread id of the selected thread to be operated $/;"	m	class:hashtable_bits_mt
m_shader_id	bloomfilter.h	/^   std::vector<unsigned int> m_shader_id;$/;"	m	class:versioning_hashtable
m_shared_mem	ptx_sim.h	/^   memory_space   *m_shared_mem;$/;"	m	class:ptx_thread_info
m_shared_next	ptx_ir.h	/^   unsigned m_shared_next;$/;"	m	class:symbol_table
m_signature	bloomfilter.h	/^   sig_t m_signature; \/\/ the bit array containing the approximate representation of the hashed set $/;"	m	class:hashtable_bits
m_signature	bloomfilter.h	/^   std::vector<tvec_t> m_signature; \/\/ array of the bit arrays [sig-bit, tid] containing the approx. representation of the hashed set $/;"	m	class:hashtable_bits_mt
m_size	bloomfilter.h	/^   unsigned int m_size; $/;"	m	class:bloomfilter
m_size	bloomfilter.h	/^   unsigned int m_size; $/;"	m	class:bloomfilter_mt
m_size	bloomfilter.h	/^   unsigned int m_size; $/;"	m	class:hashtable
m_size	bloomfilter.h	/^   unsigned int m_size; $/;"	m	class:versioning_bloomfilter
m_size	bloomfilter.h	/^   unsigned int m_size; $/;"	m	class:versioning_hashtable
m_size	hashfunc.h	/^   unsigned int m_size; $/;"	m	class:hasht_funct::gskew_hash
m_size	hashfunc.h	/^   unsigned int m_size; $/;"	m	class:hasht_funct::h3_hash
m_size	ptx_ir.h	/^   size_t m_size;$/;"	m	class:param_info
m_size	ptx_ir.h	/^   unsigned m_size; \/\/ in bytes$/;"	m	class:symbol
m_size	tm_manager_internal.h	/^   unsigned int m_size; $/;"	m	class:tm_bloomfilter_options
m_size_log2	hashfunc.h	/^   unsigned int m_size_log2; $/;"	m	class:hasht_funct::gskew_hash
m_size_log2	hashfunc.h	/^   unsigned int m_size_log2; $/;"	m	class:hasht_funct::h3_hash
m_sm_idx	ptx_sim.h	/^   unsigned                m_sm_idx;$/;"	m	class:ptx_cta_info
m_sm_version	ptx_sim.h	/^      unsigned m_sm_version;$/;"	m	class:ptx_version
m_sm_version_str	ptx_sim.h	/^      std::string m_sm_version_str;$/;"	m	class:ptx_version
m_sm_version_valid	ptx_sim.h	/^      unsigned m_sm_version_valid;$/;"	m	class:ptx_version
m_source	ptx_ir.h	/^   std::string          m_source;$/;"	m	class:ptx_instruction
m_source_file	ptx_ir.h	/^   std::string             m_source_file;$/;"	m	class:ptx_instruction
m_source_line	ptx_ir.h	/^   unsigned                m_source_line;$/;"	m	class:ptx_instruction
m_space_spec	ptx_ir.h	/^   memory_space_t m_space_spec; $/;"	m	class:type_info_key
m_space_spec	ptx_ir.h	/^   memory_space_t m_space_spec;$/;"	m	class:ptx_instruction
m_src_op	ptx_ir.h	/^   operand_info m_src_op;$/;"	m	class:arg_buffer_t
m_start_PC	ptx_ir.h	/^   unsigned m_start_PC;$/;"	m	class:function_info
m_start_cycle	tm_manager_internal.h	/^   unsigned long long m_start_cycle; \/\/ when the transaction called txbegin()$/;"	m	class:tm_manager
m_start_pts	tm_manager_internal.h	/^      tm_timestamp_t m_start_pts;            \/\/ pts at which Tx start $/;"	m	class:logical_timestamp_based_tm_manager::logical_temporal_cd_metadata
m_stats	tm_manager_internal.h	/^   trans_stats m_stats;$/;"	m	class:tm_manager
m_status	tm_manager_internal.h	/^   enum tm_ring::status_t m_status; $/;"	m	class:tm_ring_commit_record	typeref:enum:tm_ring_commit_record::status_t
m_symbol_table	ptx_sim.h	/^   symbol_table  *m_symbol_table;$/;"	m	class:ptx_thread_info
m_symbol_table	ptx_sim.h	/^   symbol_table  *m_symbol_table;$/;"	m	struct:stack_entry
m_symbolic	ptx_ir.h	/^      const symbol*  m_symbolic;$/;"	m	union:operand_info::__anon3
m_symbols	ptx_ir.h	/^   std::map<std::string, symbol *> m_symbols; \/\/map from name of register to pointers to the registers$/;"	m	class:symbol_table
m_symtab	ptx_ir.h	/^   symbol_table *m_symtab;$/;"	m	class:function_info
m_temporal_bloomfilter_n_hash	tm_manager_internal.h	/^   unsigned m_temporal_bloomfilter_n_hash;  $/;"	m	class:tm_options
m_temporal_bloomfilter_size	tm_manager_internal.h	/^   unsigned m_temporal_bloomfilter_size;  $/;"	m	class:tm_options
m_temporal_cd_addr_granularity	tm_manager_internal.h	/^   unsigned m_temporal_cd_addr_granularity; $/;"	m	class:tm_options
m_temporal_cd_addr_granularity_log2	tm_manager_internal.h	/^   unsigned m_temporal_cd_addr_granularity_log2; $/;"	m	class:tm_options
m_temporal_cd_metadata	tm_manager_internal.h	/^   temporal_cd_metadata m_temporal_cd_metadata; $/;"	m	class:value_based_tm_manager
m_tex_next	ptx_ir.h	/^   unsigned m_tex_next;$/;"	m	class:symbol_table
m_texmode_unified	ptx_sim.h	/^      bool     m_texmode_unified;$/;"	m	class:ptx_version
m_thread	tm_manager.h	/^   ptx_thread_info *m_thread;$/;"	m	class:tm_manager_inf
m_thread_done	ptx_sim.h	/^   bool m_thread_done;$/;"	m	class:ptx_thread_info
m_thread_hwtid	tm_manager.cc	/^   unsigned m_thread_hwtid; $/;"	m	struct:last_writer_info	file:
m_thread_hwtid	tm_manager.h	/^   unsigned m_thread_hwtid;$/;"	m	class:tm_manager_inf
m_thread_hwwid	tm_manager.h	/^   unsigned m_thread_hwwid;$/;"	m	class:tm_manager_inf
m_thread_sc	tm_manager.cc	/^   unsigned m_thread_sc;$/;"	m	struct:last_writer_info	file:
m_thread_sc	tm_manager.h	/^   unsigned m_thread_sc;$/;"	m	class:tm_manager_inf
m_thread_uid	tm_manager.cc	/^   unsigned m_thread_uid; $/;"	m	struct:last_writer_info	file:
m_thread_uid	tm_manager.h	/^   unsigned m_thread_uid;$/;"	m	class:tm_manager_inf
m_threads_in_cta	ptx_sim.h	/^   std::set<ptx_thread_info*>    m_threads_in_cta;$/;"	m	class:ptx_cta_info
m_threads_in_tx	tm_manager_internal.h	/^   tr1_hash_map<unsigned, hashtable_bits_mt::tvec_t> m_threads_in_tx; $/;"	m	class:tm_global_state
m_threads_that_have_exited	ptx_sim.h	/^   std::set<ptx_thread_info*>  m_threads_that_have_exited;$/;"	m	class:ptx_cta_info
m_tid	ptx_sim.h	/^   dim3   m_tid;$/;"	m	class:ptx_thread_info
m_tid_hashsize	bloomfilter.h	/^   unsigned int m_tid_hashsize; $/;"	m	class:bloomfilter_mt
m_tid_hashsize	bloomfilter.h	/^   unsigned int m_tid_hashsize; \/\/ # bits in each hashed thread vector $/;"	m	class:hashtable_bits_mt
m_tid_subhashsize	bloomfilter.h	/^   std::vector<unsigned> m_tid_subhashsize; \/\/ size of each sub hash in the thread-bloomfilter $/;"	m	class:hashtable_bits_mt
m_time	tm_manager.cc	/^   unsigned long long m_time; $/;"	m	struct:last_writer_info	file:
m_timeout_validation	tm_manager_internal.h	/^   int m_timeout_validation; \/\/ allow timeout validation$/;"	m	class:tm_options
m_timestamp	tm_manager_internal.h	/^   int m_timestamp; $/;"	m	class:tm_ring_commit_record
m_timing_mode	tm_manager.h	/^   bool m_timing_mode;$/;"	m	class:tm_manager_inf
m_timing_mode_core_side_commit	tm_manager_internal.h	/^   bool m_timing_mode_core_side_commit;$/;"	m	class:tm_options
m_tlookup	tm_manager_internal.h	/^	tuid_to_thread_t m_tlookup;$/;"	m	class:tm_global_state
m_tm_callback	ptx_sim.h	/^   tm_callback_t *m_tm_callback; \/\/ the tm handler at the uarch model side $/;"	m	class:ptx_thread_info
m_tm_debug_trace_regs_modified_snapshot	ptx_sim.h	/^   std::list<reg_map_t> m_tm_debug_trace_regs_modified_snapshot;$/;"	m	class:ptx_thread_info
m_tm_debug_trace_regs_read_snapshot	ptx_sim.h	/^   std::list<reg_map_t> m_tm_debug_trace_regs_read_snapshot;$/;"	m	class:ptx_thread_info
m_tm_manager	ptx_sim.h	/^   class tm_manager_inf *m_tm_manager;$/;"	m	class:ptx_thread_info	typeref:class:ptx_thread_info::tm_manager_inf
m_tm_mem	tm_manager_internal.h	/^   tm_mem_t m_tm_mem;$/;"	m	class:tm_manager
m_tm_num_transactions	ptx_sim.h	/^   unsigned m_tm_num_transactions;$/;"	m	class:ptx_thread_info
m_tm_num_tx_instruction	ptx_sim.h	/^   unsigned m_tm_num_tx_instruction; $/;"	m	class:ptx_thread_info
m_tm_reg_states	ptx_sim.h	/^   std::list<tm_reg_state_map_t> m_tm_reg_states;$/;"	m	class:ptx_thread_info
m_tm_regs_buffered	ptx_sim.h	/^   unsigned m_tm_regs_buffered;$/;"	m	class:ptx_thread_info
m_tm_regs_buffered_max	ptx_sim.h	/^   unsigned m_tm_regs_buffered_max;$/;"	m	class:ptx_thread_info
m_tm_regs_modified	ptx_sim.h	/^   unsigned m_tm_regs_modified;$/;"	m	class:ptx_thread_info
m_tm_regs_modified_max	ptx_sim.h	/^   unsigned m_tm_regs_modified_max;$/;"	m	class:ptx_thread_info
m_tm_regs_read	ptx_sim.h	/^   unsigned m_tm_regs_read;$/;"	m	class:ptx_thread_info
m_tm_regs_read_max	ptx_sim.h	/^   unsigned m_tm_regs_read_max;$/;"	m	class:ptx_thread_info
m_tm_regs_snapshot	ptx_sim.h	/^   std::list<reg_map_t> m_tm_regs_snapshot;$/;"	m	class:ptx_thread_info
m_tm_restart_PC	ptx_sim.h	/^	unsigned m_tm_restart_PC;$/;"	m	class:ptx_thread_info
m_tm_stack_count	ptx_sim.h	/^	int m_tm_stack_count;$/;"	m	class:ptx_thread_info
m_to_option	ptx_ir.h	/^   bool                m_to_option;$/;"	m	class:ptx_instruction
m_total_nblock	tm_manager_internal.h	/^    pow2_histogram m_total_nblock; $/;"	m	class:tm_global_statistics
m_total_nmem	tm_manager_internal.h	/^    linear_histogram m_total_nmem; $/;"	m	class:tm_global_statistics
m_total_size	tm_manager_internal.h	/^    pow2_histogram m_total_size; $/;"	m	class:tm_global_statistics
m_total_sz_all	tm_manager_internal.h	/^    pow2_histogram m_total_sz_all; $/;"	m	class:tm_global_statistics
m_transaction_footprint	tm_manager_internal.h	/^    pow2_histogram m_transaction_footprint; $/;"	m	class:tm_global_statistics
m_tuid	tm_manager_internal.h	/^   unsigned m_tuid; $/;"	m	class:tm_ring_commit_record
m_tuids_have_read	tm_manager_internal.h	/^	tuid_set_t m_tuids_have_read;$/;"	m	struct:conflict_set
m_tuids_have_written	tm_manager_internal.h	/^	tuid_set_t m_tuids_have_written;$/;"	m	struct:conflict_set
m_type	ptx_ir.h	/^   const type_info *m_type;$/;"	m	class:symbol
m_type	ptx_ir.h	/^   enum operand_type m_type;$/;"	m	class:operand_info	typeref:enum:operand_info::operand_type
m_type	ptx_ir.h	/^   int m_type;$/;"	m	class:param_info
m_type_info	ptx_ir.h	/^   type_info_key m_type_info;$/;"	m	class:type_info
m_types	ptx_ir.h	/^   std::map<type_info_key,type_info*,type_info_key_compare>  m_types;$/;"	m	class:symbol_table
m_uid	ptx_ir.h	/^   unsigned          m_uid;$/;"	m	class:ptx_instruction
m_uid	ptx_ir.h	/^   unsigned m_uid;$/;"	m	class:function_info
m_uid	ptx_ir.h	/^   unsigned m_uid;$/;"	m	class:operand_info
m_uid	ptx_ir.h	/^   unsigned m_uid;$/;"	m	class:symbol
m_uid	ptx_sim.h	/^   unsigned long long         m_uid;$/;"	m	class:ptx_cta_info
m_uid	ptx_sim.h	/^   unsigned m_uid;$/;"	m	class:ptx_thread_info
m_uid	tm_manager.h	/^   unsigned m_uid;$/;"	m	class:tm_manager_inf
m_uni	ptx_ir.h	/^   bool                m_uni; \/\/if branch instruction, this evaluates to true for uniform branches (ie jumps)$/;"	m	class:ptx_instruction
m_unsigned	ptx_ir.h	/^      unsigned int    m_unsigned;$/;"	m	union:operand_info::__anon3
m_use_logical_timestamp_based_tm	tm_manager_internal.h	/^   bool m_use_logical_timestamp_based_tm;$/;"	m	class:tm_options
m_use_ring_tm	tm_manager_internal.h	/^   bool m_use_ring_tm; $/;"	m	class:tm_options
m_use_value_based_tm	tm_manager_internal.h	/^   bool m_use_value_based_tm; $/;"	m	class:tm_options
m_valid	ptx_ir.h	/^   bool m_valid;$/;"	m	class:operand_info
m_valid	ptx_ir.h	/^   bool m_valid;$/;"	m	class:param_info
m_valid	ptx_sim.h	/^      bool     m_valid;$/;"	m	class:ptx_version
m_valid	ptx_sim.h	/^   bool   m_valid;$/;"	m	class:ptx_thread_info
m_valid	ptx_sim.h	/^   bool m_valid;$/;"	m	struct:stack_entry
m_value	ptx_ir.h	/^   param_t m_value;$/;"	m	class:param_info
m_value	ptx_ir.h	/^   } m_value;$/;"	m	class:operand_info	typeref:union:operand_info::__anon3
m_value_based_eager_cr	tm_manager_internal.h	/^   bool m_value_based_eager_cr; $/;"	m	class:tm_options
m_value_set	ptx_ir.h	/^   bool m_value_set;$/;"	m	class:param_info
m_vdouble	ptx_ir.h	/^      double          m_vdouble[4];$/;"	m	union:operand_info::__anon3
m_vector	ptx_ir.h	/^   bool m_vector;$/;"	m	class:operand_info
m_vector_spec	ptx_ir.h	/^   int m_vector_spec;$/;"	m	class:ptx_instruction
m_vector_spec	ptx_ir.h	/^   int m_vector_spec;$/;"	m	class:type_info_key
m_vector_symbolic	ptx_ir.h	/^      const symbol**  m_vector_symbolic;$/;"	m	union:operand_info::__anon3
m_version	bloomfilter.h	/^   std::vector<unsigned int> m_version;$/;"	m	class:versioning_hashtable
m_version_management	tm_manager_internal.h	/^   bool m_version_management; $/;"	m	class:tm_manager
m_vfloat	ptx_ir.h	/^      float           m_vfloat[4];$/;"	m	union:operand_info::__anon3
m_vint	ptx_ir.h	/^      int             m_vint[4];$/;"	m	union:operand_info::__anon3
m_violated	tm_manager_internal.h	/^   bool m_violated; $/;"	m	class:logical_timestamp_based_tm_manager
m_violated	tm_manager_internal.h	/^   bool m_violated; \/\/ true when this transaction is operating on inconsistent data $/;"	m	class:value_based_tm_manager
m_vote_mode	ptx_ir.h	/^   enum vote_mode_t m_vote_mode;$/;"	m	class:ptx_instruction	typeref:enum:ptx_instruction::vote_mode_t
m_vunsigned	ptx_ir.h	/^      unsigned int    m_vunsigned[4];$/;"	m	union:operand_info::__anon3
m_warpAtBarrier	cuda-sim.h	/^    bool* m_warpAtBarrier;$/;"	m	class:functionalCoreSim
m_warp_id	bloomfilter.h	/^   std::vector<unsigned int> m_warp_id;$/;"	m	class:versioning_hashtable
m_warp_level_raw	tm_manager_internal.h	/^   unsigned m_warp_level_raw; $/;"	m	class:value_based_tm_manager
m_warp_level_write_word_set	tm_manager_internal.h	/^   addr_set_t m_warp_level_write_word_set;  \/\/ only record the potentially conflicting ones$/;"	m	class:tm_manager
m_warp_pts_current	tm_manager_internal.h	/^   std::vector<tm_timestamp_t> m_warp_pts_current;     \/\/ latest Tx pts$/;"	m	class:logical_temporal_conflict_detector
m_warp_pts_start	tm_manager_internal.h	/^   std::vector<tm_timestamp_t> m_warp_pts_start;       \/\/ pts at which the Tx start$/;"	m	class:logical_temporal_conflict_detector
m_watchpoints	memory.h	/^   std::map<unsigned,mem_addr_t> m_watchpoints;$/;"	m	class:memory_space_impl
m_wide	ptx_ir.h	/^   bool                m_wide;$/;"	m	class:ptx_instruction
m_word_size	tm_manager_internal.h	/^   unsigned m_word_size; \/\/ size of a word $/;"	m	class:tm_options
m_word_size_log2	tm_manager_internal.h	/^   unsigned m_word_size_log2; $/;"	m	class:tm_options
m_write_block_set	tm_manager_internal.h	/^   addr_set_t m_write_block_set; $/;"	m	class:tm_manager
m_write_buffer_footprint	tm_manager_internal.h	/^    pow2_histogram m_write_buffer_footprint;$/;"	m	class:tm_global_statistics
m_write_conflict_detection	tm_manager_internal.h	/^   bool m_write_conflict_detection;$/;"	m	class:tm_manager
m_write_data	tm_manager_internal.h	/^   std::list<access_record> m_write_data;$/;"	m	class:tm_manager
m_write_filter	tm_manager_internal.h	/^   bloomfilter m_write_filter; \/\/ for bloom filter based conflict detection $/;"	m	class:tm_ring_commit_record
m_write_filter	tm_manager_internal.h	/^   bloomfilter_mt m_write_filter; \/\/ for hashed bloom filter array based conflict detection $/;"	m	class:tm_ring_compressed_record
m_write_nblock	tm_manager_internal.h	/^    pow2_histogram m_write_nblock; $/;"	m	class:tm_global_statistics
m_write_set	tm_manager_internal.h	/^   addr_set_t m_write_set; \/\/ for ideal conflict detection $/;"	m	class:tm_ring_commit_record
m_write_set	tm_manager_internal.h	/^   addr_set_t m_write_set; \/\/ only record the potentially conflicting ones$/;"	m	class:tm_manager
m_write_set	tm_manager_internal.h	/^   bloomfilter m_write_set; $/;"	m	class:tm_bloomfilter_set
m_write_size	tm_manager_internal.h	/^    pow2_histogram m_write_size; $/;"	m	class:tm_global_statistics
m_write_sz_all	tm_manager_internal.h	/^    pow2_histogram m_write_sz_all; $/;"	m	class:tm_global_statistics
m_write_word_set	tm_manager_internal.h	/^   addr_set_t m_write_word_set;  \/\/ only record the potentially conflicting ones$/;"	m	class:tm_manager
m_writeonly_footprint	tm_manager_internal.h	/^    pow2_histogram m_writeonly_footprint; $/;"	m	class:tm_global_statistics
m_writeonly_footprint	tm_manager_internal.h	/^   int m_writeonly_footprint; $/;"	m	class:tm_global_state
m_wts_rbloomfilter	tm_manager_internal.h	/^   versioning_bloomfilter * m_wts_rbloomfilter;$/;"	m	class:logical_temporal_conflict_detector
mad24_impl	instructions.cc	/^void mad24_impl( const ptx_instruction *pI, ptx_thread_info *thread )$/;"	f
mad_def	instructions.cc	/^void mad_def( const ptx_instruction *pI, ptx_thread_info *thread, bool use_carry ) $/;"	f
mad_impl	instructions.cc	/^void mad_impl( const ptx_instruction *pI, ptx_thread_info *thread ) $/;"	f
madp_impl	instructions.cc	/^void madp_impl( const ptx_instruction *pI, ptx_thread_info *thread ) $/;"	f
main	bloomfilter.cc	/^int main() $/;"	f
main	bloomfilter.cc	/^int main()$/;"	f
main	memory.cc	/^int main(int argc, char *argv[] )$/;"	f
make_copy	ptx_ir.h	/^   void make_copy( const arg_buffer_t &another )$/;"	f	class:arg_buffer_t
make_memory_operand	ptx_ir.h	/^   void make_memory_operand() { m_type = memory_t;}$/;"	f	class:operand_info
map_t	memory.h	/^   typedef mem_map<mem_addr_t,mem_storage<BSIZE> > map_t;$/;"	t	class:memory_space_impl
mask_and	ptx_sim.h	/^   void mask_and( unsigned ms, unsigned ls )$/;"	f	union:ptx_reg_t
mask_or	ptx_sim.h	/^   void mask_or( unsigned ms, unsigned ls )$/;"	f	union:ptx_reg_t
match	bloomfilter.cc	/^bool bloomfilter::match(addr_t addr) const $/;"	f	class:bloomfilter
match	bloomfilter.cc	/^bool bloomfilter::match(const bloomfilter& signature) const $/;"	f	class:bloomfilter
match	bloomfilter.cc	/^bool bloomfilter_mt::match(addr_t addr) const$/;"	f	class:bloomfilter_mt
match	bloomfilter.cc	/^bool bloomfilter_mt::match(const bloomfilter& signature)$/;"	f	class:bloomfilter_mt
match	bloomfilter.cc	/^bool hashtable_bits<sig_limit>::match(addr_t addr) const$/;"	f	class:hashtable_bits
match	bloomfilter.cc	/^bool hashtable_bits<sig_limit>::match(const hashtable& signature) const$/;"	f	class:hashtable_bits
match	bloomfilter.cc	/^bool hashtable_bits_mt::match(addr_t addr) const$/;"	f	class:hashtable_bits_mt
match	bloomfilter.cc	/^bool hashtable_bits_mt::match(const hashtable& signature) const$/;"	f	class:hashtable_bits_mt
match	bloomfilter.cc	/^bool hashtable_counter::match(addr_t addr) const$/;"	f	class:hashtable_counter
match	bloomfilter.cc	/^bool hashtable_counter::match(const hashtable& signature) const$/;"	f	class:hashtable_counter
match	tm_manager.cc	/^bool tm_ring_commit_record::match(const addr_version_set_t& other_tx_read_set) const $/;"	f	class:tm_ring_commit_record
match	tm_manager.cc	/^bool tm_ring_compressed_record::match(const addr_version_set_t& other_tx_read_set, int starttime) const$/;"	f	class:tm_ring_compressed_record
match_access_set	tm_manager.cc	/^bool tm_bloomfilter_set::match_access_set(const addr_set_t& w_set) $/;"	f	class:tm_bloomfilter_set
match_access_set	tm_manager.cc	/^bool tm_bloomfilter_set::match_access_set(const tm_bloomfilter_set& other)$/;"	f	class:tm_bloomfilter_set
match_access_set	tm_manager.cc	/^unsigned int tm_bloomfilter_hashed_core_set::match_access_set(const addr_set_t& w_set, hashtable_bits_mt::tvec_t &matched_threads)$/;"	f	class:tm_bloomfilter_hashed_core_set
match_filter	tm_manager.cc	/^bool tm_ring_commit_record::match_filter(const addr_version_set_t& other_tx_read_set) const $/;"	f	class:tm_ring_commit_record
match_hashed	bloomfilter.cc	/^bool bloomfilter_mt::match_hashed(addr_t addr, hashtable_bits_mt::tvec_t& matched_threads) const$/;"	f	class:bloomfilter_mt
match_hashexpanded	bloomfilter.cc	/^bool bloomfilter_mt::match_hashexpanded(addr_t addr)$/;"	f	class:bloomfilter_mt
max	cuda-math.h	71;"	d
max_impl	instructions.cc	/^void max_impl( const ptx_instruction *pI, ptx_thread_info *thread ) $/;"	f
mem_access	tm_manager.cc	/^tuid_set_t tm_global_state::mem_access( unsigned tuid, bool rd, unsigned addr, unsigned nbytes )$/;"	f	class:tm_global_state
mem_access	tm_manager.cc	/^void tm_bloomfilter_hashed_core_set::mem_access(int hw_thread_id, bool rd, unsigned addr, unsigned nbytes)$/;"	f	class:tm_bloomfilter_hashed_core_set
mem_access	tm_manager.cc	/^void tm_bloomfilter_set::mem_access(bool rd, unsigned addr, unsigned nbytes)$/;"	f	class:tm_bloomfilter_set
mem_addr_t	memory.h	/^typedef address_type mem_addr_t;$/;"	t
mem_map	memory.h	34;"	d
mem_storage	memory.h	/^   mem_storage( const mem_storage &another )$/;"	f	class:mem_storage
mem_storage	memory.h	/^   mem_storage()$/;"	f	class:mem_storage
mem_storage	memory.h	/^template<unsigned BSIZE> class mem_storage {$/;"	c
memaccess_tx_bf	tm_manager.cc	/^void tm_global_state::memaccess_tx_bf( unsigned tuid, bool rd, unsigned addr, unsigned nbytes )$/;"	f	class:tm_global_state
membar_impl	instructions.cc	/^void membar_impl( const ptx_instruction *pI, ptx_thread_info *thread ) $/;"	f
membar_level	ptx_ir.h	/^   int membar_level() const { return m_membar_level; }$/;"	f	class:ptx_instruction
memcpy_from_gpu	cuda-sim.cc	/^void gpgpu_t::memcpy_from_gpu( void *dst, size_t src_start_addr, size_t count )$/;"	f	class:gpgpu_t
memcpy_gpu_to_gpu	cuda-sim.cc	/^void gpgpu_t::memcpy_gpu_to_gpu( size_t dst, size_t src, size_t count )$/;"	f	class:gpgpu_t
memcpy_to_gpu	cuda-sim.cc	/^void gpgpu_t::memcpy_to_gpu( size_t dst_start_addr, const void *src, size_t count )$/;"	f	class:gpgpu_t
memory_h_INCLUDED	memory.h	29;"	d
memory_operand	ptx.y	/^memory_operand : LEFT_SQUARE_BRACKET address_expression RIGHT_SQUARE_BRACKET { add_memory_operand(); }$/;"	l
memory_space	memory.h	/^class memory_space$/;"	c
memory_space_impl	memory.cc	/^template<unsigned BSIZE> memory_space_impl<BSIZE>::memory_space_impl( std::string name, unsigned hash_size )$/;"	f	class:memory_space_impl
memory_space_impl	memory.h	/^template<unsigned BSIZE> class memory_space_impl : public memory_space {$/;"	c
memory_t	ptx_ir.h	/^   reg_t, vector_t, builtin_t, address_t, memory_t, float_op_t, double_op_t, int_t, $/;"	e	enum:operand_type
min	cuda-math.h	72;"	d
min_impl	instructions.cc	/^void min_impl( const ptx_instruction *pI, ptx_thread_info *thread ) $/;"	f
mov_impl	instructions.cc	/^void mov_impl( const ptx_instruction *pI, ptx_thread_info *thread ) $/;"	f
ms	ptx_sim.h	/^      unsigned ms;$/;"	m	struct:ptx_reg_t::__anon4
mul24_impl	instructions.cc	/^void mul24_impl( const ptx_instruction *pI, ptx_thread_info *thread ) $/;"	f
mul_impl	instructions.cc	/^void mul_impl( const ptx_instruction *pI, ptx_thread_info *thread ) $/;"	f
my_abs	instructions.cc	676;"	d	file:
my_cuda_printf	cuda_device_printf.cc	/^void my_cuda_printf(const char *fmtstr,const char *arg_list)$/;"	f
mymax	ptx_parser.cc	196;"	d	file:
n_hashes	bloomfilter.h	/^   size_t n_hashes() const { return m_n_hashes; }$/;"	f	class:bloomfilter
n_hashes	bloomfilter.h	/^   size_t n_hashes() const { return m_n_hashes; }$/;"	f	class:bloomfilter_mt
n_hashes	bloomfilter.h	/^   size_t n_hashes() const { return m_n_hashes; }$/;"	f	class:versioning_bloomfilter
name	ptx_ir.h	/^   const std::string &name() const { return m_name;}$/;"	f	class:symbol
name	ptx_ir.h	/^   const std::string &name() const$/;"	f	class:operand_info
nandn_impl	instructions.cc	/^void nandn_impl( const ptx_instruction *pI, ptx_thread_info *thread ) $/;"	f
neg_impl	instructions.cc	/^void neg_impl( const ptx_instruction *pI, ptx_thread_info *thread ) $/;"	f
nesting_level	tm_manager.h	/^   unsigned nesting_level() { return m_nesting_level;}$/;"	f	class:tm_manager_inf
next_instr	ptx_sim.h	/^   unsigned next_instr()$/;"	f	class:ptx_thread_info
next_reg_num	ptx_ir.h	/^   unsigned next_reg_num() { return ++m_reg_allocator;}$/;"	f	class:symbol_table
nop_impl	instructions.cc	/^void nop_impl( const ptx_instruction *pI, ptx_thread_info *thread ) $/;"	f
norn_impl	instructions.cc	/^void norn_impl( const ptx_instruction *pI, ptx_thread_info *thread ) $/;"	f
not_impl	instructions.cc	/^void not_impl( const ptx_instruction *pI, ptx_thread_info *thread ) $/;"	f
num_args	ptx_ir.h	/^   unsigned num_args() const$/;"	f	class:function_info
num_reconvergence_pairs	ptx_ir.h	/^   unsigned num_reconvergence_pairs;$/;"	m	class:function_info
num_threads	ptx_sim.cc	/^unsigned ptx_cta_info::num_threads() const$/;"	f	class:ptx_cta_info
offset	ptx_sim.h	/^   size_t offset;$/;"	m	struct:param_t
op_iter_begin	ptx_ir.h	/^   const_iterator op_iter_begin() const $/;"	f	class:ptx_instruction
op_iter_end	ptx_ir.h	/^   const_iterator op_iter_end() const $/;"	f	class:ptx_instruction
opcode_initiation_dp	cuda-sim.cc	/^char *opcode_initiation_int, *opcode_initiation_fp, *opcode_initiation_dp;$/;"	v
opcode_initiation_fp	cuda-sim.cc	/^char *opcode_initiation_int, *opcode_initiation_fp, *opcode_initiation_dp;$/;"	v
opcode_initiation_int	cuda-sim.cc	/^char *opcode_initiation_int, *opcode_initiation_fp, *opcode_initiation_dp;$/;"	v
opcode_latency_dp	cuda-sim.cc	/^char *opcode_latency_int, *opcode_latency_fp, *opcode_latency_dp;$/;"	v
opcode_latency_fp	cuda-sim.cc	/^char *opcode_latency_int, *opcode_latency_fp, *opcode_latency_dp;$/;"	v
opcode_latency_int	cuda-sim.cc	/^char *opcode_latency_int, *opcode_latency_fp, *opcode_latency_dp;$/;"	v
opcode_spec	ptx.y	/^opcode_spec: OPCODE { add_opcode($1); } option_list$/;"	l
opcode_t	opcodes.h	/^enum opcode_t {$/;"	g
opcodes_h_included	opcodes.h	29;"	d
operand	ptx.y	/^operand: IDENTIFIER  { add_scalar_operand( $1 ); }$/;"	l
operand_info	ptx_ir.h	/^   operand_info( const symbol *addr )$/;"	f	class:operand_info
operand_info	ptx_ir.h	/^   operand_info( const symbol *addr, int offset )$/;"	f	class:operand_info
operand_info	ptx_ir.h	/^   operand_info( const symbol *addr1, const symbol *addr2 )$/;"	f	class:operand_info
operand_info	ptx_ir.h	/^   operand_info( const symbol *s1, const symbol *s2, const symbol *s3, const symbol *s4 )$/;"	f	class:operand_info
operand_info	ptx_ir.h	/^   operand_info( double x )$/;"	f	class:operand_info
operand_info	ptx_ir.h	/^   operand_info( float x )$/;"	f	class:operand_info
operand_info	ptx_ir.h	/^   operand_info( int builtin_id, int dim_mod )$/;"	f	class:operand_info
operand_info	ptx_ir.h	/^   operand_info( int x )$/;"	f	class:operand_info
operand_info	ptx_ir.h	/^   operand_info( unsigned x )$/;"	f	class:operand_info
operand_info	ptx_ir.h	/^   operand_info()$/;"	f	class:operand_info
operand_info	ptx_ir.h	/^class operand_info {$/;"	c
operand_list	ptx.y	/^operand_list: operand$/;"	l
operand_lookup	ptx_ir.h	/^   const operand_info &operand_lookup( unsigned n ) const$/;"	f	class:ptx_instruction
operand_type	ptx_ir.h	/^enum operand_type {$/;"	g
operator ()	ptx-stats.cc	/^    std::size_t operator()(const ptx_file_line & pfline) const {$/;"	f	struct:hash_ptx_file_line
operator ()	ptx_ir.h	/^   bool operator()( const type_info_key &a, const type_info_key &b ) const$/;"	f	struct:type_info_key_compare
operator <	ptx-stats.cc	/^    bool operator<(const ptx_file_line &other) const {$/;"	f	class:ptx_file_line
operator =	bloomfilter.cc	/^bloomfilter& bloomfilter::operator=(const bloomfilter& other)$/;"	f	class:bloomfilter
operator =	bloomfilter.cc	/^bloomfilter_mt& bloomfilter_mt::operator=(const bloomfilter_mt& other)$/;"	f	class:bloomfilter_mt
operator =	bloomfilter.cc	/^versioning_bloomfilter& versioning_bloomfilter::operator=(const versioning_bloomfilter& other)$/;"	f	class:versioning_bloomfilter
operator =	ptx_ir.h	/^   void operator=( const arg_buffer_t &another )$/;"	f	class:arg_buffer_t
operator ==	ptx-stats.cc	/^    bool operator==(const ptx_file_line &other) const {$/;"	f	class:ptx_file_line
operator unsigned char	ptx_sim.h	/^   operator unsigned char() { return u8;}$/;"	f	union:ptx_reg_t
operator unsigned int	ptx_sim.h	/^   operator unsigned int() { return u32;}$/;"	f	union:ptx_reg_t
operator unsigned long long	ptx_sim.h	/^   operator unsigned long long() { return u64;}$/;"	f	union:ptx_reg_t
operator unsigned short	ptx_sim.h	/^   operator unsigned short() { return u16;}$/;"	f	union:ptx_reg_t
option	ptx.y	/^option: type_spec$/;"	l
option_list	ptx.y	/^option_list: option$/;"	l
or_impl	instructions.cc	/^void or_impl( const ptx_instruction *pI, ptx_thread_info *thread ) $/;"	f
orn_impl	instructions.cc	/^void orn_impl( const ptx_instruction *pI, ptx_thread_info *thread ) $/;"	f
owned_addr	tm_manager.h	/^   std::map<addr_t, unsigned> owned_addr;$/;"	m	class:tm_manager_inf
param_entry	ptx.y	/^param_entry: PARAM_DIRECTIVE { add_space_spec(param_space_unclassified,0); } variable_spec ptr_spec identifier_spec { add_function_arg(); }$/;"	l
param_info	ptx_ir.h	/^   param_info( std::string name, int type, size_t size, bool is_ptr, memory_space_t ptr_space ) $/;"	f	class:param_info
param_info	ptx_ir.h	/^   param_info() { m_valid = false; m_value_set=false; m_size = 0; m_is_ptr = false; }$/;"	f	class:param_info
param_info	ptx_ir.h	/^class param_info {$/;"	c
param_list	ptx.y	/^param_list: \/*empty*\/$/;"	l
param_t	ptx_sim.h	/^struct param_t {$/;"	s
param_to_shared	cuda-sim.cc	/^void function_info::param_to_shared( memory_space *shared_mem, symbol_table *symtab ) $/;"	f	class:function_info
parse_assert	ptx_parser.cc	214;"	d	file:
parse_assert_impl	ptx_parser.cc	/^void parse_assert_impl( int test_value, const char *file, unsigned line, const char *msg, ... )$/;"	f
parse_error	ptx_parser.cc	213;"	d	file:
parse_error_impl	ptx_parser.cc	/^void parse_error_impl( const char *file, unsigned line, const char *msg, ... )$/;"	f
passed	bloomfilter.cc	/^void passed(const char *test_name, bool condition) $/;"	f
pc_to_instruction	ptx_ir.h	/^   static const ptx_instruction* pc_to_instruction(unsigned pc) $/;"	f	class:function_info
pdata	ptx_sim.h	/^   const void *pdata;$/;"	m	struct:param_t
pdom	ptx_ir.h	/^   bool pdom(const basic_block_t *B) {$/;"	f	struct:basic_block_t
pmevent_impl	instructions.cc	/^void pmevent_impl( const ptx_instruction *pI, ptx_thread_info *thread ) { inst_not_implemented(pI); }$/;"	f
pop_breakaddr	ptx_sim.cc	/^const operand_info& ptx_thread_info::pop_breakaddr() $/;"	f	class:ptx_thread_info
popc_impl	instructions.cc	/^void popc_impl( const ptx_instruction *pI, ptx_thread_info *thread ) $/;"	f
postdominator_ids	ptx_ir.h	/^   std::set<int> postdominator_ids;$/;"	m	struct:basic_block_t
pre_decode	cuda-sim.cc	/^void ptx_instruction::pre_decode()$/;"	f	class:ptx_instruction
pred_lookup	decuda_pred_table/decuda_pred_table.cc	/^bool pred_lookup(int condition, int flags)$/;"	f
pred_spec	ptx.y	/^pred_spec: PRED IDENTIFIER  { add_pred($2,0, -1); }$/;"	l
predecessor_ids	ptx_ir.h	/^   std::set<int> predecessor_ids; \/\/indices of other basic blocks in m_basic_blocks array$/;"	m	struct:basic_block_t
prefetch_impl	instructions.cc	/^void prefetch_impl( const ptx_instruction *pI, ptx_thread_info *thread ) { inst_not_implemented(pI); }$/;"	f
prefetchu_impl	instructions.cc	/^void prefetchu_impl( const ptx_instruction *pI, ptx_thread_info *thread ) { inst_not_implemented(pI); }$/;"	f
print	bloomfilter.cc	/^void bloomfilter::print(FILE *fout) const$/;"	f	class:bloomfilter
print	bloomfilter.cc	/^void hashtable_bits<sig_limit>::print(FILE *fout) const$/;"	f	class:hashtable_bits
print	bloomfilter.cc	/^void hashtable_bits_mt::print(FILE *fout) const$/;"	f	class:hashtable_bits_mt
print	bloomfilter.cc	/^void hashtable_counter::print(FILE *fout) const $/;"	f	class:hashtable_counter
print	bloomfilter.cc	/^void versioning_bloomfilter::print(FILE *fout) const$/;"	f	class:versioning_bloomfilter
print	bloomfilter.cc	/^void versioning_hashtable::print(FILE *fout) const $/;"	f	class:versioning_hashtable
print	memory.cc	/^template<unsigned BSIZE> void memory_space_impl<BSIZE>::print( const char *format, FILE *fout ) const$/;"	f	class:memory_space_impl
print	memory.h	/^   void print( const char *format, FILE *fout ) const$/;"	f	class:mem_storage
print	tm_manager.cc	/^void ring_tm_manager::print(FILE *fout)$/;"	f	class:ring_tm_manager
print	tm_manager.cc	/^void tm_global_statistics::print(FILE *fout) $/;"	f	class:tm_global_statistics
print	tm_manager.cc	/^void tm_manager::access_record::print(FILE *fout) $/;"	f	class:tm_manager::access_record
print	tm_manager.cc	/^void tm_ring_commit_record::print(FILE *fout) const $/;"	f	class:tm_ring_commit_record
print	tm_manager.cc	/^void tm_ring_global::print(FILE *fout) const $/;"	f	class:tm_ring_global
print	tm_manager.cc	/^void tm_ring_stats::print(FILE *fout)$/;"	f	class:tm_ring_stats
print_basic_block_dot	ptx_ir.cc	/^void function_info::print_basic_block_dot()$/;"	f	class:function_info
print_basic_block_links	ptx_ir.cc	/^void function_info::print_basic_block_links()$/;"	f	class:function_info
print_basic_blocks	ptx_ir.cc	/^void function_info::print_basic_blocks()$/;"	f	class:function_info
print_counters	bloomfilter.cc	/^void hashtable_counter::print_counters(FILE *fout) const $/;"	f	class:hashtable_counter
print_dominators	ptx_ir.cc	/^void function_info::print_dominators()$/;"	f	class:function_info
print_idominators	ptx_ir.cc	/^void function_info::print_idominators()$/;"	f	class:function_info
print_info	ptx_ir.cc	/^void symbol::print_info(FILE *fp) const$/;"	f	class:symbol
print_insn	ptx_ir.cc	/^unsigned function_info::print_insn( unsigned pc, FILE * fp ) const$/;"	f	class:function_info
print_insn	ptx_ir.cc	/^void ptx_instruction::print_insn( FILE *fp ) const$/;"	f	class:ptx_instruction
print_insn	ptx_ir.cc	/^void ptx_instruction::print_insn() const$/;"	f	class:ptx_instruction
print_insn	ptx_sim.cc	/^void ptx_thread_info::print_insn( unsigned pc, FILE * fp ) const$/;"	f	class:ptx_thread_info
print_ipostdominators	ptx_ir.cc	/^void function_info::print_ipostdominators()$/;"	f	class:function_info
print_postdominators	ptx_ir.cc	/^void function_info::print_postdominators()$/;"	f	class:function_info
print_ptx_file	ptx_loader.cc	/^void print_ptx_file( const char *p, unsigned source_num, const char *filename )$/;"	f
print_ptxinfo	cuda-sim.cc	/^void print_ptxinfo()$/;"	f
print_read_write_set	tm_manager.cc	/^void tm_manager::print_read_write_set(FILE *fp)$/;"	f	class:tm_manager
print_reg	ptx_sim.cc	/^static void print_reg( FILE *fp, std::string name, ptx_reg_t value, symbol_table *symtab )$/;"	f	file:
print_reg	ptx_sim.cc	/^static void print_reg( std::string name, ptx_reg_t value, symbol_table *symtab )$/;"	f	file:
print_resource_usage	tm_manager.cc	/^void tm_global_state::print_resource_usage( FILE *fout ) $/;"	f	class:tm_global_state
print_set	ptx_ir.cc	/^void print_set(const std::set<int> &A)$/;"	f
print_short	tm_manager.cc	/^void tm_global_statistics::print_short(FILE *fout) $/;"	f	class:tm_global_statistics
print_splash	cuda-sim.cc	/^void print_splash()$/;"	f
print_tm_mem	tm_manager.cc	/^void tm_manager::print_tm_mem(FILE *fp){$/;"	f	class:tm_manager
prmt_impl	instructions.cc	/^void prmt_impl( const ptx_instruction *pI, ptx_thread_info *thread ) { inst_not_implemented(pI); }$/;"	f
ptr_align_spec	ptx.y	/^ptr_align_spec: ALIGN_DIRECTIVE INT_OPERAND$/;"	l
ptr_space_spec	ptx.y	/^ptr_space_spec: GLOBAL_DIRECTIVE { add_ptr_spec(global_space); }$/;"	l
ptr_spec	ptx.y	/^ptr_spec: \/*empty*\/$/;"	l
ptx_assemble	cuda-sim.cc	/^void function_info::ptx_assemble()$/;"	f	class:function_info
ptx_begin	ptx_ir.h	/^   ptx_instruction* ptx_begin;$/;"	m	struct:basic_block_t
ptx_cta_info	ptx_sim.cc	/^ptx_cta_info::ptx_cta_info( unsigned sm_idx )$/;"	f	class:ptx_cta_info
ptx_cta_info	ptx_sim.h	/^class ptx_cta_info {$/;"	c
ptx_debug_exec_dump_cond	cuda-sim.cc	/^bool ptx_debug_exec_dump_cond(int thd_uid, addr_t pc)$/;"	f
ptx_end	ptx_ir.h	/^   ptx_instruction* ptx_end;$/;"	m	struct:basic_block_t
ptx_exec_inst	cuda-sim.cc	/^void ptx_thread_info::ptx_exec_inst( warp_inst_t &inst, unsigned lane_id)$/;"	f	class:ptx_thread_info
ptx_fetch_inst	cuda-sim.cc	/^const warp_inst_t *ptx_fetch_inst( address_type pc )$/;"	f
ptx_fetch_inst	cuda-sim.cc	/^void ptx_thread_info::ptx_fetch_inst( inst_t &inst ) const$/;"	f	class:ptx_thread_info
ptx_file_line	ptx-stats.cc	/^    ptx_file_line(const char* s, int l) {$/;"	f	class:ptx_file_line
ptx_file_line	ptx-stats.cc	/^class ptx_file_line $/;"	c	file:
ptx_file_line_stats	ptx-stats.cc	/^    ptx_file_line_stats() $/;"	f	class:ptx_file_line_stats
ptx_file_line_stats	ptx-stats.cc	/^class ptx_file_line_stats$/;"	c	file:
ptx_file_line_stats_add_dram_traffic	ptx-stats.cc	/^void ptx_file_line_stats_add_dram_traffic(unsigned pc, unsigned dram_traffic)$/;"	f
ptx_file_line_stats_add_exec_count	ptx-stats.cc	/^void ptx_file_line_stats_add_exec_count(const ptx_instruction *pInsn)$/;"	f
ptx_file_line_stats_add_inflight_memory_insn	ptx-stats.cc	/^void ptx_file_line_stats_add_inflight_memory_insn(int sc_id, unsigned pc)$/;"	f
ptx_file_line_stats_add_latency	ptx-stats.cc	/^void ptx_file_line_stats_add_latency(unsigned pc, unsigned latency)$/;"	f
ptx_file_line_stats_add_smem_bank_conflict	ptx-stats.cc	/^void ptx_file_line_stats_add_smem_bank_conflict(unsigned pc, unsigned n_way_bkconflict)$/;"	f
ptx_file_line_stats_add_uncoalesced_gmem	ptx-stats.cc	/^void ptx_file_line_stats_add_uncoalesced_gmem(unsigned pc, unsigned n_access)$/;"	f
ptx_file_line_stats_add_warp_divergence	ptx-stats.cc	/^void ptx_file_line_stats_add_warp_divergence(unsigned pc, unsigned n_way_divergence)$/;"	f
ptx_file_line_stats_commit_exposed_latency	ptx-stats.cc	/^void ptx_file_line_stats_commit_exposed_latency(int sc_id, int exposed_latency)$/;"	f
ptx_file_line_stats_create_exposed_latency_tracker	ptx-stats.cc	/^void ptx_file_line_stats_create_exposed_latency_tracker(int n_shader_cores)$/;"	f
ptx_file_line_stats_map_t	ptx-stats.cc	/^typedef tr1_hash_map<ptx_file_line, ptx_file_line_stats, hash_ptx_file_line> ptx_file_line_stats_map_t;$/;"	t	file:
ptx_file_line_stats_map_t	ptx-stats.cc	/^typedef tr1_hash_map<ptx_file_line, ptx_file_line_stats> ptx_file_line_stats_map_t;$/;"	t	file:
ptx_file_line_stats_options	ptx-stats.cc	/^void ptx_file_line_stats_options(option_parser_t opp)$/;"	f
ptx_file_line_stats_sub_inflight_memory_insn	ptx-stats.cc	/^void ptx_file_line_stats_sub_inflight_memory_insn(int sc_id, unsigned pc)$/;"	f
ptx_file_line_stats_tracker	ptx-stats.cc	/^static ptx_file_line_stats_map_t ptx_file_line_stats_tracker;$/;"	v	file:
ptx_file_line_stats_write_file	ptx-stats.cc	/^void ptx_file_line_stats_write_file()$/;"	f
ptx_get_insn_str	cuda-sim.cc	/^std::string ptx_get_insn_str( address_type pc )$/;"	f
ptx_inflight_memory_insn_tracker	ptx-stats.cc	/^class ptx_inflight_memory_insn_tracker$/;"	c	file:
ptx_inflight_memory_insns	ptx-stats.cc	/^    insn_count_map ptx_inflight_memory_insns;$/;"	m	class:ptx_inflight_memory_insn_tracker	file:
ptx_instruction	ptx_ir.cc	/^ptx_instruction::ptx_instruction( int opcode, $/;"	f	class:ptx_instruction
ptx_instruction	ptx_ir.h	/^class ptx_instruction : public warp_inst_t {$/;"	c
ptx_instruction_lookup	ptx_parser.cc	/^const ptx_instruction *ptx_instruction_lookup( const char *filename, unsigned linenumber )$/;"	f
ptx_ir_INCLUDED	ptx_ir.h	29;"	d
ptx_kernel_nregs	ptx_ir.cc	/^unsigned ptx_kernel_nregs( void *kernel_impl )$/;"	f
ptx_kernel_shmem_size	ptx_ir.cc	/^unsigned ptx_kernel_shmem_size( void *kernel_impl )$/;"	f
ptx_line_stats_filename	ptx-stats.cc	/^char * ptx_line_stats_filename = NULL;$/;"	v
ptx_opcocde_latency_options	cuda-sim.cc	/^void ptx_opcocde_latency_options (option_parser_t opp) {$/;"	f
ptx_parser_INCLUDED	ptx_parser.h	29;"	d
ptx_print_insn	cuda-sim.cc	/^void ptx_print_insn( address_type pc, FILE *fp )$/;"	f
ptx_reg_options	ptx_loader.cc	/^void ptx_reg_options(option_parser_t opp)$/;"	f
ptx_reg_t	ptx_sim.h	/^   ptx_reg_t() {$/;"	f	union:ptx_reg_t
ptx_reg_t	ptx_sim.h	/^   ptx_reg_t(unsigned x) $/;"	f	union:ptx_reg_t
ptx_reg_t	ptx_sim.h	/^union ptx_reg_t {$/;"	u
ptx_round	instructions.cc	/^void ptx_round(ptx_reg_t& data, int rounding_mode, int type)$/;"	f
ptx_saturate	instructions.cc	/^void ptx_saturate(ptx_reg_t& data, int saturation_mode, int type)$/;"	f
ptx_sim_h_INCLUDED	ptx_sim.h	28;"	d
ptx_sim_init_thread	cuda-sim.cc	/^unsigned ptx_sim_init_thread( kernel_info_t &kernel,$/;"	f
ptx_sim_kernel_info	cuda-sim.cc	/^const struct gpgpu_ptx_sim_kernel_info* ptx_sim_kernel_info(const function_info *kernel) $/;"	f
ptx_tex_regs	instructions.cc	/^ptx_reg_t* ptx_tex_regs = NULL;$/;"	v
ptx_thread_info	ptx_sim.cc	/^ptx_thread_info::ptx_thread_info( kernel_info_t &kernel )$/;"	f	class:ptx_thread_info
ptx_thread_info	ptx_sim.h	/^class ptx_thread_info {$/;"	c
ptx_version	ptx_sim.h	/^      ptx_version()$/;"	f	class:ptx_version
ptx_version	ptx_sim.h	/^      ptx_version(float ver, unsigned extensions)$/;"	f	class:ptx_version
ptx_version	ptx_sim.h	/^class ptx_version {$/;"	c
ptxinfo_cmem	cuda-sim.cc	/^void ptxinfo_cmem( unsigned nbytes, unsigned bank )$/;"	f
ptxinfo_function	cuda-sim.cc	/^void ptxinfo_function(const char *fname )$/;"	f
ptxinfo_lmem	cuda-sim.cc	/^void ptxinfo_lmem( unsigned declared, unsigned system )$/;"	f
ptxinfo_opencl_addinfo	cuda-sim.cc	/^void ptxinfo_opencl_addinfo( std::map<std::string,function_info*> &kernels )$/;"	f
ptxinfo_regs	cuda-sim.cc	/^void ptxinfo_regs( unsigned nregs )$/;"	f
ptxinfo_smem	cuda-sim.cc	/^void ptxinfo_smem( unsigned declared, unsigned system )$/;"	f
push_breakaddr	ptx_sim.cc	/^void ptx_thread_info::push_breakaddr(const operand_info &breakaddr) $/;"	f	class:ptx_thread_info
rcp_impl	instructions.cc	/^void rcp_impl( const ptx_instruction *pI, ptx_thread_info *thread ) $/;"	f
read	memory.cc	/^template<unsigned BSIZE> void memory_space_impl<BSIZE>::read( mem_addr_t addr, size_t length, void *data ) const$/;"	f	class:memory_space_impl
read	memory.h	/^   void read( unsigned offset, size_t length, unsigned char *data ) const$/;"	f	class:mem_storage
read_only	tm_manager_internal.h	/^   bool read_only() const { return (!m_tuids_have_read.empty() && m_tuids_have_written.empty()); }$/;"	f	struct:conflict_set
read_parser_environment_variables	ptx_parser.cc	/^void read_parser_environment_variables() $/;"	f
read_sim_environment_variables	cuda-sim.cc	/^void read_sim_environment_variables() $/;"	f
read_single_block	memory.cc	/^template<unsigned BSIZE> void memory_space_impl<BSIZE>::read_single_block( mem_addr_t blk_idx, mem_addr_t addr, size_t length, void *data) const$/;"	f	class:memory_space_impl
rec_pts	cuda-sim.cc	/^struct rec_pts {$/;"	s	file:
record_abort_at_address	tm_manager.cc	/^void tm_global_statistics::record_abort_at_address(addr_t addr, const conflict_set& cs) $/;"	f	class:tm_global_statistics
record_abort_tx_size	tm_manager_internal.h	/^    void record_abort_tx_size(size_t read_size, size_t write_size, size_t access_size) {$/;"	f	class:tm_global_statistics
record_commit_tx_size	tm_manager_internal.h	/^    void record_commit_tx_size(size_t read_size, size_t write_size, size_t access_size) {$/;"	f	class:tm_global_statistics
record_false_conflict_info	tm_manager_internal.h	/^    void record_false_conflict_info(size_t aborter_size, size_t abortee_size) {$/;"	f	class:tm_global_statistics
record_raw_info	tm_manager_internal.h	/^    void record_raw_info(size_t footprint, unsigned n_accesses) {$/;"	f	class:tm_global_statistics
record_tx_blockcount	tm_manager.cc	/^void tm_global_statistics::record_tx_blockcount(const addr_set_t& read_set_block, $/;"	f	class:tm_global_statistics
red_impl	instructions.cc	/^void red_impl( const ptx_instruction *pI, ptx_thread_info *thread ) { inst_not_implemented(pI); }$/;"	f
reduce_precision	instructions.cc	/^float reduce_precision( float x, unsigned bits )$/;"	f
reg1_num	ptx_ir.h	/^   int reg1_num() const { return m_value.m_vector_symbolic[0]->reg_num();}$/;"	f	class:operand_info
reg2_num	ptx_ir.h	/^   int reg2_num() const { return m_value.m_vector_symbolic[1]->reg_num();}$/;"	f	class:operand_info
reg3_num	ptx_ir.h	/^   int reg3_num() const { return m_value.m_vector_symbolic[2]?m_value.m_vector_symbolic[2]->reg_num():0; }$/;"	f	class:operand_info
reg4_num	ptx_ir.h	/^   int reg4_num() const { return m_value.m_vector_symbolic[3]?m_value.m_vector_symbolic[3]->reg_num():0; }$/;"	f	class:operand_info
reg_map_t	ptx_sim.h	/^   typedef tr1_hash_map<const symbol*,ptx_reg_t> reg_map_t;$/;"	t	class:ptx_thread_info
reg_num	ptx_ir.h	/^   int reg_num() const { return m_value.m_symbolic->reg_num();}$/;"	f	class:operand_info
reg_num	ptx_ir.h	/^   unsigned reg_num() const$/;"	f	class:symbol
reg_options	bloomfilter.cc	/^void bloomfilter_mt::reg_options(option_parser_t opp)$/;"	f	class:bloomfilter_mt
reg_options	bloomfilter.cc	/^void hashtable_bits_mt::reg_options(option_parser_t opp)$/;"	f	class:hashtable_bits_mt
reg_options	tm_manager.cc	/^void tm_bloomfilter_hashed_core_set::reg_options(option_parser_t opp)$/;"	f	class:tm_bloomfilter_hashed_core_set
reg_options	tm_manager.cc	/^void tm_bloomfilter_options::reg_options(option_parser_t opp)$/;"	f	class:tm_bloomfilter_options
reg_options	tm_manager.cc	/^void tm_options::reg_options(option_parser_t opp)$/;"	f	class:tm_options
reg_t	ptx_ir.h	/^   reg_t, vector_t, builtin_t, address_t, memory_t, float_op_t, double_op_t, int_t, $/;"	e	enum:operand_type
registerExit	ptx_sim.h	/^   void registerExit(){m_cta_info->register_thread_exit(this);}$/;"	f	class:ptx_thread_info
register_deleted_thread	ptx_sim.cc	/^void ptx_cta_info::register_deleted_thread( ptx_thread_info *thd )$/;"	f	class:ptx_cta_info
register_thread	tm_manager.cc	/^void tm_global_state::register_thread( ptx_thread_info *thrd )$/;"	f	class:tm_global_state
register_thread_exit	ptx_sim.cc	/^void ptx_cta_info::register_thread_exit( ptx_thread_info *thd )$/;"	f	class:ptx_cta_info
rem_impl	instructions.cc	/^void rem_impl( const ptx_instruction *pI, ptx_thread_info *thread ) $/;"	f
remove	bloomfilter.cc	/^template<int sig_limit> void hashtable_bits<sig_limit>::remove(addr_t addr) { assert(0); }  $/;"	f	class:hashtable_bits
remove	bloomfilter.cc	/^template<int sig_limit> void hashtable_bits<sig_limit>::remove(const hashtable& signature) { assert(0); }  $/;"	f	class:hashtable_bits
remove	bloomfilter.cc	/^void bloomfilter::remove(addr_t addr)$/;"	f	class:bloomfilter
remove	bloomfilter.cc	/^void bloomfilter::remove(const bloomfilter& signature)$/;"	f	class:bloomfilter
remove	bloomfilter.cc	/^void hashtable_bits_mt::remove(addr_t addr) { assert(0); } $/;"	f	class:hashtable_bits_mt
remove	bloomfilter.cc	/^void hashtable_bits_mt::remove(const hashtable& signature) { assert(0); }$/;"	f	class:hashtable_bits_mt
remove	bloomfilter.cc	/^void hashtable_counter::remove(addr_t addr)$/;"	f	class:hashtable_counter
remove	bloomfilter.cc	/^void hashtable_counter::remove(const hashtable& signature)$/;"	f	class:hashtable_counter
remove_access_set	tm_manager.cc	/^void tm_bloomfilter_core_set::remove_access_set(const bloomfilter &thread_access_set) $/;"	f	class:tm_bloomfilter_core_set
remove_args	ptx_ir.h	/^   void remove_args()$/;"	f	class:function_info
remove_test	bloomfilter.cc	/^bool remove_test(unsigned int size, const std::vector<int>& funct_ids)$/;"	f
remove_test	bloomfilter.cc	/^bool remove_test(unsigned int size, int funct_id)$/;"	f
remove_tuid	tm_manager.cc	/^void tm_global_state::remove_tuid( unsigned tuid, const addr_set_t &read_set, const addr_set_t &write_set )$/;"	f	class:tm_global_state
reset	tm_manager_internal.h	/^      void reset() {$/;"	f	class:value_based_tm_manager::temporal_cd_metadata
reset_symtab	ptx_parser.cc	/^void *reset_symtab()$/;"	f
ret_impl	instructions.cc	/^void ret_impl( const ptx_instruction *pI, ptx_thread_info *thread ) $/;"	f
retainMax	tm_manager.cc	/^void retainMax(T& max_value, T test_value)$/;"	f
retp_impl	instructions.cc	/^void retp_impl( const ptx_instruction *pI, ptx_thread_info *thread )$/;"	f
ring_index	tm_manager_internal.h	/^   int ring_index() const { return m_ring_index; }$/;"	f	class:tm_ring_global
ring_t	tm_manager_internal.h	/^   typedef std::deque<tm_ring_commit_record> ring_t; $/;"	t	class:tm_ring_global
ring_tm_access	tm_manager.cc	/^void ring_tm_manager::ring_tm_access(addr_t addr, int nbytes, bool rd)$/;"	f	class:ring_tm_manager
ring_tm_eager_conflict_resolution	tm_manager.cc	/^bool ring_tm_manager::ring_tm_eager_conflict_resolution(bool rd)$/;"	f	class:ring_tm_manager
ring_tm_manager	tm_manager.cc	/^ring_tm_manager::ring_tm_manager( ptx_thread_info *thread, bool timing_mode )$/;"	f	class:ring_tm_manager
ring_tm_manager	tm_manager_internal.h	/^class ring_tm_manager : public tm_manager $/;"	c
rollback_callback	cuda-sim.h	/^    virtual void rollback_callback(unsigned thread_id, unsigned warp_id, address_type pc) { }$/;"	f	class:functionalCoreSim
rounding_mode	ptx.y	/^rounding_mode: floating_point_rounding_mode$/;"	l
rounding_mode	ptx_ir.h	/^   unsigned rounding_mode() const { return m_rounding_mode;}$/;"	f	class:ptx_instruction
rpc_updated	ptx_sim.h	/^   bool rpc_updated() const { return m_RPC_updated; }$/;"	f	class:ptx_thread_info
rsqrt_impl	instructions.cc	/^void rsqrt_impl( const ptx_instruction *pI, ptx_thread_info *thread ) $/;"	f
s16	ptx_sim.h	/^   signed short      s16;$/;"	m	union:ptx_reg_t
s2f	instructions.cc	/^ptx_reg_t s2f( ptx_reg_t x, unsigned from_width, unsigned to_width, int to_sign, int rounding_mode, int saturation_mode )$/;"	f
s32	ptx_sim.h	/^   signed int        s32;$/;"	m	union:ptx_reg_t
s64	ptx_sim.h	/^   signed long long  s64;$/;"	m	union:ptx_reg_t
s8	ptx_sim.h	/^   signed char       s8;$/;"	m	union:ptx_reg_t
s_g_pc_to_insn	cuda-sim.cc	/^std::vector<ptx_instruction*> function_info::s_g_pc_to_insn;$/;"	m	class:function_info	file:
s_g_pc_to_insn	ptx_ir.h	/^   static std::vector<ptx_instruction*> s_g_pc_to_insn; \/\/ a direct mapping from PC to instruction$/;"	m	class:function_info
s_kernel_recon_points	cuda-sim.cc	/^   gpgpu_recon_t *s_kernel_recon_points;$/;"	m	struct:rec_pts	file:
s_logical_temporal_conflict_detector	tm_manager.cc	/^logical_temporal_conflict_detector * logical_temporal_conflict_detector::s_logical_temporal_conflict_detector = NULL;$/;"	m	class:logical_temporal_conflict_detector	file:
s_logical_temporal_conflict_detector	tm_manager_internal.h	/^   static logical_temporal_conflict_detector * s_logical_temporal_conflict_detector; $/;"	m	class:logical_temporal_conflict_detector
s_n_tid_subhash	bloomfilter.cc	/^int hashtable_bits_mt::s_n_tid_subhash = 1; $/;"	m	class:hashtable_bits_mt	file:
s_n_tid_subhash	bloomfilter.h	/^   static int s_n_tid_subhash;$/;"	m	class:hashtable_bits_mt
s_non_hash_match	tm_manager_internal.h	/^   static const bool s_non_hash_match = false; $/;"	m	class:tm_bloomfilter_hashed_core_set
s_nthread_limit	bloomfilter.h	/^   static const int s_nthread_limit = 2048; $/;"	m	class:hashtable_bits_mt
s_null_tid	bloomfilter.h	/^   static const int s_null_tid = -1; $/;"	m	class:hashtable_bits_mt
s_nullpos	bloomfilter.cc	/^const int hashtable::s_nullpos = 0xDEADBEEF; $/;"	m	class:hashtable	file:
s_nullpos	bloomfilter.h	/^   static const int s_nullpos; $/;"	m	class:hashtable
s_num_recon	cuda-sim.cc	/^   int s_num_recon;$/;"	m	struct:rec_pts	file:
s_temporal_conflict_detector	tm_manager.cc	/^temporal_conflict_detector * temporal_conflict_detector::s_temporal_conflict_detector = NULL;$/;"	m	class:temporal_conflict_detector	file:
s_temporal_conflict_detector	tm_manager_internal.h	/^   static temporal_conflict_detector * s_temporal_conflict_detector; $/;"	m	class:temporal_conflict_detector
s_thread_hash_size	tm_manager.cc	/^unsigned int tm_bloomfilter_hashed_core_set::s_thread_hash_size = 32; $/;"	m	class:tm_bloomfilter_hashed_core_set	file:
s_thread_hash_size	tm_manager_internal.h	/^   static unsigned int s_thread_hash_size; $/;"	m	class:tm_bloomfilter_hashed_core_set
s_tid_hash_limit	bloomfilter.h	/^   static const int s_tid_hash_limit = 512; $/;"	m	class:hashtable_bits_mt
s_tid_hashvar	bloomfilter.cc	/^int bloomfilter_mt::s_tid_hashvar = 0; $/;"	m	class:bloomfilter_mt	file:
s_tid_hashvar	bloomfilter.h	/^   static int s_tid_hashvar; $/;"	m	class:bloomfilter_mt
sad_impl	instructions.cc	/^void sad_impl( const ptx_instruction *pI, ptx_thread_info *thread ) $/;"	f
sample_footprint	tm_manager.cc	/^void tm_global_statistics::sample_footprint()$/;"	f	class:tm_global_statistics
saturated2i	instructions.cc	/^double saturated2i (double a, double max, double min) {$/;"	f
saturatei	instructions.cc	/^int saturatei(int a, int max, int min) $/;"	f
saturatei	instructions.cc	/^unsigned int saturatei(unsigned int a, unsigned int max) $/;"	f
saturation_mode	ptx_ir.h	/^   unsigned saturation_mode() const { return m_saturation_mode;}$/;"	f	class:ptx_instruction
scalar_type	ptx.y	/^scalar_type: S8_TYPE { add_scalar_type_spec( S8_TYPE ); }$/;"	l
scalar_type	ptx_ir.h	/^   int  scalar_type() const { return m_scalar_type_spec;}$/;"	f	class:type_info_key
scaling_test	bloomfilter.cc	/^bool scaling_test(unsigned int size, int hashset, const std::vector<int>& funct_ids, int n_hashes, $/;"	f
select_thread	bloomfilter.cc	/^void bloomfilter_mt::select_thread(int thread_id)$/;"	f	class:bloomfilter_mt
select_thread	bloomfilter.h	/^   void select_thread(int thread_id) { $/;"	f	class:hashtable_bits_mt
selp_impl	instructions.cc	/^void selp_impl( const ptx_instruction *pI, ptx_thread_info *thread ) $/;"	f
set_PC	ptx_ir.h	/^   void set_PC( addr_t PC )$/;"	f	class:ptx_instruction
set_addr_space	ptx_ir.h	/^   void set_addr_space(enum _memory_space_t set_value) { m_addr_space = set_value; }$/;"	f	class:operand_info
set_address	ptx_ir.h	/^   void set_address( addr_t addr )$/;"	f	class:symbol
set_array_dim	ptx_ir.h	/^   void set_array_dim( int array_dim ) { m_array_dim = array_dim; }$/;"	f	class:type_info_key
set_bitpos	bloomfilter.cc	/^void bloomfilter::set_bitpos(const std::vector<int>& bitpos)$/;"	f	class:bloomfilter
set_bitpos	bloomfilter.cc	/^void hashtable_bits<sig_limit>::set_bitpos(unsigned int bitpos) $/;"	f	class:hashtable_bits
set_bitpos	bloomfilter.cc	/^void hashtable_bits_mt::set_bitpos(unsigned int bitpos) { assert(0); } $/;"	f	class:hashtable_bits_mt
set_bitpos	bloomfilter.cc	/^void hashtable_counter::set_bitpos(unsigned int bitpos)$/;"	f	class:hashtable_counter
set_const_mem_offset	ptx_ir.h	/^   void set_const_mem_offset(addr_t set_value) { m_const_mem_offset = set_value; }$/;"	f	class:operand_info
set_core_id	tm_manager_internal.h	/^   void set_core_id(int core_id) { assert(m_core_id == core_id || m_core_id == -1); m_core_id = core_id; } $/;"	f	class:tm_bloomfilter_hashed_core_set
set_core_set	tm_manager_internal.h	/^   void set_core_set(int core_id, tm_bloomfilter_core_set *core_bf) {$/;"	f	class:tm_bloomfilter_set
set_core_set	tm_manager_internal.h	/^   void set_core_set(tm_bloomfilter_core_set *core_bf) { assert(0); }$/;"	f	class:tm_bloomfilter_core_set
set_ctaid	ptx_sim.h	/^   void set_ctaid( dim3 ctaid ) { m_ctaid = ctaid; }$/;"	f	class:ptx_thread_info
set_done	ptx_sim.cc	/^void ptx_thread_info::set_done() $/;"	f	class:ptx_thread_info
set_double_operand_type	ptx_ir.h	/^   void set_double_operand_type(int set_value) {  m_double_operand_type = set_value; }$/;"	f	class:operand_info
set_first_read_time	tm_manager_internal.h	/^      void set_first_read_time( tm_timestamp_t new_time ) {$/;"	f	class:value_based_tm_manager::temporal_cd_metadata
set_fp_or_int_archop	cuda-sim.cc	/^void ptx_instruction::set_fp_or_int_archop(){$/;"	f	class:ptx_instruction
set_framesize	ptx_ir.h	/^   void set_framesize( unsigned sz )$/;"	f	class:function_info
set_function	ptx_ir.h	/^   void set_function( function_info *func )$/;"	f	class:symbol
set_immediate_addr	ptx_ir.h	/^   void set_immediate_addr() {m_immediate_address=true;}$/;"	f	class:operand_info
set_immediate_operand_type	ptx_parser.cc	/^void set_immediate_operand_type ()$/;"	f
set_impl	instructions.cc	/^void set_impl( const ptx_instruction *pI, ptx_thread_info *thread ) $/;"	f
set_info	ptx_sim.cc	/^void ptx_thread_info::set_info( function_info *func ) $/;"	f	class:ptx_thread_info
set_is_abort_need_clean	tm_manager.h	/^   virtual void set_is_abort_need_clean() { m_is_abort_need_clean = true; }$/;"	f	class:tm_manager_inf
set_is_func	ptx_ir.h	/^   void set_is_func()$/;"	f	class:type_info_key
set_is_non_arch_reg	ptx_ir.h	/^   void set_is_non_arch_reg() { m_is_non_arch_reg = true;  }$/;"	f	class:type_info_key
set_is_warp_level	tm_manager.h	/^   virtual void set_is_warp_level() { m_is_warp_level = true; }$/;"	f	class:tm_manager_inf
set_kernel_info	ptx_ir.h	/^   const void set_kernel_info (const struct gpgpu_ptx_sim_kernel_info &info) {$/;"	f	class:function_info
set_label_address	ptx_ir.cc	/^void symbol_table::set_label_address( const symbol *label, unsigned addr )$/;"	f	class:symbol_table
set_label_address	ptx_ir.h	/^   void set_label_address( addr_t addr)$/;"	f	class:symbol
set_m_instr_mem_index	ptx_ir.h	/^   void set_m_instr_mem_index(unsigned index) {$/;"	f	class:ptx_instruction
set_mul_div_or_other_archop	cuda-sim.cc	/^void ptx_instruction::set_mul_div_or_other_archop(){$/;"	f	class:ptx_instruction
set_name	ptx_ir.cc	/^void symbol_table::set_name( const char *name )$/;"	f	class:symbol_table
set_name	ptx_ir.h	/^   void set_name(const char *name)$/;"	f	class:function_info
set_nctaid	ptx_sim.h	/^   void set_nctaid( dim3 cta_size ) { m_nctaid = cta_size; }$/;"	f	class:ptx_thread_info
set_neg_pred	ptx_ir.h	/^   void set_neg_pred()$/;"	f	class:operand_info
set_npc	ptx_sim.cc	/^void ptx_thread_info::set_npc( const function_info *f )$/;"	f	class:ptx_thread_info
set_npc	ptx_sim.h	/^   void set_npc( unsigned npc )$/;"	f	class:ptx_thread_info
set_ntid	ptx_sim.h	/^   void set_ntid( dim3 tid ) { m_ntid = tid; }$/;"	f	class:ptx_thread_info
set_opcode_and_latency	cuda-sim.cc	/^void ptx_instruction::set_opcode_and_latency()$/;"	f	class:ptx_instruction
set_operand_lohi	ptx_ir.h	/^   void set_operand_lohi(int set_value) { m_operand_lohi = set_value; }$/;"	f	class:operand_info
set_operand_neg	ptx_ir.h	/^   void set_operand_neg() { m_operand_neg = true; }$/;"	f	class:operand_info
set_operand_value	instructions.cc	/^void ptx_thread_info::set_operand_value( const operand_info &dst, const ptx_reg_t &data, unsigned type, ptx_thread_info *thread, const ptx_instruction *pI )$/;"	f	class:ptx_thread_info
set_operand_value	instructions.cc	/^void ptx_thread_info::set_operand_value( const operand_info &dst, const ptx_reg_t &data, unsigned type, ptx_thread_info *thread, const ptx_instruction *pI, int overflow, int carry )$/;"	f	class:ptx_thread_info
set_param_gpgpu_num_shaders	cuda-sim.cc	/^void set_param_gpgpu_num_shaders(int num_shaders)$/;"	f
set_ptx_version	ptx_ir.cc	/^void symbol_table::set_ptx_version( float ver, unsigned ext ) $/;"	f	class:symbol_table
set_ptx_warp_size	ptx_parser.cc	/^void set_ptx_warp_size(const struct core_config * warp_size)$/;"	f
set_reg	instructions.cc	/^void ptx_thread_info::set_reg( const symbol *reg, const ptx_reg_t &value ) $/;"	f	class:ptx_thread_info
set_regno	ptx_ir.h	/^   void set_regno( unsigned regno, unsigned arch_regno )$/;"	f	class:symbol
set_return	ptx_ir.h	/^   void set_return() { m_is_return_var = true; }$/;"	f	class:operand_info
set_return	ptx_parser.cc	/^void set_return()$/;"	f
set_single_thread_single_block	ptx_sim.h	/^   void set_single_thread_single_block()$/;"	f	class:ptx_thread_info
set_sm_target	ptx_ir.cc	/^void symbol_table::set_sm_target( const char *target, const char *ext, const char *ext2 )$/;"	f	class:symbol_table
set_status	tm_manager_internal.h	/^   void set_status(enum tm_ring::status_t new_status) { m_status = new_status; } $/;"	f	class:tm_ring_commit_record
set_symtab	ptx_ir.h	/^   void set_symtab(symbol_table *symtab )$/;"	f	class:function_info
set_symtab	ptx_parser.cc	/^void set_symtab(void*symtab)$/;"	f
set_target	ptx_sim.h	/^      void set_target( const char *sm_ver, const char *ext, const char *ext2 ) $/;"	f	class:ptx_version
set_tid	ptx_sim.h	/^   void set_tid( dim3 tid ) { m_tid = tid; }$/;"	f	class:ptx_thread_info
set_tm_raw_info	tm_manager.cc	/^void tm_manager::set_tm_raw_info(addr_t addr, memory_space *mem, memory_space_t space, $/;"	f	class:tm_manager
set_type	ptx_ir.h	/^   void set_type( enum operand_type type ) $/;"	f	class:operand_info
set_valid	ptx_sim.h	/^   void set_valid() { m_valid = true;}$/;"	f	class:ptx_thread_info
set_variable_type	ptx_parser.cc	/^void set_variable_type()$/;"	f
set_vector_operand_values	instructions.cc	/^void ptx_thread_info::set_vector_operand_values( const operand_info &dst, $/;"	f	class:ptx_thread_info
set_warp_pts_current	tm_manager_internal.h	/^   void set_warp_pts_current(unsigned index, tm_timestamp_t time) { $/;"	f	class:logical_temporal_conflict_detector
set_watch	memory.cc	/^template<unsigned BSIZE> void memory_space_impl<BSIZE>::set_watch( addr_t addr, unsigned watchpoint ) $/;"	f	class:memory_space_impl
setp_impl	instructions.cc	/^void setp_impl( const ptx_instruction *pI, ptx_thread_info *thread ) $/;"	f
sexd	instructions.cc	/^ptx_reg_t sexd( ptx_reg_t x, unsigned from_width, unsigned to_width, int to_sign, int rounding_mode, int saturation_mode )$/;"	f
sext	instructions.cc	/^ptx_reg_t sext( ptx_reg_t x, unsigned from_width, unsigned to_width, int to_sign, int rounding_mode, int saturation_mode )$/;"	f
share_gmem_view	tm_manager_internal.h	/^   virtual void share_gmem_view( tm_manager_inf* other_tx ) {$/;"	f	class:tm_manager
shared_to_generic	cuda-sim.cc	/^addr_t shared_to_generic( unsigned smid, addr_t addr )$/;"	f
shl_impl	instructions.cc	/^void shl_impl( const ptx_instruction *pI, ptx_thread_info *thread ) $/;"	f
shr_impl	instructions.cc	/^void shr_impl( const ptx_instruction *pI, ptx_thread_info *thread )$/;"	f
sid	tm_manager.h	/^   unsigned sid() const { return m_thread_sc; }$/;"	f	class:tm_manager_inf
sig_t	bloomfilter.h	/^   typedef std::bitset<sig_limit> sig_t; $/;"	t	class:hashtable_bits
sign_extend	instructions.cc	/^void sign_extend( ptx_reg_t &data, unsigned src_size, const operand_info &dst )$/;"	f
signature_op_test	bloomfilter.cc	/^bool signature_op_test(unsigned int size, const std::vector<int>& funct_ids)$/;"	f
signature_op_test	bloomfilter.cc	/^bool signature_op_test(unsigned int size, int funct_id)$/;"	f
simplemod	hashfunc.h	/^inline unsigned int simplemod(unsigned int size, addr_t addr)$/;"	f	namespace:hasht_funct
sin_impl	instructions.cc	/^void sin_impl( const ptx_instruction *pI, ptx_thread_info *thread ) $/;"	f
size	bloomfilter.h	/^   unsigned int size() const { return m_size; } $/;"	f	class:hashtable
size	bloomfilter.h	/^   unsigned int size() const { return m_size; } $/;"	f	class:versioning_hashtable
size	bloomfilter.h	/^   unsigned int size() const { return m_size; }$/;"	f	class:bloomfilter
size	bloomfilter.h	/^   unsigned int size() const { return m_size; }$/;"	f	class:bloomfilter_mt
size	bloomfilter.h	/^   unsigned int size() const { return m_size; }$/;"	f	class:versioning_bloomfilter
size	ptx_sim.h	/^   size_t size;$/;"	m	struct:param_t
slct_impl	instructions.cc	/^void slct_impl( const ptx_instruction *pI, ptx_thread_info *thread ) $/;"	f
sm_next_uid	ptx_ir.cc	/^unsigned function_info::sm_next_uid = 1;$/;"	m	class:function_info	file:
sm_next_uid	ptx_ir.cc	/^unsigned operand_info::sm_next_uid=1;$/;"	m	class:operand_info	file:
sm_next_uid	ptx_ir.cc	/^unsigned symbol::sm_next_uid = 1;$/;"	m	class:symbol	file:
sm_next_uid	ptx_ir.h	/^   static unsigned sm_next_uid;$/;"	m	class:function_info
sm_next_uid	ptx_ir.h	/^   static unsigned sm_next_uid;$/;"	m	class:operand_info
sm_next_uid	ptx_ir.h	/^   static unsigned sm_next_uid;$/;"	m	class:symbol
smem_n_way_bank_conflict_total	ptx-stats.cc	/^    unsigned long long smem_n_way_bank_conflict_total;  \/\/ total number of banks accessed by this instruction$/;"	m	class:ptx_file_line_stats	file:
smem_warp_count	ptx-stats.cc	/^    unsigned long smem_warp_count;                      \/\/ number of warps accessing shared memory$/;"	m	class:ptx_file_line_stats	file:
source_file	ptx_ir.h	/^   const char *source_file() const { return m_source_file.c_str();} $/;"	f	class:ptx_instruction
source_inst	ptx_ir.h	/^   class ptx_instruction* source_inst;$/;"	m	struct:gpgpu_recon_t	typeref:class:gpgpu_recon_t::ptx_instruction
source_line	ptx_ir.h	/^   unsigned source_line() const { return m_source_line;}$/;"	f	class:ptx_instruction
source_pc	ptx_ir.h	/^   address_type source_pc;$/;"	m	struct:gpgpu_recon_t
space_spec	ptx.y	/^space_spec: REG_DIRECTIVE {  add_space_spec(reg_space,0); }$/;"	l
special_regs	opcodes.h	/^enum special_regs {$/;"	g
sqrt_impl	instructions.cc	/^void sqrt_impl( const ptx_instruction *pI, ptx_thread_info *thread ) $/;"	f
src1	ptx_ir.h	/^   const operand_info &src1() const $/;"	f	class:ptx_instruction
src2	ptx_ir.h	/^   const operand_info &src2() const $/;"	f	class:ptx_instruction
src3	ptx_ir.h	/^   const operand_info &src3() const $/;"	f	class:ptx_instruction
srcOperandModifiers	instructions.cc	/^ptx_reg_t srcOperandModifiers(ptx_reg_t opData, operand_info opInfo, operand_info dstInfo, unsigned type, ptx_thread_info *thread)$/;"	f
ssy_impl	instructions.cc	/^void ssy_impl( const ptx_instruction *pI, ptx_thread_info *thread ) $/;"	f
st	ptx-stats.cc	/^    std::string st;$/;"	m	class:ptx_file_line	file:
st_impl	instructions.cc	/^void st_impl( const ptx_instruction *pI, ptx_thread_info *thread ) $/;"	f
stack_entry	ptx_sim.h	/^   stack_entry( symbol_table *s, function_info *f, unsigned pc, unsigned rpc, const symbol *return_var_src, const symbol *return_var_dst, unsigned call_uid,bool is_tm )$/;"	f	struct:stack_entry
stack_entry	ptx_sim.h	/^   stack_entry() {$/;"	f	struct:stack_entry
stack_entry	ptx_sim.h	/^struct stack_entry {$/;"	s
start	tm_manager.cc	/^void tm_manager::start()$/;"	f	class:tm_manager
start_function	ptx_parser.cc	/^void start_function( int entry_point ) $/;"	f
start_transaction	ptx_sim.h	/^    void start_transaction( tm_manager_inf* tm_manager )$/;"	f	class:ptx_thread_info
statement_block	ptx.y	/^statement_block: LEFT_BRACE statement_list RIGHT_BRACE $/;"	l
statement_list	ptx.y	/^statement_list: directive_statement { add_directive(); }$/;"	l
status	tm_manager_internal.h	/^   enum tm_ring::status_t status() const { return m_status; }$/;"	f	class:tm_ring_commit_record
status_t	tm_manager_internal.h	/^enum status_t {$/;"	g	namespace:tm_ring
sub_count	ptx-stats.cc	/^    void sub_count(const ptx_instruction * pInsn, int count = 1)$/;"	f	class:ptx_inflight_memory_insn_tracker
sub_impl	instructions.cc	/^void sub_impl( const ptx_instruction *pI, ptx_thread_info *thread ) $/;"	f
subc_impl	instructions.cc	/^void subc_impl( const ptx_instruction *pI, ptx_thread_info *thread ) { inst_not_implemented(pI); }$/;"	f
subhash1	hashfunc.h	/^   unsigned int subhash1(addr_t addr)$/;"	f	class:hasht_funct::gskew_hash
subhash2	hashfunc.h	/^   unsigned int subhash2(addr_t addr)$/;"	f	class:hasht_funct::gskew_hash
successor_ids	ptx_ir.h	/^   std::set<int> successor_ids;$/;"	m	struct:basic_block_t
suld_impl	instructions.cc	/^void suld_impl( const ptx_instruction *pI, ptx_thread_info *thread ) { inst_not_implemented(pI); }$/;"	f
suq_impl	instructions.cc	/^void suq_impl( const ptx_instruction *pI, ptx_thread_info *thread ) { inst_not_implemented(pI); }$/;"	f
sured_impl	instructions.cc	/^void sured_impl( const ptx_instruction *pI, ptx_thread_info *thread ) { inst_not_implemented(pI); }$/;"	f
sust_impl	instructions.cc	/^void sust_impl( const ptx_instruction *pI, ptx_thread_info *thread ) { inst_not_implemented(pI); }$/;"	f
symbol	ptx_ir.h	/^   symbol( const char *name, const type_info *type, const char *location, unsigned size ) $/;"	f	class:symbol
symbol	ptx_ir.h	/^class symbol {$/;"	c
symbol_table	ptx_ir.cc	/^symbol_table::symbol_table( const char *scope_name, unsigned entry_point, symbol_table *parent )$/;"	f	class:symbol_table
symbol_table	ptx_ir.cc	/^symbol_table::symbol_table() $/;"	f	class:symbol_table
symbol_table	ptx_ir.h	/^class symbol_table {$/;"	c
symbolic_t	ptx_ir.h	/^   unsigned_t, symbolic_t, label_t, v_reg_t, v_float_op_t, v_double_op_t,$/;"	e	enum:operand_type
target	ptx_sim.h	/^      unsigned target() const { assert(m_valid&&m_sm_version_valid); return m_sm_version; }$/;"	f	class:ptx_version
target_header	ptx_parser.cc	/^void target_header(char* a) $/;"	f
target_header2	ptx_parser.cc	/^void target_header2(char* a, char* b) $/;"	f
target_header3	ptx_parser.cc	/^void target_header3(char* a, char* b, char* c) $/;"	f
target_inst	ptx_ir.h	/^   class ptx_instruction* target_inst;$/;"	m	struct:gpgpu_recon_t	typeref:class:gpgpu_recon_t::ptx_instruction
target_pc	ptx_ir.h	/^   address_type target_pc;$/;"	m	struct:gpgpu_recon_t
tbeginv_call	instructions.cc	/^void tbeginv_call( const ptx_instruction *pI, ptx_thread_info *thread ) $/;"	f
tcommitv_call	instructions.cc	/^void tcommitv_call( const ptx_instruction *pI, ptx_thread_info *thread ) $/;"	f
temporal_cd_metadata	tm_manager_internal.h	/^      temporal_cd_metadata() { reset(); }$/;"	f	class:value_based_tm_manager::temporal_cd_metadata
temporal_cd_metadata	tm_manager_internal.h	/^   class temporal_cd_metadata {$/;"	c	class:value_based_tm_manager
temporal_conflict_detector	tm_manager.cc	/^temporal_conflict_detector::temporal_conflict_detector() $/;"	f	class:temporal_conflict_detector
temporal_conflict_detector	tm_manager_internal.h	/^class temporal_conflict_detector$/;"	c
test_signature	bloomfilter.h	/^   bool test_signature(unsigned int bitpos) const { return m_signature.test(bitpos); }$/;"	f	class:hashtable_bits
texAddr_t	instructions.cc	/^typedef unsigned (*texAddr_t) (unsigned x, unsigned y, unsigned mx, unsigned my, size_t elem_size);$/;"	t	file:
tex_impl	instructions.cc	/^void tex_impl( const ptx_instruction *pI, ptx_thread_info *thread ) $/;"	f
tex_linf_sampling	instructions.cc	/^float tex_linf_sampling(memory_space* mem, unsigned tex_array_base, $/;"	f
tex_operand	ptx.y	/^tex_operand: LEFT_SQUARE_BRACKET IDENTIFIER COMMA { add_scalar_operand($2); }$/;"	l
texel_size	ptx_ir.h	/^   unsigned int texel_size; \/\/size in bytes, e.g. (channelDesc.x+y+z+w)\/8$/;"	m	struct:textureInfo
texel_size_numbits	ptx_ir.h	/^   unsigned int texel_size_numbits; \/\/log2(texel_size)$/;"	m	struct:textureInfo
textureInfo	ptx_ir.h	/^struct textureInfo {$/;"	s
textureNormalizeElementSigned	instructions.cc	/^float textureNormalizeElementSigned(int element, int bits)$/;"	f
textureNormalizeElementUnsigned	instructions.cc	/^float textureNormalizeElementUnsigned(unsigned int element, int bits)$/;"	f
textureNormalizeOutput	instructions.cc	/^void textureNormalizeOutput( const struct cudaChannelFormatDesc& desc, ptx_reg_t& datax, ptx_reg_t& datay, ptx_reg_t& dataz, ptx_reg_t& dataw ) $/;"	f
tm_access	tm_manager.cc	/^bool tm_manager::tm_access( memory_space *mem, memory_space_t space, bool rd, addr_t addr, void *vp, int nbytes, tm_access_uarch_info& uarch_info, mem_fetch *mf )$/;"	f	class:tm_manager
tm_bloomfilter_core_set	tm_manager.cc	/^tm_bloomfilter_core_set::tm_bloomfilter_core_set()$/;"	f	class:tm_bloomfilter_core_set
tm_bloomfilter_core_set	tm_manager_internal.h	/^class tm_bloomfilter_core_set : public tm_bloomfilter_set {$/;"	c
tm_bloomfilter_hashed_core_set	tm_manager.cc	/^tm_bloomfilter_hashed_core_set::tm_bloomfilter_hashed_core_set()$/;"	f	class:tm_bloomfilter_hashed_core_set
tm_bloomfilter_hashed_core_set	tm_manager_internal.h	/^class tm_bloomfilter_hashed_core_set : public tm_bloomfilter_set {$/;"	c
tm_bloomfilter_options	tm_manager.cc	/^tm_bloomfilter_options::tm_bloomfilter_options()$/;"	f	class:tm_bloomfilter_options
tm_bloomfilter_options	tm_manager_internal.h	/^class tm_bloomfilter_options $/;"	c
tm_bloomfilter_set	tm_manager.cc	/^tm_bloomfilter_set::tm_bloomfilter_set(bool counter_based)$/;"	f	class:tm_bloomfilter_set
tm_bloomfilter_set	tm_manager_internal.h	/^class tm_bloomfilter_set {$/;"	c
tm_checkpoint	ptx_sim.cc	/^void ptx_thread_info::tm_checkpoint()$/;"	f	class:ptx_thread_info
tm_commit	ptx_sim.cc	/^void ptx_thread_info::tm_commit() $/;"	f	class:ptx_thread_info
tm_dump_profile	tm_manager.cc	/^void tm_dump_profile()$/;"	f
tm_global_state	tm_manager_internal.h	/^   tm_global_state() : m_conflict_footprint(0), m_readonly_footprint(0), m_writeonly_footprint(0) { } $/;"	f	class:tm_global_state
tm_global_state	tm_manager_internal.h	/^class tm_global_state {$/;"	c
tm_global_statistics	tm_manager_internal.h	/^    tm_global_statistics() $/;"	f	class:tm_global_statistics
tm_global_statistics	tm_manager_internal.h	/^class tm_global_statistics {$/;"	c
tm_logical_timestamp_t	tm_manager_internal.h	/^typedef std::pair<tm_timestamp_t, warp_logical_id> tm_logical_timestamp_t;$/;"	t
tm_manager	tm_manager.cc	/^tm_manager::tm_manager(	ptx_thread_info *thread, bool timing_mode ) $/;"	f	class:tm_manager
tm_manager	tm_manager_internal.h	/^class tm_manager : public tm_manager_inf$/;"	c
tm_manager_inf	tm_manager.cc	/^tm_manager_inf::tm_manager_inf( ptx_thread_info *thread, bool timing_mode )$/;"	f	class:tm_manager_inf
tm_manager_inf	tm_manager.h	/^class tm_manager_inf$/;"	c
tm_mem_bucket	tm_manager_internal.h	/^      tm_mem_bucket() $/;"	f	struct:tm_manager::tm_mem_bucket
tm_mem_bucket	tm_manager_internal.h	/^   struct tm_mem_bucket $/;"	s	class:tm_manager
tm_mem_hash_t	tm_manager_internal.h	/^   typedef std::map<unsigned,tm_mem_bucket> tm_mem_hash_t;$/;"	t	class:tm_manager
tm_mem_t	tm_manager_internal.h	/^   typedef std::map<memory_space*, tm_mem_hash_t> tm_mem_t;$/;"	t	class:tm_manager
tm_num_transactions	ptx_sim.h	/^    unsigned tm_num_transactions() const$/;"	f	class:ptx_thread_info
tm_options	tm_manager.cc	/^tm_options::tm_options()$/;"	f	class:tm_options
tm_options	tm_manager_internal.h	/^class tm_options : public OptionChecker$/;"	c
tm_reg_options	tm_manager.cc	/^void tm_reg_options(option_parser_t opp) $/;"	f
tm_reg_state	ptx_sim.h	/^enum tm_reg_state {$/;"	g
tm_reg_state_map_t	ptx_sim.h	/^   typedef tr1_hash_map<const symbol*,tm_reg_state> tm_reg_state_map_t;$/;"	t	class:ptx_thread_info
tm_ring	tm_manager_internal.h	/^namespace tm_ring {$/;"	n
tm_ring_commit_record	tm_manager.cc	/^tm_ring_commit_record::tm_ring_commit_record(unsigned tuid, const addr_set_t& write_set, int commit_time)$/;"	f	class:tm_ring_commit_record
tm_ring_commit_record	tm_manager_internal.h	/^class tm_ring_commit_record$/;"	c
tm_ring_compressed_record	tm_manager.cc	/^tm_ring_compressed_record::tm_ring_compressed_record(int base_index, unsigned int n_records, unsigned int compressed_size)$/;"	f	class:tm_ring_compressed_record
tm_ring_compressed_record	tm_manager_internal.h	/^class tm_ring_compressed_record $/;"	c
tm_ring_global	tm_manager.cc	/^tm_ring_global::tm_ring_global()$/;"	f	class:tm_ring_global
tm_ring_global	tm_manager_internal.h	/^class tm_ring_global$/;"	c
tm_ring_stats	tm_manager_internal.h	/^   tm_ring_stats() $/;"	f	class:tm_ring_stats
tm_ring_stats	tm_manager_internal.h	/^class tm_ring_stats$/;"	c
tm_rollback	ptx_sim.cc	/^void ptx_thread_info::tm_rollback()$/;"	f	class:ptx_thread_info
tm_sample_conflict_footprint	tm_manager.cc	/^void tm_sample_conflict_footprint()$/;"	f
tm_set_callback	ptx_sim.h	/^    void tm_set_callback(tm_callback_t *callback) $/;"	f	class:ptx_thread_info
tm_statistics	tm_manager.cc	/^void tm_statistics(FILE *fout)$/;"	f
tm_statistics_visualizer	tm_manager.cc	/^void tm_statistics_visualizer( gzFile visualizer_file ) $/;"	f
tm_stats_set	tm_manager_internal.h	/^   	typedef std::set<unsigned> tm_stats_set;$/;"	t	class:tm_manager::trans_stats
tm_timestamp_t	tm_manager_internal.h	/^typedef unsigned long long tm_timestamp_t; $/;"	t
to_string	ptx_ir.cc	/^std::string ptx_instruction::to_string() const$/;"	f	class:ptx_instruction
track_delta_change	tm_manager.cc	/^void track_delta_change(bool before, bool after, int& value)$/;"	f
trans_stats	tm_manager_internal.h	/^   	trans_stats() $/;"	f	class:tm_manager::trans_stats
trans_stats	tm_manager_internal.h	/^   class trans_stats{$/;"	c	class:tm_manager
translate_pc_to_ptxlineno	cuda-sim.cc	/^unsigned translate_pc_to_ptxlineno(unsigned pc)$/;"	f
trap_impl	instructions.cc	/^void trap_impl( const ptx_instruction *pI, ptx_thread_info *thread ) { inst_not_implemented(pI); }$/;"	f
tuid	tm_manager.h	/^   unsigned tuid() const { return m_thread_uid; }$/;"	f	class:tm_manager_inf
tuid_set_t	tm_manager_internal.h	/^typedef std::unordered_set<unsigned> tuid_set_t;$/;"	t
tuid_to_thread_t	tm_manager_internal.h	/^	typedef tr1_hash_map<unsigned,ptx_thread_info*> tuid_to_thread_t;$/;"	t	class:tm_global_state
tuple	ptxinfo.y	/^tuple: INT_OPERAND PLUS INT_OPERAND BYTES { g_declared=$1; g_system=$3; }$/;"	l
tvec_t	bloomfilter.h	/^   typedef std::bitset<s_nthread_limit> tvec_t; $/;"	t	class:hashtable_bits_mt
twin_operand	ptx.y	/^twin_operand : IDENTIFIER PLUS IDENTIFIER { add_double_operand($1,$3); change_double_operand_type(1); }$/;"	l
tx_begin	ptx_sim.cc	/^void ptx_thread_info::tx_begin( const ptx_instruction *pI, bool timing_mode ) {$/;"	f	class:ptx_thread_info
tx_commit	ptx_sim.cc	/^bool ptx_thread_info::tx_commit( const ptx_instruction *pI, bool auto_self_abort ) {$/;"	f	class:ptx_thread_info
tx_load	instructions.cc	/^void tx_load( const ptx_instruction *pI, ptx_thread_info *thread,$/;"	f
tx_store	instructions.cc	/^void tx_store( const ptx_instruction *pI, ptx_thread_info *thread, $/;"	f
txq_impl	instructions.cc	/^void txq_impl( const ptx_instruction *pI, ptx_thread_info *thread ) { inst_not_implemented(pI); }$/;"	f
type	ptx_ir.h	/^   const type_info *type() const { return m_type;}$/;"	f	class:symbol
type	ptx_sim.h	/^   int type;$/;"	m	struct:param_t
type_decode	ptx_ir.cc	/^unsigned type_info_key::type_decode( int type, size_t &size, int &basic_type )$/;"	f	class:type_info_key
type_decode	ptx_ir.cc	/^unsigned type_info_key::type_decode( size_t &size, int &basic_type ) const$/;"	f	class:type_info_key
type_info	ptx_ir.h	/^   type_info( symbol_table *scope, type_info_key t )$/;"	f	class:type_info
type_info	ptx_ir.h	/^class type_info {$/;"	c
type_info_key	ptx_ir.h	/^   type_info_key( memory_space_t space_spec, int scalar_type_spec, int vector_spec, int alignment_spec, int extern_spec, int array_dim )$/;"	f	class:type_info_key
type_info_key	ptx_ir.h	/^   type_info_key()$/;"	f	class:type_info_key
type_info_key	ptx_ir.h	/^class type_info_key {$/;"	c
type_info_key_compare	ptx_ir.h	/^struct type_info_key_compare {$/;"	s
type_spec	ptx.y	/^type_spec: scalar_type $/;"	l
u128	ptx_sim.h	/^   } u128;$/;"	m	union:ptx_reg_t	typeref:struct:ptx_reg_t::__anon5
u16	ptx_sim.h	/^   unsigned short    u16;$/;"	m	union:ptx_reg_t
u2f	instructions.cc	/^ptx_reg_t u2f( ptx_reg_t x, unsigned from_width, unsigned to_width, int to_sign, int rounding_mode, int saturation_mode )$/;"	f
u32	ptx_sim.h	/^   unsigned int      u32;$/;"	m	union:ptx_reg_t
u64	ptx_sim.h	/^   unsigned long long   u64;$/;"	m	union:ptx_reg_t
u8	ptx_sim.h	/^   unsigned char     u8;$/;"	m	union:ptx_reg_t
uid	ptx_ir.h	/^   unsigned uid() const { return m_uid; }$/;"	f	class:symbol
uid	ptx_ir.h	/^   unsigned uid() const { return m_uid;}$/;"	f	class:ptx_instruction
uid	tm_manager.h	/^   unsigned uid() const { return m_uid; }$/;"	f	class:tm_manager_inf
uint4	cuda-math.h	/^   struct uint4 {$/;"	s	namespace:cuda_math
uint4	cuda-math.h	/^   typedef struct uint4 uint4;$/;"	t	namespace:cuda_math	typeref:struct:cuda_math::uint4
undef_t	ptx_ir.h	/^   v_int_t, v_unsigned_t, undef_t$/;"	e	enum:operand_type
unit_test	bloomfilter.cc	/^void versioning_bloomfilter::unit_test()$/;"	f	class:versioning_bloomfilter
unit_test	bloomfilter.cc	/^void versioning_hashtable::unit_test()$/;"	f	class:versioning_hashtable
unregister_thread	tm_manager.cc	/^void tm_global_state::unregister_thread( ptx_thread_info *thrd )$/;"	f	class:tm_global_state
unselect_thread	bloomfilter.cc	/^void bloomfilter_mt::unselect_thread()$/;"	f	class:bloomfilter_mt
unselect_thread	bloomfilter.h	/^   void unselect_thread() { m_selected_thread = s_null_tid; } $/;"	f	class:hashtable_bits_mt
unsigned_t	ptx_ir.h	/^   unsigned_t, symbolic_t, label_t, v_reg_t, v_float_op_t, v_double_op_t,$/;"	e	enum:operand_type
update_access_bloomfilter	tm_manager.cc	/^void tm_bloomfilter_core_set::update_access_bloomfilter(const std::vector<int>& update_positions) $/;"	f	class:tm_bloomfilter_core_set
update_access_sets	tm_manager.cc	/^void tm_manager::update_access_sets(addr_t addr, unsigned nbytes, bool rd, bool detect_conflict) $/;"	f	class:tm_manager
update_current_pts	tm_manager_internal.h	/^      void update_current_pts( tm_timestamp_t new_pts ) {$/;"	f	class:logical_timestamp_based_tm_manager::logical_temporal_cd_metadata
update_largest_pts	tm_manager_internal.h	/^   void update_largest_pts(tm_timestamp_t pts) {$/;"	f	class:logical_temporal_conflict_detector
update_last_written_time	tm_manager_internal.h	/^      void update_last_written_time( tm_timestamp_t new_time ) {$/;"	f	class:value_based_tm_manager::temporal_cd_metadata
update_logical_info	tm_manager.cc	/^void logical_timestamp_based_tm_manager::update_logical_info(addr_t addr, bool rd, int nbytes, memory_space_t space) {$/;"	f	class:logical_timestamp_based_tm_manager
update_logical_info	tm_manager_internal.h	/^   virtual void update_logical_info(addr_t addr, bool rd, int nbytes, memory_space_t space) {};$/;"	f	class:ring_tm_manager
update_logical_info	tm_manager_internal.h	/^   virtual void update_logical_info(addr_t addr, bool rd, int nbytes, memory_space_t space) {};$/;"	f	class:tm_manager
update_logical_info	tm_manager_internal.h	/^   virtual void update_logical_info(addr_t addr, bool rd, int nbytes, memory_space_t space) {};$/;"	f	class:value_based_tm_manager
update_logical_timestamp	tm_manager.cc	/^void logical_temporal_conflict_detector::update_logical_timestamp(addr_t addr, bool rd, tm_timestamp_t new_time, $/;"	f	class:logical_temporal_conflict_detector
update_logical_version	bloomfilter.cc	/^void versioning_bloomfilter::update_logical_version(addr_t addr, unsigned int version, unsigned int shader_id, unsigned int warp_id)$/;"	f	class:versioning_bloomfilter
update_logical_version	bloomfilter.cc	/^void versioning_hashtable::update_logical_version(addr_t addr, unsigned int version, unsigned int shader_id, unsigned int warp_id)$/;"	f	class:versioning_hashtable
update_pc	ptx_sim.h	/^   void update_pc( )$/;"	f	class:ptx_thread_info
update_tvec_hash	bloomfilter.cc	/^void hashtable_bits_mt::update_tvec_hash(unsigned int bitpos)$/;"	f	class:hashtable_bits_mt
update_version	bloomfilter.cc	/^void versioning_bloomfilter::update_version(addr_t addr, unsigned int version)$/;"	f	class:versioning_bloomfilter
update_version	bloomfilter.cc	/^void versioning_hashtable::update_version(addr_t addr, unsigned int version)$/;"	f	class:versioning_hashtable
update_version_dec	bloomfilter.cc	/^void versioning_bloomfilter::update_version_dec(addr_t addr, unsigned int version)$/;"	f	class:versioning_bloomfilter
update_version_dec	bloomfilter.cc	/^void versioning_hashtable::update_version_dec(addr_t addr, unsigned int version)$/;"	f	class:versioning_hashtable
update_version_inc	bloomfilter.cc	/^void versioning_bloomfilter::update_version_inc(addr_t addr, unsigned int version)$/;"	f	class:versioning_bloomfilter
update_version_inc	bloomfilter.cc	/^void versioning_hashtable::update_version_inc(addr_t addr, unsigned int version)$/;"	f	class:versioning_hashtable
update_word	tm_manager.cc	/^void temporal_conflict_detector::update_word( addr_t addr, tm_timestamp_t new_time) $/;"	f	class:temporal_conflict_detector
upperloweradd	hashfunc.h	/^template<int upperlowerbound> unsigned int upperloweradd(unsigned int size, addr_t addr)$/;"	f	namespace:hasht_funct
upperlowerxor	hashfunc.h	/^template<int upperlowerbound> unsigned int upperlowerxor(unsigned int size, addr_t addr)$/;"	f	namespace:hasht_funct
v_double_op_t	ptx_ir.h	/^   unsigned_t, symbolic_t, label_t, v_reg_t, v_float_op_t, v_double_op_t,$/;"	e	enum:operand_type
v_float_op_t	ptx_ir.h	/^   unsigned_t, symbolic_t, label_t, v_reg_t, v_float_op_t, v_double_op_t,$/;"	e	enum:operand_type
v_int_t	ptx_ir.h	/^   v_int_t, v_unsigned_t, undef_t$/;"	e	enum:operand_type
v_reg_t	ptx_ir.h	/^   unsigned_t, symbolic_t, label_t, v_reg_t, v_float_op_t, v_double_op_t,$/;"	e	enum:operand_type
v_unsigned_t	ptx_ir.h	/^   v_int_t, v_unsigned_t, undef_t$/;"	e	enum:operand_type
vabsdiff_impl	instructions.cc	/^void vabsdiff_impl( const ptx_instruction *pI, ptx_thread_info *thread ) { inst_not_implemented(pI); }$/;"	f
vadd_impl	instructions.cc	/^void vadd_impl( const ptx_instruction *pI, ptx_thread_info *thread ) { inst_not_implemented(pI); }$/;"	f
validate	tm_manager.cc	/^void logical_timestamp_based_tm_manager::validate() {$/;"	f	class:logical_timestamp_based_tm_manager
validate	tm_manager.cc	/^void value_based_tm_manager::validate() $/;"	f	class:value_based_tm_manager
validate_addr	tm_manager.cc	/^bool ring_tm_manager::validate_addr( addr_t addr ) { assert(0); return false; }$/;"	f	class:ring_tm_manager
validate_addr	tm_manager.cc	/^bool tm_manager::validate_addr( addr_t addr ) { assert(0); return false; }$/;"	f	class:tm_manager
validate_addr	tm_manager.cc	/^bool value_based_tm_manager::validate_addr( addr_t addr ) $/;"	f	class:value_based_tm_manager
validate_all	tm_manager.cc	/^bool logical_timestamp_based_tm_manager::validate_all(bool useTemporalCD) {$/;"	f	class:logical_timestamp_based_tm_manager
validate_all	tm_manager.cc	/^bool value_based_tm_manager::validate_all( bool useTemporalCD ) $/;"	f	class:value_based_tm_manager
validate_all	tm_manager_internal.h	/^   virtual bool validate_all( bool useTemporalCD ) {$/;"	f	class:tm_manager
validate_or_crash	tm_manager.cc	/^void tm_manager::validate_or_crash( ) { assert(0); }$/;"	f	class:tm_manager
validate_or_crash	tm_manager.cc	/^void value_based_tm_manager::validate_or_crash( ) $/;"	f	class:value_based_tm_manager
value_based_tm_manager	tm_manager.cc	/^value_based_tm_manager::value_based_tm_manager( ptx_thread_info *thread, bool timing_mode )$/;"	f	class:value_based_tm_manager
value_based_tm_manager	tm_manager_internal.h	/^class value_based_tm_manager : public tm_manager $/;"	c
var_spec	ptx.y	/^var_spec: space_spec $/;"	l
var_spec_list	ptx.y	/^var_spec_list: var_spec $/;"	l
variable_declaration	ptx.y	/^variable_declaration: variable_spec identifier_list { add_variables(); }$/;"	l
variable_spec	ptx.y	/^variable_spec: var_spec_list { set_variable_type(); }$/;"	l
vec_name1	ptx_ir.h	/^   const std::string &vec_name1() const$/;"	f	class:operand_info
vec_name2	ptx_ir.h	/^   const std::string &vec_name2() const$/;"	f	class:operand_info
vec_name3	ptx_ir.h	/^   const std::string &vec_name3() const$/;"	f	class:operand_info
vec_name4	ptx_ir.h	/^   const std::string &vec_name4() const$/;"	f	class:operand_info
vec_symbol	ptx_ir.h	/^   const symbol* vec_symbol(int idx) const $/;"	f	class:operand_info
vector_operand	ptx.y	/^vector_operand: LEFT_BRACE IDENTIFIER COMMA IDENTIFIER RIGHT_BRACE { add_2vector_operand($2,$4); }$/;"	l
vector_spec	ptx.y	/^vector_spec:  V2_TYPE {  add_option(V2_TYPE); func_header_info(".v2");}$/;"	l
vector_t	ptx_ir.h	/^   reg_t, vector_t, builtin_t, address_t, memory_t, float_op_t, double_op_t, int_t, $/;"	e	enum:operand_type
ver	ptx_sim.h	/^      float    ver() const { assert(m_valid); return m_ptx_version; }$/;"	f	class:ptx_version
version_header	ptx_parser.cc	/^void version_header(double a) {}  \/\/intentional dummy function$/;"	f
versioning_bloomfilter	bloomfilter.cc	/^versioning_bloomfilter::versioning_bloomfilter(const versioning_bloomfilter& other)$/;"	f	class:versioning_bloomfilter
versioning_bloomfilter	bloomfilter.cc	/^versioning_bloomfilter::versioning_bloomfilter(unsigned int size, const std::vector<int>& funct_ids, unsigned int n_functs)$/;"	f	class:versioning_bloomfilter
versioning_bloomfilter	bloomfilter.h	/^class versioning_bloomfilter$/;"	c
versioning_hashtable	bloomfilter.cc	/^versioning_hashtable::versioning_hashtable(unsigned int size, int funct_id)$/;"	f	class:versioning_hashtable
versioning_hashtable	bloomfilter.h	/^class versioning_hashtable$/;"	c
visualizer_print	tm_manager.cc	/^void tm_global_statistics::visualizer_print(gzFile visualizer_file) $/;"	f	class:tm_global_statistics
vmad_impl	instructions.cc	/^void vmad_impl( const ptx_instruction *pI, ptx_thread_info *thread ) { inst_not_implemented(pI); }$/;"	f
vmax_impl	instructions.cc	/^void vmax_impl( const ptx_instruction *pI, ptx_thread_info *thread ) { inst_not_implemented(pI); }$/;"	f
vmin_impl	instructions.cc	/^void vmin_impl( const ptx_instruction *pI, ptx_thread_info *thread ) { inst_not_implemented(pI); }$/;"	f
vote_all	ptx_ir.h	/^   enum vote_mode_t { vote_any, vote_all, vote_uni, vote_ballot };$/;"	e	enum:ptx_instruction::vote_mode_t
vote_any	ptx_ir.h	/^   enum vote_mode_t { vote_any, vote_all, vote_uni, vote_ballot };$/;"	e	enum:ptx_instruction::vote_mode_t
vote_ballot	ptx_ir.h	/^   enum vote_mode_t { vote_any, vote_all, vote_uni, vote_ballot };$/;"	e	enum:ptx_instruction::vote_mode_t
vote_impl	instructions.cc	/^void vote_impl( const ptx_instruction *pI, ptx_thread_info *thread ) $/;"	f
vote_mode	ptx_ir.h	/^   enum vote_mode_t vote_mode() const { return m_vote_mode; }$/;"	f	class:ptx_instruction
vote_mode_t	ptx_ir.h	/^   enum vote_mode_t { vote_any, vote_all, vote_uni, vote_ballot };$/;"	g	class:ptx_instruction
vote_uni	ptx_ir.h	/^   enum vote_mode_t { vote_any, vote_all, vote_uni, vote_ballot };$/;"	e	enum:ptx_instruction::vote_mode_t
vset_impl	instructions.cc	/^void vset_impl( const ptx_instruction *pI, ptx_thread_info *thread ) { inst_not_implemented(pI); }$/;"	f
vshl_impl	instructions.cc	/^void vshl_impl( const ptx_instruction *pI, ptx_thread_info *thread ) { inst_not_implemented(pI); }$/;"	f
vshr_impl	instructions.cc	/^void vshr_impl( const ptx_instruction *pI, ptx_thread_info *thread ) { inst_not_implemented(pI); }$/;"	f
vsub_impl	instructions.cc	/^void vsub_impl( const ptx_instruction *pI, ptx_thread_info *thread ) { inst_not_implemented(pI); }$/;"	f
w	cuda-math.h	/^      float x, y, z, w;$/;"	m	struct:cuda_math::float4
w	cuda-math.h	/^      int x, y, z, w;$/;"	m	struct:cuda_math::int4
w	cuda-math.h	/^      unsigned int x, y, z, w;$/;"	m	struct:cuda_math::uint4
warp_divergence	ptx-stats.cc	/^    unsigned long long warp_divergence; \/\/ number of warp divergence occured at this instruction$/;"	m	class:ptx_file_line_stats	file:
warp_exit	cuda-sim.cc	/^void functionalCoreSim::warp_exit( unsigned warp_id )$/;"	f	class:functionalCoreSim
warp_level_conflict_exist	tm_manager_internal.h	/^   bool warp_level_conflict_exist(unsigned index) {$/;"	f	class:logical_temporal_conflict_detector
warp_logical_id	tm_manager_internal.h	/^typedef std::pair<unsigned int, unsigned int> warp_logical_id;$/;"	t
warp_waiting_at_barrier	cuda-sim.h	/^    virtual bool warp_waiting_at_barrier( unsigned warp_id ) const  $/;"	f	class:functionalCoreSim
watched	tm_manager.cc	/^bool tm_manager_inf::watched() const $/;"	f	class:tm_manager_inf
whichspace	cuda-sim.cc	/^memory_space_t whichspace( addr_t addr )$/;"	f
wid	tm_manager.h	/^   unsigned wid() const { return m_thread_hwwid; }$/;"	f	class:tm_manager_inf
wrap	instructions.cc	/^unsigned wrap( unsigned x, unsigned y, unsigned mx, unsigned my, size_t elem_size )$/;"	f
write	memory.cc	/^template<unsigned BSIZE> void memory_space_impl<BSIZE>::write( mem_addr_t addr, size_t length, const void *data, class ptx_thread_info *thd, const ptx_instruction *pI)$/;"	f	class:memory_space_impl
write	memory.h	/^   void write( unsigned offset, size_t length, const unsigned char *data )$/;"	f	class:mem_storage
write_access_log	tm_manager.cc	/^void tm_manager::write_access_log()$/;"	f	class:tm_manager
write_only	tm_manager_internal.h	/^   bool write_only() const { return (m_tuids_have_read.empty() && !m_tuids_have_written.empty()); }$/;"	f	struct:conflict_set
write_stats	tm_manager.cc	/^void tm_manager::write_stats(){$/;"	f	class:tm_manager
x	cuda-math.h	/^      float x, y, z, w;$/;"	m	struct:cuda_math::float4
x	cuda-math.h	/^      float x, y;$/;"	m	struct:cuda_math::float2
x	cuda-math.h	/^      int x, y, z, w;$/;"	m	struct:cuda_math::int4
x	cuda-math.h	/^      unsigned int x, y, z, w;$/;"	m	struct:cuda_math::uint4
xor_impl	instructions.cc	/^void xor_impl( const ptx_instruction *pI, ptx_thread_info *thread ) $/;"	f
y	cuda-math.h	/^      float x, y, z, w;$/;"	m	struct:cuda_math::float4
y	cuda-math.h	/^      float x, y;$/;"	m	struct:cuda_math::float2
y	cuda-math.h	/^      int x, y, z, w;$/;"	m	struct:cuda_math::int4
y	cuda-math.h	/^      unsigned int x, y, z, w;$/;"	m	struct:cuda_math::uint4
z	cuda-math.h	/^      float x, y, z, w;$/;"	m	struct:cuda_math::float4
z	cuda-math.h	/^      int x, y, z, w;$/;"	m	struct:cuda_math::int4
z	cuda-math.h	/^      unsigned int x, y, z, w;$/;"	m	struct:cuda_math::uint4
zext	instructions.cc	/^ptx_reg_t zext( ptx_reg_t x, unsigned from_width, unsigned to_width, int to_sign, int rounding_mode, int saturation_mode )$/;"	f
~access_record	tm_manager.cc	/^tm_manager::access_record::~access_record()$/;"	f	class:tm_manager::access_record
~arg_buffer_t	ptx_ir.h	/^   ~arg_buffer_t()$/;"	f	class:arg_buffer_t
~bloomfilter	bloomfilter.cc	/^bloomfilter::~bloomfilter()$/;"	f	class:bloomfilter
~bloomfilter_mt	bloomfilter.cc	/^bloomfilter_mt::~bloomfilter_mt()$/;"	f	class:bloomfilter_mt
~functionalCoreSim	cuda-sim.h	/^    virtual ~functionalCoreSim(){$/;"	f	class:functionalCoreSim
~hashtable	bloomfilter.h	/^   virtual ~hashtable() {} $/;"	f	class:hashtable
~logical_temporal_conflict_detector	tm_manager.cc	/^logical_temporal_conflict_detector::~logical_temporal_conflict_detector() $/;"	f	class:logical_temporal_conflict_detector
~logical_timestamp_based_tm_manager	tm_manager_internal.h	/^   virtual ~logical_timestamp_based_tm_manager() {};$/;"	f	class:logical_timestamp_based_tm_manager
~mem_storage	memory.h	/^   ~mem_storage()$/;"	f	class:mem_storage
~memory_space	memory.h	/^   virtual ~memory_space() {}$/;"	f	class:memory_space
~ptx_thread_info	ptx_sim.cc	/^ptx_thread_info::~ptx_thread_info()$/;"	f	class:ptx_thread_info
~ring_tm_manager	tm_manager.cc	/^ring_tm_manager::~ring_tm_manager()$/;"	f	class:ring_tm_manager
~temporal_conflict_detector	tm_manager.cc	/^temporal_conflict_detector::~temporal_conflict_detector() $/;"	f	class:temporal_conflict_detector
~tm_manager	tm_manager.cc	/^tm_manager::~tm_manager()$/;"	f	class:tm_manager
~tm_manager_inf	tm_manager.cc	/^tm_manager_inf::~tm_manager_inf() $/;"	f	class:tm_manager_inf
~value_based_tm_manager	tm_manager.cc	/^value_based_tm_manager::~value_based_tm_manager()$/;"	f	class:value_based_tm_manager
~versioning_bloomfilter	bloomfilter.cc	/^versioning_bloomfilter::~versioning_bloomfilter()$/;"	f	class:versioning_bloomfilter
~versioning_hashtable	bloomfilter.h	/^   virtual ~versioning_hashtable() {} $/;"	f	class:versioning_hashtable
